<!--🎮 Zombie Survivor  ✨ Version: 1.1  🖋️ Tác giả: Dang -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Zombie Survivor - Dang</title>
<style>
  :root {
  /* 🎨 Màu sắc chính */
  --color-bg-dark: #111;
  --color-primary: #00ffff;
  --color-accent: gold;
  --color-danger: #ff4c4c;
  --color-text: #e0f7fa;
  --color-hover-bg: #22404c;
  --color-hover-border: #3d6c78;
  --color-title: #aefeff;
  --glow-title: 0 0 6px #7f7fff, 0 0 12px #4d4dfb;
 
  /* 🌈 Màu sắc giao diện */
  --menu-width: 24rem;
  --menu-min-height: 20rem;
  --menu-radius: 1rem;
  --menu-padding: 2rem 1.5rem;

  /* 🔘 Màu button riêng */
  --btn-bg: #1a2b33;
  --btn-border: #294e5a;

  /* 🔤 Kích thước font chữ */
  --font-xs: 0.75rem;
  --font-sm: 0.9rem;
  --font-md: 1rem;
  --font-lg: 1.25rem;
  --font-xl: 1.5rem;
  --font-xxl: 2.5rem;

  /* 📏 Kích thước padding/margin chuẩn */
  --space-xs: 0.4rem;
  --space-sm: 0.6rem;
  --space-md: 1rem;
  --space-lg: 1.5rem;
  --space-xl: 2rem;

  /* 🌟 Độ sáng bóng / hiệu ứng */
  --glow-primary: 0 0 8px var(--color-primary);
  --glow-accent: 0 0 8px var(--color-accent);
}

  body { margin: 0; background: #111; overflow: hidden; font-family: sans-serif; }
  canvas { display: block; margin: auto; transition: background 1s ease; }
/* 🎯 Giao diện chính */
#ui {
  position: absolute;
  top: 0vh; /* cách top theo chiều cao màn hình */
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 0.5rem; /* khoảng cách giữa các nút */
  padding: 0.7rem 1.5rem; 
  background: rgb(0, 0, 0); /* nền trong suốt */
  border-radius: 0rem;
  width: 90%; /* tỷ lệ theo chiều ngang */
  max-width: 57rem; /* giới hạn tối đa */
  justify-content: center;
  z-index: 1000;
  flex-wrap: wrap;
}

/* 🔘 Nút trong UI (nhỏ gọn hơn nút mặc định) */
#ui button {
  padding: 0.6rem 0.6rem;
  font-size: 0.75rem;
  min-width: 4.5rem;
  margin-bottom: 0.6rem;
  margin-top: 0.6rem;
}

/* 🔘 Nút mặc định cho toàn giao diện */
button {
  font-family: 'Segoe UI', sans-serif;
  padding: 0.65rem 1.25rem;
  font-size: 1rem;
  cursor: pointer;
  min-width: 5rem;
  text-align: center;
  background-color: #1a2b33;
  border: 0.125rem solid #294e5a;
  border-radius: 0.5rem;
  color: #e0f7fa;
  transition: all 0.2s ease;
  box-shadow: 0 0.125rem 0.3rem rgba(0, 0, 0, 0.2);
}

/* 🔁 Hiệu ứng hover cho nút */
button:hover {
  background-color: #22404c;
  border-color: #3d6c78;
  color: #ffffff;
  transform: translateY(-0.06rem);
}

/* 🖱 Hiệu ứng khi click giữ */
button:active {
  transform: scale(0.97);
  box-shadow: 0 0.06rem 0.2rem rgba(0, 0, 0, 0.3);
}

/* ✳️ Nút đang active (được chọn) */
button.active {
  border-color: #00ffff;
  box-shadow: 0 0 0.625rem #00ffffaa;
}

/* Trạng thái active dùng cho nhiều thành phần */
.active {
  outline: 0.125rem solid gold;
  border-radius: 0.5rem;
}

/* 📊 Vùng hiển thị điểm số hoặc thông tin */
#score {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-width: 7.5rem;
  text-align: center;
  color: white;
  font-size: 1rem;
  padding: 0.3rem 0.6rem;
}

/* 🔄 Nút restart đặc biệt */
#restartBtn {
  padding: 0.75rem 1.75rem;
  font-weight: bold;
  background-color: #1c2e36;
  border: 0.125rem solid #3a6b75;
  border-radius: 0.5rem;
  font-size: 1rem;
  color: #aefeff;
  cursor: pointer;
  transition: 0.25s ease;
}

/* 🖱 Hover cho restart */
#restartBtn:hover {
  background-color: #28515f;
  color: white;
  transform: translateY(-0.06rem);
}

/* ⏳ Hiển thị đồng hồ đếm wave */
#waveTimerDisplay {
  position: fixed;
  top: 12vh;
  left: 46%;
  transform: translateX(-50%);
  font-size: 1.2rem;
  color: gold;
  z-index: 10;
  text-shadow: 0 0 8px gold;
  font-weight: bold;
  font-family: 'Courier New', monospace;
  letter-spacing: 0.1rem;
  pointer-events: none;
}

/* 🌊 Popup khi bắt đầu Wave */
#wavePopup {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 2.5rem;
  font-weight: bold;
  color: #fff3b0;
  text-shadow:
    0 0 6px #ffd54f,
    0 0 12px #ffb300;
  background: none;
  border: none;
  pointer-events: none;
  z-index: 1000;
  transition: opacity 0.5s ease;
  opacity: 0;
}

/* ✨ Animation xuất hiện mềm mượt */
@keyframes waveFade {
  0% {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.7);
  }
  50% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1.05);
  }
  100% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
}

/* 📋 Menu bắt đầu game */
#startMenu {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  width: 90%;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  border-radius: var(--menu-radius);
  padding: var(--menu-padding);
  max-width: var(--menu-width);
  min-height: var(--menu-min-height);
  text-align: center;
  background: linear-gradient(to bottom, #0e1a26, #0a121a);
  backdrop-filter: blur(6px);
  border: 1px solid #446688;
  box-shadow:
    0 0 8px rgba(102, 170, 255, 0.1),
    inset 0 0 6px rgba(102, 170, 255, 0.05);
  z-index: 9999;
}
#startMenu:hover {
  box-shadow:
    0 0 12px rgb(0, 153, 255),
    inset 0 0 8px rgba(0, 187, 255, 0.393);
}
#startMenu .btn-group {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 1rem;
}
#startMenu button {
  min-width: 10rem;
}

/* 🌟 Popup khi lên cấp */
#levelUpPopup {
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 2.5rem;
  color: gold;
  font-weight: bold;
  text-shadow: 0 0 15px #ffff00;
  display: none;
  z-index: 2000;
}

/* 💀 Panel Game Over hiển thị khi thua */
.gameOverPanel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  display: none;
  flex-direction: column;
  align-items: center;
  backdrop-filter: blur(6px);
  z-index: 2000;
  padding: 2rem 1rem;
  border: 2px solid #ff5722;
  background: linear-gradient(145deg, #1a0f0f, #300d0d);
  box-shadow: 0 0 1rem #ff572288;
  border-radius: 1rem;
  text-align: center;
}

/* 🎯 Tiêu đề Game Over */
.gameOverTitle {
  color: #ff5722;
  font-size: 2.5rem;
  text-shadow: 0 0 4px #ffff00, 0 0 4px #ffff00;
  margin-bottom: 1rem;
}

/* 🔁 Nút Chơi lại trong Game Over Panel */
.restartButton {
  margin-top: 1rem;
  padding: 0.75rem 2rem;
  font-size: 1.2rem;
  font-weight: 300;
  background-color: #330000;
  color: #fff5cc;
  border: 2px solid #ff9800;
  border-radius: 0.75rem;
  cursor: pointer;
  box-shadow: 0 0 0.5rem #ff5722aa;
  transition: all 0.25s ease;
  text-shadow: 0 0 3px #ffaa00;
}

.restartButton:hover {
  background-color: #551100;
  color: #ffffff;
  transform: scale(1.05);
  box-shadow: 0 0 1rem #ff5722cc;
}

/* 🕹️ Tiêu đề game ở menu bắt đầu */
.gameTitle {
  font-size: 2.5rem;
  font-weight: 900;
  color: var(--color-title);
  text-shadow: var(--glow-title);
  margin-bottom: 1.5rem;
  font-family: 'Segoe UI', sans-serif;
}

/* ⚠️ Popup cảnh báo (dùng cho showWarning) */
.warningPopup{
  position:fixed;
  top:20%;                /* ① đặt tâm dọc  */
  left:50%;               /* ② đặt tâm ngang */
  transform:translate(-50%,-50%); /* ③ kéo ngược lại 50 % kích thước chính nó */
  background:rgba(0,32,64,.9);
  color:var(--color-text);
  padding:var(--space-sm) var(--space-lg);
  border-radius:.75rem;
  font:var(--font-md) 'Segoe UI',sans-serif;
  font-weight:500;
  z-index:9999;
  box-shadow:0 0 10px #00bcd4aa;
  pointer-events:none;
  animation:popupFade 1.5s ease-out forwards;
  max-width:70vw;         /* nếu text quá dài sẽ tự xuống hàng */
  text-align:center;
}

/*  Vì transform nay đã chứa translate(-50%,-50%),
    animation chỉ lắc trục Y thêm một chút  */
@keyframes popupFade{
  0%   {opacity:0; transform:translate(-50%,-30%);}
  10%  {opacity:1; transform:translate(-50%,-50%);}
  90%  {opacity:1; transform:translate(-50%,-50%);}
  100% {opacity:0; transform:translate(-50%,-70%);}
}
#notificationContainer{
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translate(-50%, -50%);   /* căn đúng tâm như popup cũ */
  display: flex;
  flex-direction: column;             /* xếp dọc */
  align-items: center;                /* mỗi popup vẫn giữa ngang */
  gap: .5rem;                         /* khoảng cách giữa các popup */
  pointer-events: none;
  z-index: 10000;
}

/* ✨ Popup bên trong khay – bỏ fixed & translate cũ */
#notificationContainer .warningPopup{
  position: relative;                 /* relative → theo khay */
  left: auto; top: 0;
  transform: none;                    /* khay đã lo căn giữa */
  animation: popupFadeStack 1.5s ease-out forwards;
}

/* Hiệu ứng gần giống cũ nhưng không chứa -50% nữa */
@keyframes popupFadeStack{
  0%   {opacity:0;   transform: translateY(20px);}
  10%  {opacity:1;   transform: translateY(0);}
  90%  {opacity:1;}
  100% {opacity:0;   transform: translateY(-20px);}
}

/* 🌟 Giao diện popup nâng cấp */
#upgradePopup {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.85);
  border: 2px solid gold;
  padding: 2rem;
  border-radius: 1rem;
  z-index: 9999;
  max-width: 42rem;
  width: 90%;
  text-align: center;
  box-shadow: 0 0 15px gold;
}

.upgradeTitle {
  color: gold;
  font-size: 1.8rem;
  font-weight: bold;
  margin-bottom: 1.5rem;
  text-shadow: 0 0 6px gold;
  margin-top: 1rem;
}

.upgradeChoices {
  display: flex;
  justify-content: space-evenly;
  gap: 1rem;
  flex-wrap: wrap;
}

.upgradeChoices button {
  padding: 0.8rem 1.2rem;
  border: 2px solid #ccc;
  border-radius: 0.6rem;
  background: #111;
  color: white;
  font-size: 1rem;
  font-weight: bold;
  min-width: 8rem;
  cursor: pointer;
  transition: 0.2s ease;
}

.upgradeChoices button:hover {
  background: #22404c;
  border-color: gold;
  color: #fff;
  box-shadow: 0 0 10px gold;
}

/* 📊 Overlay thống kê */
#statsOverlay {
  position: fixed;
  top: 0.2rem;
  right: 0.5rem;
  background: rgba(0, 0, 0, 0.7);
  border: 2px solid #00ffff;
  border-radius: 1rem;
  padding: 1rem;
  color: #e0f7fa;
  font-size: 0.95rem;
  line-height: 1.5;
  z-index: 9999;
  width: 15rem;
  font-family: 'Segoe UI', sans-serif;
}

#statsOverlay h3 {
  font-size: 1rem;
  margin-top: 0;
  margin-bottom: 0.5rem;
  color: gold;
  text-align: center;
}

#statsOverlay.hidden {
  display: none;
}
/* 📚 Giao diện bảng kỹ năng active */
#skillsOverlay {
  position: fixed;
  top: 0.2rem;
  left: 0.5rem;
  background: rgba(0, 0, 0, 0.7);
  border: 2px solid #00ffff;
  border-radius: 1rem;
  padding: 1rem;
  color: #e0f7fa;
  font-size: 0.95rem;
  line-height: 1.5;
  z-index: 9999;
  width: 15rem;
  font-family: 'Segoe UI', sans-serif;
}

#skillsOverlay h3 {
  font-size: 1rem;
  margin-top: 0;
  margin-bottom: 0.5rem;
  color: gold;
  text-align: center;
}

#skillsOverlay.hidden {
  display: none;
}

.skill-item {
  margin-bottom: 0.5rem;
  padding: 0.4rem;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 0.5rem;
  cursor: pointer;
  transition: background 0.3s;
}

.skill-item:hover {
  background: rgba(0, 255, 255, 0.3);
}

.skill-icon {
  font-size: 1.2rem;
  margin-right: 0.5rem;
}
#skillPopup {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 32, 64, 0.9);
  border: 2px solid #00ffff;
  padding: 2rem;
  border-radius: 1rem;
  z-index: 9999;
  max-width: 42rem;
  width: 90%;
  text-align: center;
  box-shadow: 0 0 15px #00ffffaa;
}

#skillPopup h3 {
  color: #00ffff;
  font-size: 1.6rem;
  font-weight: bold;
  margin-bottom: 1.2rem;
  text-shadow: 0 0 6px #00ffff;
}

#skillPopup .upgradeChoices {
  display: flex;
  justify-content: space-evenly;
  gap: 1rem;
  flex-wrap: wrap;
}

#skillPopup .upgradeChoices button {
  padding: 0.8rem 1rem;
  border: 2px solid #0d1aa0; /* màu kỹ năng active */
  border-radius: 0.6rem;
  background: #001f2f;
  color: white;
  font-size: 1rem;
  font-weight: bold;
  min-width: 9rem;
  cursor: pointer;
  transition: 0.2s ease;
}
#skillPopup .upgradeChoices button:hover {
  background: #003344;
  border-color: cyan;
  box-shadow: 0 0 10px cyan;
}

.skill-item.active {
  border: 2px solid #00ffff;
  background: rgba(0, 255, 255, 0.2);
  box-shadow: 0 0 8px cyan;
  pointer-events: none; /* không cho click vào kỹ năng đã chọn */
}
.infoOverlay {
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(10, 25, 40, 0.95); /* xanh đen dịu */
  border: 2px solid #446688;
  border-radius: var(--menu-radius);
  max-width: 24rem;
  min-height: 22rem;
  width: 90%;
  padding: var(--menu-padding);
  box-shadow: 0 0 10px rgba(50, 100, 150, 0.3);
  color: #eef;
  z-index: 9999;
  font-family: 'Segoe UI', sans-serif;
  font-size: 0.95rem;
  line-height: 1.6; /* khoảng cách dòng */
  text-align: center;
}
.spacer {
  height: 2rem;  /* hoặc 4rem tùy độ cao bạn muốn */
}
/* 🔧 Spacer cân bằng layout trong overlay hướng dẫn */
.spacerguide {
  height: 2rem; /* khoảng cách giữa các mục */
}

.infoOverlay button {
  min-width: 10rem;
}
.custom-input {
  font-family: 'Segoe UI', sans-serif;
  padding: 0.65rem 1.25rem;
  font-size: 0.9rem;
  min-width: 6.5rem;
  width: 100%;
  max-width: 7.2rem;
  text-align: center;
  background-color: #1a2b33;
  border: 0.125rem solid #294e5a;
  border-radius: 0.5rem;
  color: #e0f7fa;
  transition: all 0.2s ease;
  box-shadow: 0 0.125rem 0.3rem rgba(0, 0, 0, 0.2);
}

.custom-input:focus {
  outline: none;
  background-color: #22404c;
  border-color: #3d6c78;
  color: #ffffff;
  box-shadow: 0 0 0.625rem #00ffffaa;
}
#waveNumberDisplay {
  position: fixed;
  top: 12vh; /* giống waveTimerDisplay */
  left: 52.5%; /* lệch phải so với thời gian ở 50% */
  transform: translateX(-50%);
  font-size: 1.1rem;
  color: #aefeff;
  font-weight: bold;
  text-shadow: 0 0 6px #00ffff;
  z-index: 10;
  pointer-events: none;
}
#miniMap {
  position: fixed;
  top: 4.8rem;
  right: 18.2rem;
  width: 150px;
  height: 150px;
  border: 2px solid #00ffff;
  border-radius: 0.5rem;
  background: rgba(0, 0, 0, 0.4);
  z-index: 9999;
  display: none; /* ẩn mini map ban đầu */
}
/* Tooltip cho item trong bảng kỹ năng (phím X) */
.skill-item[data-tooltip] {
  position: relative;
}
.skill-item[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 102%;               /* hiện bên phải bảng */
  top: -2rem;
  transform: translateY(var(--tip-shift,0)); /* DỊCH theo biến */
  margin-left: .6rem;
  min-width: 18rem;
  white-space: pre-line;    /* xuống dòng theo \n */
  padding: .55rem .7rem;
  font-size: .8rem;
  background: rgba(0,0,0,.85);
  color: #e0f7fa;
  border: 1px solid #00ffff;
  border-radius: .5rem;
  pointer-events: none;
  opacity: 0;
  transition: opacity .25s;
  z-index: 10000;
}
.skill-item:hover::after { opacity: 1; }
#bigBossRespawnDisplay {
    position: fixed;
    top: 12vh;
    left: 24vw;
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid violet;
    border-radius: 0.5rem;
    padding: 0.4rem 0.8rem;
    color: violet;
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    text-align: center;
    min-width: 6rem;
    z-index: 10;
    text-shadow: 0 0 5px violet;
}
#ui button[data-tooltip] {
  position: relative;
}

#ui button[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 112%;
  top: 4rem;
  transform: translateX(-38%);
  margin-left: .6rem;
  min-width: 18rem;
  white-space: pre-line;
  padding: .55rem .7rem;
  font-size: .8rem;
  background: rgba(0, 0, 0, 0.85);
  color: #e0f7fa;
  border: 1px solid #00ffff;
  border-radius: .5rem;
  pointer-events: none;
  opacity: 0;
  transition: opacity .25s;
  text-align: left; /* 👈 Đây là thứ bạn đang thiếu */
  z-index: 10000;
}

#ui button:hover::after {
  opacity: 1;
}

/* kết thúc style */
</style>
</head>
<body>
<div id="ui">
  <button id="autoBtn" data-tooltip="⚙️ Auto:
- Tự động tấn công zombie gần nhất
- Tiêu hao: 0 ⚡">⚙️ Auto</button>

  <button id="bladeBtn" data-tooltip="🔪 Kỹ năng Đao:
- Tạo 2 thanh đao xoay quanh
- Tối đa tạo được 20 đao
- Bay vào zombie gần nhất
- Yêu cầu level 1
- Sát thương: 1
- Hiệu lực: 30s ⏱
- Tiêu hao: 3 ⚡">🔪 Đao</button>

  <button id="swordBtn" data-tooltip="⚔️ Kỹ năng Kiếm:
- Tạo mưa kiếm rơi từng đợt
- Số lượng kiếm tăng theo level
- Bay vào zombie gần nhất
- Yêu cầu level 2
- Sát thương: 1
- Hiệu lực: 30s ⏱
- Tiêu hao: 6 ⚡">⚔️ Kiếm</button>

  <button id="fireBtn" data-tooltip="🔥 Kỹ năng Lửa:
- Tạo 2 quả cầu lửa quay quanh
- Tạo được tối đa 10 quả cầu lửa
- Tiêu diệt zombie chạm vào
- Yêu cầu level 3
- Sát thương: 1
- Hiệu lực: 45s ⏱
- Tiêu hao: 8 ⚡">🔥 Lửa</button>

  <button id="iceBtn" data-tooltip="❄️ Kỹ năng Băng (mở khóa Lv10):
- Tạo 2 quả cầu băng lớn xoay quanh
- Tạo được tối đa 10 quả cầu băng
- Gây sát thương diện rộng
- Yêu cầu level 3
- Sát thương: 1
- Hiệu lực: 60s ⏱
- Tiêu hao: 12 ⚡">❄️ Băng</button>

  <button id="thunderBtn" data-tooltip="🧪 Kỹ năng thunder (test):
- Tạo 2 quả cầu lôi xoay quanh
- Tạo được tối đa 6 quả cầu
- Gây sát thương diện rộng
- Yêu cầu level 5
- Sát thương: 1
- Hiệu lực: 60s ⏱
- Tiêu hao: 18 ⚡">🧪 Lôi</button>

  <button id="thunderBtn" data-tooltip="🧪 Kỹ năng thunder (test):
- Tạo 2 quả cầu lôi xoay quanh
- Tạo được tối đa 6 quả cầu
- Gây sát thương diện rộng
- Yêu cầu level 5
- Sát thương: 1
- Hiệu lực: 60s ⏱
- Tiêu hao: 18 ⚡">🧪 test1</button>

  <button id="thunderBtn" data-tooltip="🧪 Kỹ năng thunder (test):
- Tạo 2 quả cầu lôi xoay quanh
- Tạo được tối đa 6 quả cầu
- Gây sát thương diện rộng
- Yêu cầu level 5
- Sát thương: 1
- Hiệu lực: 60s ⏱
- Tiêu hao: 18 ⚡">🧪 test2</button>

  <button id="PetBtn" data-tooltip="🐰 Kỹ năng Pet:
- Kỹ năng thử nghiệm
- (Chưa hoạt động)
- Tiêu hao: 5 ⚡
- Hiệu lực: 20s ⏱
- Hỗ trợ: nhặt vật phẩm">🐰 Pet</button>

  <div id="score">
    <div id="score-top">Kill: 0 | ❤️: 10</div>
    <div id="score-bottom">Level: 1 | ⚡: 0</div>
  </div>
</div>
<canvas id="game" width="960" height="720"></canvas>

<!-- 📋 Menu bắt đầu game -->
<div id="startMenu">
  <h2 class="gameTitle">Zombie Survivor</h2>
<input type="text" id="playerNameInput" placeholder="Nhập tên của bạn" class="custom-input" />
  <button onclick="startGame()">🎮 Bắt đầu</button>
  <button onclick="showGuide()">📘 Hướng dẫn</button>
  <button onclick="showInfo()">ℹ️ Thông tin</button>
</div>
<div id="guideOverlay" class="infoOverlay" style="display: none;">
<h3 style="margin-top: 0; color: #66aaff;">📘 Hướng dẫn chơi</h3>
  <ul style="text-align: left;">
    <li>Tiêu diệt zombie để lên cấp</li>
    <li>Mỗi wave chọn 1 nâng cấp kỹ năng</li>
    <li>Mỗi level chọn kỹ năng chủ động</li>
    <li>Kỹ năng dùng năng lượng hoặc mana</li>
    <li>Mana rơi từ boss để dùng kỹ năng đặc biệt</li>
    <li>Bấm X: mở danh sách kỹ năng</li>
    <li>Bấm Z: mở bảng thống kê</li>
    <li>Bấm M: mở bảng bản đồ</li>
    <li>Vật phẩm mới: Energy, Mana, HP, Box</li>
  </ul>
  <div class="spacerguide"></div> <!-- 👈 dòng đệm -->
  <button onclick="hideGuide()">Đóng</button>
</div>
<div id="infoOverlay" class="infoOverlay" style="display: none;">
  <h3 style="margin-top: 0; color: #66aaff;">ℹ️ Thông tin</h3>
  <div class="infoContent">
    <p>Phiên bản: 1.2<br>
       Tác giả: Dang<br>
       Cập nhật: 2025-07-18</p>
    <p style="margin: 0; text-align: left;"><strong style="color: #00cc66;">🆕 New</strong></p>
    <!-- Phần có thể cuộn và canh trái -->
    <div style="max-height: 128px;overflow-y: auto;scrollbar-width: none;
    -ms-overflow-style: none;text-align: left;">
      <ul style="padding-left: 20px;margin-top: 2px;list-style-type: disc;">
        <li>Thêm minimap</li>
        <li>Tăng giới hạn bản đồ</li>
        <li>Tăng giới hạn số lượng Zombie</li>
        <li>Thêm Boss to hơn</li>
        <li>Cải tiến một số kỹ năng</li>
        <li>Thêm hệ thống ngày đêm</li>
        <!-- Các mục mới có thể thêm ở đây -->
      </ul>
    </div>
    <!-- Ẩn scrollbar trên Chrome/Safari -->
    <style>
      .infoContent div::-webkit-scrollbar {
        display: none;
      }
    </style>
  </div>
  <div class="spacer"></div>
  <button onclick="hideInfo()">Đóng</button>
</div>

<!-- 💀 Game Over Panel -->
<div id="gameOverPanel" class="gameOverPanel" style="display: none;">
  <h2 class="gameOverTitle">Game Over</h2>
  <button onclick="location.reload()" class="restartButton">Chơi lại</button>
</div>

<!-- 🌊 Popup khi bắt đầu mỗi Wave -->
<div id="wavePopup">Wave 1</div>

<!-- ⏳ Đồng hồ đếm thời gian wave -->
<div id="bigBossRespawnDisplay">BigBoss: --</div>
<div id="waveTimerDisplay">01:30:00</div>
<div id="waveNumberDisplay">Wave: 1</div>
<!-- Mini map -->
<canvas id="miniMap" width="150" height="150"></canvas>
<script>
// 🧱 1. Biến toàn cục – Cấu hình & Khởi tạo
let camera = { x: 0, y: 0 }; // 📷 Vị trí camera
let backgroundStars = [];
let backgroundBirds = [];
let backgroundTrees = [];
let backgroundClouds = [];
let backgroundPlanes = [];
let backgroundMushrooms = [];
let backgroundRocks = [];
let backgroundBalloons = [];
let backgroundSeeds = [];
let dayTime = 0;
let dayDirection = 1; // giữ lại cờ này như cũ
const dayDuration = 600; // 1 vòng ngày đêm = 96 giây thực tế
let lastUpdateTime = Date.now();
let prevIsNight = isNight();
let backgroundBigStars = [];
let globalDeltaTime = 0;

let lastBigBossTimerUpdate = performance.now();
let bigBossRespawnTimer = 0;
const bigBossRespawnInterval = 3; // giây

// 🔫 Cấu hình bắn
let shootCooldown = 1000;        // ⏱ Delay giữa mỗi đợt bắn
let lastShootBatchTime = 0;      // ⏱ Mốc thời gian đợt bắn
let currentBurstShots = 0;       // 💥 Số viên đã bắn trong đợt
let lastShootTime = 0;           // 🕒 Thời điểm bắn gần nhất
let autoBurstIndex = 0;
let autoLastBurstTime = 0;
let clickShotMode = 4; // 0: xoắn ốc, 1: zigzag, 2: spiral, 3: xuyên thẳng, 4: mặc định

const autoBurstDelay = 100; // ms delay giữa từng viên trong auto

// 🧟 Thống kê – Kỹ năng & zombie
let zombieKillCount = 0;
let zombieSpawnedCount = 0;
let zombieByLevel = {};
for (let i = 1; i <= 10; i++) zombieByLevel[i] = 0;
zombieByLevel.boss = 0;
zombieByLevel.miniBoss = 0;
let skillStats = {};             // 📊 Thống kê kỹ năng

// 🧍 Trạng thái người chơi
const player = {
  x: 480, y: 360, size: 20, speed: 1,
  hearts: 10, energy: 1, mana: 1,
  level: 1, score: 0,
  hitTimer: 0,
  name: "Player"
};

// 🌟 Trạng thái nâng cấp
const playerUpgrades = {
  fireRate: 1,          // 🔫 Hướng bắn
  damageBoost: 1,       // 💥 Sát thương cơ bản cộng thêm
  hpBoost: 0,           // ❤️ Số lần đã tăng máu
  bulletSpeed: 1,       // 💨 Tốc độ đạn
  lineBulletCount: 1    // 🧨 Số lượng đạn
};
// 🌟 Biến nâng cấp kỹ năng mặc định (🔪 Đao, ⚔️ Kiếm, 🔥 Lửa, ❄️ Băng)
const skillUpgrades = {
  // 🔪 Đao: số lượng đao và sát thương từng đao
  bladeCount: 2,           // bắt đầu 2 đao, tối đa 20
  bladeDamage: 1,          // sát thương từng đao

  // ⚔️ Kiếm: cấp độ mưa kiếm (số lượng + sát thương)
  swordLevel: 1,           // cấp độ mưa kiếm, tăng số lượng theo cấp
  swordDamage: 1,          // sát thương mỗi kiếm

  // 🔥 Lửa: số lượng cầu lửa và sát thương
  fireCount: 2,            // bắt đầu 2 quả cầu, tối đa 10
  fireDamage: 1,           // sát thương mỗi quả

  // ❄️ Băng: số lượng cầu băng và sát thương
  iceCount: 2,             // bắt đầu 2 quả cầu, tối đa 10
  iceDamage: 1             // sát thương mỗi quả
};
let petActive = false;
let petEndTime = 0;
let petRabbit = null;
let petLastHealTime = 0;
/* ── chống chọn lại món đồ vừa bỏ ── */
let lastGiveUpId   = null;   // id món đồ vừa bị bỏ
let lastGiveUpTime = 0;      // mốc thời gian bỏ
const RESELECT_CD  = 2000;   // 2 000 ms → cấm chọn lại 2 s

// ⚙️ Trạng thái điều khiển & kỹ năng
let lastManualShootTime = 0;
const manualShootCooldown = 1000; // delay 1 giây
let lastAutoShootTime = 0;
const autoShootCooldown = 1000;

let keys = {}, autoShoot = false;
let fireActive = false, iceActive = false;
let swordActive = false, bladeActive = false;
let frame = 0, gameOver = false;
let isPaused = false;
let pendingWave = null;
let uiVisible = true; // Trạng thái hiển thị UI

let nextFireIndex = 0; // Kỹ năng đao xoay

// Kỹ năng active
let satelliteActive = false;
let satelliteEndTime = 0;
let satellites = [];

let ufoActive = false; // Kỹ năng UFO
let ufoEndTime = 0;
let ufoCooldown = 0;
let ufoCount = 1;
let ufos = [];
// ========================= ⚡ Lightning – trạng thái & dữ liệu =========================
let lightningActive = false; // Kỹ năng sét - trạng thái & dữ liệu
let lightningEndTime = 0;
let lightningBolts = [];

let disguiseActive = false;
let disguiseEndTime = 0;

let clones = []; // 🎭 Global – lưu các bản sao hiện tại
let clonesActive = false;
let clonesEndTime = 0;

let blackHoles = []; // Danh sách hố đen
let extraShockwaves = []; // 🌊 các vòng nổ phụ lan ra

let bloodOrbActive = false;
let bloodOrbEndTime = 0;
let bloodOrbs = []; // [{ angle, radius, x, y }]
let bloodOrbCount = 1; // về sau nâng cấp +1 quả cầu
let bloodOrbLastDrain = 0;
let particles = [];

// 🌊 Quản lý wave
let wave = 1;
let waveTime = 180; // Thời gian mỗi wave
let waveTimer = waveTime;
let lastWaveTime = null;
let gameStarted = false;

// ⏱ Thời gian kỹ năng
let fireTimer = 0, fireEndTime = 0;
let iceTimer = 0, iceEndTime = 0;
let swordTimer = 0, swordEndTime = 0;
let bladeTimer = 0, bladeEndTime = 0;
let levelUpGlowTime = 0;

// 📱 Điều khiển cảm ứng
let touchStartX = null, touchStartY = null;
let touchMoveX = null, touchMoveY = null;

// 🎮 Danh sách các đối tượng trong game
let enemyBullets = []; // Zombie bắn trả
let zombies = [];
let bullets = [];
let swords = [];
let downwardSwords = [];
let fireballs = [];
let iceballs = [];
let items = [];
let explosions = [];
let missiles = []; // 🚀 Danh sách tên lửa đang bay
let expandingExplosions = []; // ☢️ Các vòng nổ lan rộng (dùng cho bom hạt nhân)
let activeNukes = []; // ☢️ Danh sách bom hạt nhân đang hoạt động
let nuclearBombs = []; // Mảng lưu trữ riêng bom hạt nhân
let bombsB52 = []; // 💣 Danh sách bom B52
let activePlanes = [];   // 🛬 Danh sách máy bay đang hoạt động

// 🔧 Vẽ Canvas
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// 🌀 Object Pooling
const bulletPool = [];
const explosionPool = [];
const zombiePool = [];
const swordPool = [];
const fireballPool = [];
const iceballPool = [];

//📲 2. Sự kiện điều khiển bàn phím, chuột, cảm ứng
// ⌨️ Bàn phím di chuyển
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

// 🖱 Click chuột để bắn
canvas.addEventListener("click", () => {
  const now = Date.now();
  if (now - lastManualShootTime < manualShootCooldown) return;
  lastManualShootTime = now;

  if (zombies.length === 0) return;

  const target = zombies.reduce((a, b) =>
    distance(a, player) < distance(b, player) ? a : b
  );

  const angle = Math.atan2(target.y - player.y, target.x - player.x);
  const bullet = getBullet();
  bullet.x = player.x;
  bullet.y = player.y;
  bullet.speed = playerUpgrades.bulletSpeed;
  bullet.active = true;
  bullet.color = "cyan";
  bullet.piercing = true;
  bullet.rotation = 0;

  // ======= Kiểu bắn tùy theo clickShotMode =======
if (clickShotMode === 0) {
  // 🔄 Xoắn ốc quanh player
  bullet.curveMode = true;
  bullet.angle = angle;
  bullet.curveRadius = 0;
  bullet.curveSpeed = 0.1 + Math.random() * 0.05;

} else if (clickShotMode === 1) {
  // ↔️ Zigzag
  bullet.zigzagMode = true;
  bullet.baseAngle = angle;
  bullet.oscillatePhase = Math.random() * Math.PI * 2;
  bullet.oscillateSpeed = 0.2;
  bullet.oscillateAmplitude = 20;
  bullet.travel = 0;
  bullet.startX = player.x;
  bullet.startY = player.y;

} else if (clickShotMode === 2) {
  // 🎯 Xoắn ốc bay thẳng
  bullet.spiralForwardMode = true;
  bullet.baseAngle = angle;
  bullet.travel = 0;
  bullet.spiralRadius = 15;
  bullet.spiralSpeed = 0.3;
  bullet.spiralPhase = Math.random() * Math.PI * 2;
  bullet.startX = player.x;
  bullet.startY = player.y;

} else if (clickShotMode === 3) {
  // 🎯 Kiểu 3 – Xuyên thẳng
  bullet.dx = Math.cos(angle);
  bullet.dy = Math.sin(angle);
  bullet.piercing = true;

} else if (clickShotMode === 4) {
  // 🔵 Kiểu 4 – Giống auto shoot
  bullet.dx = Math.cos(angle);
  bullet.dy = Math.sin(angle);
  bullet.piercing = false; // ❗ không xuyên
}
  // ================================================

  bullets.push(bullet);
});
// Gán sự kiện middle click (chuột giữa) để chuyển kiểu bắn
canvas.addEventListener("mousedown", (e) => {
  if (e.button === 1) {
    clickShotMode = (clickShotMode + 1) % 5;
    const modeNames = [
      "🔄 Xoắn ốc", 
      "↔️ Zigzag", 
      "🎯 Xoắn bay thẳng", 
      "🎯 Xuyên thẳng", 
      "🔵 Mặc định"
    ];
    showWarning(`Kiểu: ${modeNames[clickShotMode]}`);
    e.preventDefault();
  }
});

// Sử dụng phím Space để bắn
document.addEventListener("keydown", e => {
  if (e.code === 'Space') shoot();
});

// 📱 Điều khiển cảm ứng
canvas.addEventListener("touchstart", e => {
  const touch = e.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
});
canvas.addEventListener("touchmove", e => {
  const touch = e.touches[0];
  touchMoveX = touch.clientX;
  touchMoveY = touch.clientY;
  e.preventDefault(); // ngăn cuộn trang
});
canvas.addEventListener("touchend", () => {
  touchStartX = null;
  touchStartY = null;
  touchMoveX = null;
  touchMoveY = null;
});

//💥 3. Hàm hỗ trợ tiện ích
function distance(a, b) {
return Math.hypot(a.x - b.x, a.y - b.y);}

// 🎁 Hàm quản lý rơi vật phẩm khi zombie bị tiêu diệt
function dropItem(x, y, isBoss = false, isMiniBoss = false) {
  // Boss rơi 5 vật phẩm, mini boss rơi 2 vật phẩm, zombie thường theo xác suất
  const dropCount = isBoss ? 5 : isMiniBoss ? 2 : (Math.random() < 0.3 ? 1 : 0); // xác suất 30% rơi vật phẩm
  for (let i = 0; i < dropCount; i++) {
    // Tạo lệch ngẫu nhiên nhỏ để vật phẩm rơi tự nhiên hơn
    const offsetX = (Math.random() - 0.5) * 30;
    const offsetY = (Math.random() - 0.5) * 30;

    const safeX = Math.min(worldWidth  - wallThickness - 20,
        Math.max(wallThickness + 20, x + offsetX));
    const safeY = Math.min(worldHeight - wallThickness - 20,
        Math.max(wallThickness + 20, y + offsetY));
    // Chọn ngẫu nhiên loại vật phẩm rơi theo xác suất
    const itemRand = Math.random();
    let type;
    if (itemRand < 0.01) type = 'box';
    else if (itemRand < 0.34) type = 'energy';
    else if (itemRand < 0.67) type = 'mana';
    else type = 'hp';

    items.push({ x: safeX, y: safeY, type, active: true });
  }
}

// 📦 Khi người chơi nhặt hộp vật phẩm đặc biệt
function openItemBox() {
  const rewardCount = Math.floor(Math.random() * 3) + 1; // Nhận 1–3 loại ngẫu nhiên
  const rewards = [
    { type: 'energy', label: '⚡ Energy', icon: '⚡' },
    { type: 'mana', label: '💠 Mana', icon: '💠' },
    { type: 'hp', label: '❤️ HP', icon: '❤️' }
  ];

  const shuffled = rewards.sort(() => Math.random() - 0.5);
  const selected = shuffled.slice(0, rewardCount);
  const summary = [];

  selected.forEach(r => {
    const amount = Math.floor(Math.random() * 5) + 3;
    switch (r.type) {
      case 'energy': player.energy += amount; break;
      case 'mana': player.mana += amount; break;
      case 'hp': player.hearts += amount; break;
    }
    summary.push(`${r.icon} +${amount}`);
  });

  // 📢 Gộp thành một dòng thông báo duy nhất
  showWarning(`📦 Hộp quà: ${summary.join(', ')}`);
}

// 🔁 Bullet Pooling
function getBullet() {
  return bulletPool.length ? bulletPool.pop() : { x: 0, y: 0, dx: 0, dy: 0, active: true };
}
function releaseBullet(bullet) {
    bullet.active = false;
    delete bullet.customDmg;      // ⭐ xoá sát thương tuỳ chỉnh
    bullet.curveMode = false;     // ┐
    bullet.zigzagMode = false;    // │ nếu bạn dùng các mode này
    bullet.spiralForwardMode = false; //┘
    bulletPool.push(bullet);
}

// 💥 Explosion Pooling
function getExplosion(x, y) {
  const e = explosionPool.length ? explosionPool.pop() : { x: 0, y: 0, radius: 0, life: 0, active: true };
  e.x = x;
  e.y = y;
  e.radius = 0;
  e.life = 20;
  e.active = true;
  return e;
}
function releaseExplosion(e) {
  e.active = false;
  explosionPool.push(e);
}

// 💥 Bắn đạn từ zombie về phía player - shootEnemyBullet pooling
function shootEnemyBullet(x, y, speed = 0.6, chance = 1) {
  if (Math.random() > chance) return;

  const angle = Math.atan2(player.y - y, player.x - x);
  const b = getEnemyBullet();
  b.x = x;
  b.y = y;
  b.dx = Math.cos(angle);
  b.dy = Math.sin(angle);
  b.speed = speed;
  b.hit = false;
  b.active = true;

  enemyBullets.push(b);
}

// object pooling cho enemyBullets
const enemyBulletPool = [];

function getEnemyBullet() {
  return enemyBulletPool.length
    ? enemyBulletPool.pop()
    : { x: 0, y: 0, dx: 0, dy: 0, speed: 1, hit: false, active: true };
}

function releaseEnemyBullet(b) {
  b.hit = false;
  b.active = false;
  enemyBulletPool.push(b);
}

// 🧟 Zombie Pooling
function getZombie() {
    let z = zombiePool.length ? zombiePool.pop() : {
        x: 0, y: 0, radius: 15, canHit: true, speed: 1,
        color: "hotpink", isBoss: false, isBigBoss: false,
        hp: 1, active: true, type: "normal", level: 1
    };

    // Reset lại toàn bộ khi lấy từ pool
    z.active = true;
    z._killed = false;
    z.isBoss = false;
    z.isBigBoss = false;
    z.type = "normal";
    z.color = "hotpink";
    z.radius = 15;
    z.hp = 1;
    z.level = 1;
    z.baseSpeed = 0.1 + Math.random() * 0.1;
    z.speed = z.baseSpeed;
    z.canHit = true;

    return z;
}

function releaseZombie(z) {
  z.active = false;
  zombiePool.push(z);
}
// 💥 Hàm tiêu diệt zombie, dùng chung cho mọi kỹ năng
function killZombie(z) {
  if (z._killed || !z.active) return;
  z._killed = true;

  // 🧟 Gỡ khỏi màn và cộng thống kê
  releaseZombie(z);
  zombieKillCount++;

  // 🎯 Cộng điểm khi tiêu diệt
  player.score++;

  // 📊 Đếm theo cấp (level 1-10)
if (z.level && z.level >= 1 && z.level <= 10) {
    zombieByLevel[z.level] = (zombieByLevel[z.level] || 0) + 1;
}

// 💀 Đếm miniBoss nếu là loại đó
if (z.type === "miniBoss") {
    zombieByLevel.miniBoss = (zombieByLevel.miniBoss || 0) + 1;
}

// 💀 Đếm boss chính (boss thường)
if (z.isBoss && !z.isBigBoss) {
    zombieByLevel.boss = (zombieByLevel.boss || 0) + 1;
}

// 💜 Đếm BigBoss riêng biệt
if (z.isBigBoss) {
    zombieByLevel.bigBoss = (zombieByLevel.bigBoss || 0) + 1;
}

  // 🎁 Rơi vật phẩm tại vị trí zombie
  dropItem(z.x, z.y, z.isBoss, z.type === "miniBoss");
}

// 🧠 Hàm xử lý sát thương vào zombie, tự động kiểm tra chết và hiệu ứng
function dealDamageToZombie(z, dmg = 1) {
  z.hp -= dmg;
  if (!z._killed && z.hp <= 0) killZombie(z);
  explosions.push(getExplosion(z.x, z.y));
}

// 🔪 Sword Pooling
function getSword() {
  return swordPool.length ? swordPool.pop() : {
    angle: 0,
    radius: 60,
    state: 'charging',
    chargeFrame: 90,
    x: 0,
    y: 0,
    target: null,
    fireDelay: 0,
    delay: 60
  };
}

function releaseSword(s) {
  swordPool.push(s);
}

// 🔥 Fireball Pooling
function getFireball() {
  return fireballPool.length ? fireballPool.pop() : {
    angle: 0,
    radius: 40,
    x: 0,
    y: 0
  };
}

function releaseFireball(f) {
  fireballPool.push(f);
}

// ❄️ Iceball Pooling
function getIceball() {
  return iceballPool.length ? iceballPool.pop() : {
    angle: 0,
    radius: 60,
    x: 0,
    y: 0
  };
}

function releaseIceball(i) {
  iceballPool.push(i);
}
// 🧊 Hiển thị cảnh báo tạm thời
function showWarning(message, customStyle = {}) {
  // 🔸 Tạo khay nếu chưa có
  const container = document.getElementById('notificationContainer')
        || (() => {
             const c = document.createElement('div');
             c.id = 'notificationContainer';
             document.body.appendChild(c);
             return c;
           })();

  // 🔸 Tạo popup
  const popup = document.createElement('div');
  popup.className  = 'warningPopup';
  popup.textContent = message;
  Object.assign(popup.style, customStyle);   // nếu cần đổi màu, v.v.

  container.appendChild(popup);

  /* Giới hạn tối đa N popup đồng thời */
  const MAX = 2;
  while (container.childElementCount > MAX) {
    container.firstElementChild.remove();
  }

  /* Tự xoá sau 1,5 s */
  setTimeout(() => popup.remove(), 1500);
}
/* ── Buffer gộp popup vật phẩm ─────────────────────────────── */
const lootBuffer  = {};     // { "⚡":3, "💠":2, "❤️":1 }
let   lootTimer   = null;   // id setTimeout

function queueLootPopup(icon, delay = 500) {
  lootBuffer[icon] = (lootBuffer[icon] || 0) + 1;

  clearTimeout(lootTimer);
  lootTimer = setTimeout(() => {
    const summary = Object.entries(lootBuffer)
                  .map(([ico,c]) => `${ico} x${c}`)
                  .join(', ');
    showWarning(`🐰 Pet nhặt: ${summary}`);
    Object.keys(lootBuffer).forEach(k => delete lootBuffer[k]);
  }, delay);
}

//🔫 4. Bắn đạn & auto shoot
function shoot() {
  const now = Date.now();
  if (now - lastManualShootTime < manualShootCooldown) return;
  lastManualShootTime = now;

  const directionCount = playerUpgrades.fireRate;
  const bulletsPerDirection = 1;
  const angleOffset = Math.random() * Math.PI * 2;
  const speed = playerUpgrades.bulletSpeed;

  for (let i = 0; i < directionCount; i++) {
    const angle = angleOffset + (2 * Math.PI / directionCount) * i;

    for (let j = 0; j < bulletsPerDirection; j++) {
      const b = getBullet();
      b.x = player.x;
      b.y = player.y;
      b.dx = Math.cos(angle);
      b.dy = Math.sin(angle);
      b.speed = speed;
      b.active = true;
      bullets.push(b);
    }
  }
}

function autoShootBurst() {
  const now = Date.now();
  if (now - lastAutoShootTime >= autoShootCooldown) {
    lastAutoShootTime = now;
    autoBurstIndex = 0;
  }

  const bulletsPerDirection = playerUpgrades.lineBulletCount;
  if (autoBurstIndex >= bulletsPerDirection) return;
  if (now - autoLastBurstTime < autoBurstDelay) return;
  if (zombies.length === 0) return;

  const target = zombies.reduce((a, b) =>
    distance(a, player) < distance(b, player) ? a : b
  );
  const angle = Math.atan2(target.y - player.y, target.x - player.x);

  const b = getBullet();
  b.x = player.x;
  b.y = player.y;
  b.dx = Math.cos(angle);
  b.dy = Math.sin(angle);
  b.speed = playerUpgrades.bulletSpeed;
  b.active = true;
  bullets.push(b);

  autoBurstIndex++;
  autoLastBurstTime = now;
}

//⚔️ 5. Kích hoạt kỹ năng (Kích hoạt kỹ năng & gán nút)
function activateSwordSkill() {
  if (!swordActive && player.energy >= 3) {
    swordActive = true;
    swordEndTime = Date.now() + 60000;
    player.energy -= 3;
    document.getElementById("bladeBtn").classList.add("active");}}

function activateDownwardSwords() {
  if (!bladeActive && player.energy >= 6) {
    bladeActive = true;
    bladeEndTime = Date.now() + 30000;
    player.energy -= 6;
    document.getElementById("swordBtn").classList.add("active");}}

// Kích hoạt kỹ năng PET – Thỏ màu hồng
function activatePet() {
  petActive       = true;                      // nay chắc chắn chưa hoạt động
  petEndTime      = Date.now() + 60000;        // 60 s
  petLastHealTime = Date.now();

  petRabbit = {                                // speed tính động mỗi frame
    x      : player.x + 40,
    y      : player.y,
    radius : 14
  };

  const btn        = document.getElementById("PetBtn");
  btn.innerText    = lastPetText;
  btn.classList.add("active");

  showWarning("🐰 Pet thỏ đã ra trận!");
}
// 🖱 Gán sự kiện nút
// 🔪 Kỹ năng Đao
document.getElementById("bladeBtn").onclick = () => {
  if (player.level < 1) return showWarning("🔪 Yêu cầu Lv1");
  if (player.energy < 3) return showWarning("🔪 Không đủ 3⚡");
  activateSwordSkill();
};
// ⚔️ Kỹ năng Kiếm
document.getElementById("swordBtn").onclick = () => {
  if (player.level < 2) return showWarning("⚔️ Yêu cầu Lv2");
  if (player.energy < 6) return showWarning("⚔️ Không đủ 6⚡");
  activateDownwardSwords();
};
// 🔥 Kỹ năng Lửa
document.getElementById("fireBtn").onclick = () => {
  if (player.level < 3) return showWarning("🔥 Yêu cầu Lv3");
  if (player.energy < 8) return showWarning("🔥 Không đủ 8⚡");
  if (!fireActive) {
    fireActive = true;
    fireballs.length = 0;
    const fireCount = skillUpgrades.fireCount;
    for (let i = 0; i < fireCount; i++) {
      const angle = (2 * Math.PI / fireCount) * i;
      const f = getFireball();
      f.angle = angle;
      f.radius = 40;
      f.x = player.x + Math.cos(angle) * 40;
      f.y = player.y + Math.sin(angle) * 40;
      fireballs.push(f);
    }
    fireEndTime = Date.now() + 45000;
    player.energy -= 8;
    document.getElementById("fireBtn").classList.add("active");
  }
};
// ❄️ Kỹ năng Băng
document.getElementById("iceBtn").onclick = () => {
  if (player.level < 3)   return showWarning("❄️ Yêu cầu Lv3");
  if (player.energy < 12) return showWarning("❄️ Không đủ 12⚡");
  if (!iceActive) {
    iceActive  = true;
    iceballs.length = 0;                    // xoá vòng cũ
    const iceCount = skillUpgrades.iceCount;
    for (let i = 0; i < iceCount; i++) {
      const angle = (2 * Math.PI / iceCount) * i;
      const b     = getIceball();
      b.angle  = angle;
      b.radius = 60;
      b.x = player.x + Math.cos(angle) * 60;
      b.y = player.y + Math.sin(angle) * 60;
      iceballs.push(b);
    }
    iceEndTime      = Date.now() + 60000;   // 60 s hiệu lực
    player.energy  -= 12;                   // trừ năng lượng đúng 1 lần
    document.getElementById("iceBtn").classList.add("active");
  }
};
// Auto bắn
document.getElementById("autoBtn").onclick = () => {
  autoShoot = !autoShoot;
  const btn = document.getElementById("autoBtn");
  if (autoShoot) {
    btn.classList.add("active");
  } else {
    btn.classList.remove("active");
  }
};
// 🐰 Kỹ năng Pet
document.getElementById("PetBtn").onclick = () => {
  if (petActive) return;                       // đang có thỏ → bỏ
  if (player.energy < 5) {
    showWarning("🐰 Không đủ 5 ⚡");
    return;
  }
  activatePet();                               // kích hoạt thành công
  player.energy -= 5;                          // trừ ⚡ duy nhất 1 lần
};

//🧟 6. Sinh zombie và boss
// 🎨 Màu tương ứng cho zombie cấp 1 → 10
const zombieColorsByLevel = [
  "#00cc66", // Level 1 – Xanh lá sáng (nhẹ nhàng)
  "#3399ff", // Level 2 – Xanh dương (nhạt hơn boss)
  "#ffcc00", // Level 3 – Vàng sáng
  "#ff9900", // Level 4 – Cam
  "#ff3333", // Level 5 – Đỏ sáng
  "#cc00cc", // Level 6 – Tím
  "#9933ff", // Level 7 – Tím xanh điện
  "#ff66cc", // Level 8 – Hồng neon
  "#00ffff", // Level 9 – Xanh cyan
  "#ffffff"  // Level 10 – Trắng sáng chói (gần max)
];

// 📊 Bảng xác suất cấp độ zombie theo từng wave
function getZombieLevelByWave(wave) {
  const levelTable = {
    1:  [100],
    2:  [70, 30],
    3:  [50, 50],
    4:  [40, 60],
    5:  [30, 70],
    6:  [20, 50, 30],
    7:  [15, 50, 35],
    8:  [10, 50, 40],
    9:  [5, 50, 45],
    10: [0, 50, 50],
    11: [20, 30, 20, 30],
    12: [15, 30, 25, 30],
    13: [10, 30, 30, 30],
    14: [5, 30, 35, 30],
    15: [0, 30, 40, 30],
    16: [0, 20, 40, 40],
    17: [0, 10, 40, 50],
    18: [0, 0, 40, 60],
    19: [0, 0, 30, 70],
    20: [0, 0, 20, 80],
    21: [0, 0, 10, 40, 50],
    22: [0, 0, 5, 35, 60],
    23: [0, 0, 5, 25, 60, 5],
    24: [0, 0, 0, 20, 50, 20, 10],
    25: [0, 0, 0, 15, 40, 25, 15, 5],
    26: [0, 0, 0, 10, 35, 25, 20, 10],
    27: [0, 0, 0, 5, 25, 25, 25, 15, 5],
    28: [0, 0, 0, 0, 20, 25, 25, 20, 10],
    29: [0, 0, 0, 0, 15, 20, 25, 25, 15],
    30: [0, 0, 0, 0, 10, 15, 25, 25, 20, 5]
  };

  // 👇 fallback khi wave > 30: zombie cấp 1–10
  const fallback = [1, 1, 10, 10, 15, 15, 15, 15, 10, 8];
  const table = levelTable[wave] || fallback;
  const rand = Math.random() * 100;
  let sum = 0;
  for (let i = 0; i < table.length; i++) {
    sum += table[i];
    if (rand < sum) return i;
  }
  return table.length - 1;
}
// Khởi tạo Zombie
function spawnZombie() {
  const z = getZombie();
  const level = getZombieLevelByWave(wave); // cấp từ 0–9
// HP zombie tăng theo level player + random 1~10
  if (wave >= 10) {
  z.hp = level + 1 + Math.floor(player.level / 2) + Math.floor(Math.random() * 10 + 1);
} else {
  z.hp = level + 1;
}
  z.baseHp = z.hp; // 🔑 Ghi nhớ HP gốc để reset ban ngày
  z.level = level + 1; // cấp thật từ 1–10
// 👣 Di chuyển ngẫu nhiên ban đầu
  z.state = "wandering";
  z.nextStateCheck = Date.now() + 3000; // kiểm tra mỗi 3s khi đang chasing - kiểm tra mỗi giây
  z.wanderTime = Date.now() + 2000 + Math.random() * 2000; // từ 2 đến 4 giây
  z.wanderAngle = Math.random() * Math.PI * 2;
// 🎲 Chọn kiểu wander: 80% di chuyển, 20% đứng im
  z.wanderBehavior = Math.random() < 0.2 ? "pause" : "move";
  z.baseSpeed = 0.02 + Math.random() * 0.3; // tốc độ khi chasing - tốc độ khi đuổi theo
  z.speed = 0.015 + Math.random() * 0.05;   // tốc độ khi wandering - tốc độ khi lang thang
  z.color = zombieColorsByLevel[level];
  z.type = "normal";
  z.radius = 15;
  z.isBoss = false;
  z.showStatusIcon = Math.random() < 0.3; // 30% zombie thường hiển thị icon trạng thái

// 🎯 Random mini boss (xuất hiện 2%) - Tỷ lệ xuất hiện mini boss
if (Math.random() < 0.02) {
  z.type = "miniBoss";
  // HP mini boss tăng theo wave và level player
  z.hp = 50 + wave + Math.floor(player.level / 2) + Math.floor(Math.random() * 20 + 1); 
  z.color = bossColors[Math.floor(Math.random() * bossColors.length)]; // Màu mini boss
  z.radius = 18;
  z.level = 99; // Đánh dấu riêng để không tính cấp thường
}

// 📍 Tạo zombie ngẫu nhiên bên trong bản đồ
z.x = Math.random() * worldWidth;
z.y = Math.random() * worldHeight;
// 📍 Đặt zombie
  zombies.push(z);
  zombieSpawnedCount++;
}

// Màu boss
const bossColors = [
  "#ff3333", // Đỏ tươi
  "#ff8800", // Cam rực
  "#ffaa00", // Vàng cam
  "#00ccff", // Xanh dương sáng
  "#9933ff", // Tím đậm
  "#00ff99", // Xanh ngọc
  "#ff66cc", // Hồng neon
  "#ffffff", // Trắng lạnh
  "#888888", // Xám tro (boss máy móc)
  "#00ffff"  // Xanh cyan ánh kim
];

function spawnBoss() {
  const z = getZombie();
   // 📍 ➊ Chọn vị trí ngẫu nhiên trong world
  // (worldWidth / worldHeight đã dùng cho zombie thường)
  do {
    z.x = Math.random() * worldWidth;
    z.y = Math.random() * worldHeight;
    // 📏 ➋ Bảo đảm không “úp sọt” player
  } while (distance(z, player) < 250); // ≥ 250 px mới cho xuất hiện

  z.radius = 30;
  z.canHit = true;
  z.baseSpeed = 0.015 + Math.random() * 0.03; // Lưu tốc độ gốc | Tốc độ boss
  z.speed = z.baseSpeed; // Bắt đầu bằng tốc độ gốc
  z.isBoss = true;
  // HP boss tăng theo wave và level player + random 1~100
  z.hp = 100 + wave * 2 + Math.floor(player.level / 2) + Math.floor(Math.random() * 100 + 1);
  z.baseHp = z.hp; // 🔑 Ghi nhớ HP gốc để reset ban ngày
  z.type = "boss";
  z.level = 100; // level Boss
  z.color = bossColors[Math.floor(Math.random() * bossColors.length)]; // Màu boss
  z.active = true;
  zombies.push(z);
  zombieSpawnedCount++;
}
function spawnBigBoss() {
    const z = getZombie();
    z.active = true; // reset lại chắc chắn
    z._killed = false;

    do {
        z.x = Math.random() * worldWidth;
        z.y = Math.random() * worldHeight;
    } while (distance(z, player) < 250); // tránh sinh gần player

    z.radius = 120; // Kích thước bigboss
    z.baseSpeed = 0.01 + Math.random() * 0.2;
    z.speed = z.baseSpeed;
    z.isBoss = true;
    z.isBigBoss = true; // 🔑 Đánh dấu riêng bigBoss
    z.hp = 10000 + wave * 500 + Math.floor(Math.random() * 1000 + 250);
    z.baseHp = z.hp;
    z.type = "bigBoss";
    z.level = 999;
    z.color = "purple"; // Đổi màu để dễ phân biệt
    z.active = true;
    zombies.push(z);
    zombieSpawnedCount++;
}

//🧠 7. Cập nhật UI – chỉ DOM
// 🧟 Hàm cập nhật Wave riêng biệt (dùng khi wave thay đổi)
function updateWaveUI() {
  document.getElementById("score-bottom").innerText = `Level: ${player.level} |⚡: ${player.energy}`;
  setTimeout(() => {
  document.getElementById("waveNumberDisplay").innerText = `Wave: ${wave}`;
}, 1000); // ⏱️ hiển thị sau 1 giây
  document.getElementById("ui-mana").innerText = `💠 Mana: ${player.mana}`;
}
// DOM chỉ cập nhật khi giá trị thay đổi
let lastScore = -1, lastLevel = -1, lastEnergy = -1, lastHearts = -1, lastHighScore = -1; let lastMana = -1;
let lastBladeText = "", lastSwordText = "", lastFireText = "", lastIceText = "", lastFpsText = "", lastPetText = "";

function updateUI() {
  const highScore = parseInt(localStorage.getItem('highScore') || '0');
  if (player.score > highScore) {
    localStorage.setItem('highScore', player.score);
}
  if (
    player.score !== lastScore ||
    player.hearts !== lastHearts ||
    highScore !== lastHighScore
  ) {
    lastScore = player.score;
    lastHearts = player.hearts;
    lastHighScore = highScore;
    document.getElementById("score-top").innerText =`Kill: ${player.score} | ❤️: ${player.hearts}`;
    document.getElementById("highScoreDisplay").innerText = `🏆 Kỷ lục: ${highScore}`;
  }

  if (
    player.level !== lastLevel ||
    player.energy !== lastEnergy
  ) {
    lastLevel = player.level;
    lastEnergy = player.energy;
    updateWaveUI(); // 🧟 tách riêng hiển thị wave
  }
  if (player.mana !== lastMana) {
  lastMana = player.mana;
  document.getElementById("ui-mana").innerText = `💠 Mana: ${player.mana}`;
}
}

// Hàm điều phối theo trạng thái sword
function updateSwordByState(s) {
  switch (s.state) {
    case 'charging': return updateSwordCharging(s);
    case 'readyToFire': return updateSwordReady(s);
    case 'flying': return updateSwordFlying(s);
    default: return true;
  }
}

// ⚙️ Đao đang xoay quanh người chơi trong trạng thái "charging"
function updateSwordCharging(s) {
// Giảm thời gian xoay còn lại
  s.chargeFrame--;
// Cập nhật góc quay & vị trí đao theo góc
  s.angle += 0.015;
  s.x = player.x + Math.cos(s.angle) * s.radius;
  s.y = player.y + Math.sin(s.angle) * s.radius;
// Kiểm tra va chạm zombie gần đao
  checkSwordHitsNearbyZombie(s);
// Khi xoay đủ thời gian → chuyển sang trạng thái "readyToFire"
  if (s.chargeFrame <= 0) {
    s.state = 'readyToFire';
    s.fireDelay = 30; // thời gian chờ trước khi bắt đầu bay
  }
  return true; // giữ đao trong mảng
}

// ⏳ Đao đang chờ sẵn để bay ra sau khi xoay xong
function updateSwordReady(s) {
//  Mỗi đao chỉ bay khi đến lượt mình
  if (s.fireOrder === nextFireIndex) {
    s.fireDelay--;
    if (s.fireDelay <= 0) {
      s.state = 'flying';
      s.target = findActiveZombie();
      nextFireIndex++; // chuyển lượt sang đao tiếp theo
    }
  }
  return true;
}

// 🚀 Đao bay về phía mục tiêu (zombie)
function updateSwordFlying(s) {
// Nếu không có target hoặc zombie đã chết → tìm lại zombie mới
  if (!s.target || !s.target.active) {
    s.target = findActiveZombie();
    if (!s.target) return true; // chưa có zombie → giữ đao chờ tiếp
  }
// Di chuyển đao hướng tới mục tiêu
  moveSwordTowardsTarget(s);
// Kiểm tra va chạm với mục tiêu
  if (distance(s, s.target) < 25) {
    handleSwordHit(s); // xử lý trúng địch
    return false;      // loại đao sau khi trúng
  }
  return true; // tiếp tục bay
}

// 📍 Di chuyển đao bay đến mục tiêu
function moveSwordTowardsTarget(s) {
  const dx = s.target.x - s.x;
  const dy = s.target.y - s.y;
  const angle = Math.atan2(dy, dx);
  s.x += Math.cos(angle) * 5;
  s.y += Math.sin(angle) * 5;
}

// 💥 Xử lý khi đao bay trúng mục tiêu
function handleSwordHit(s) {
  dealDamageToZombie(s.target, playerUpgrades.damageBoost || 1);
}

// 🧿 Tìm zombie còn sống gần player nhất 
function findActiveZombie() {
  return zombies.find(z => z.active);
}

function checkSwordHitsNearbyZombie(s) {
  const target = zombies.find(z => z.active && distance(s, z) < 20);
  if (target) {
  dealDamageToZombie(target, skillUpgrades.bladeDamage + playerUpgrades.damageBoost);
  }
}
/* ───────────────────────────────────────
   🐰 CẬP NHẬT PET – GỌI MỖI FRAME
   ─────────────────────────────────────── */
function updatePet() {
  if (!petActive || !petRabbit) return;

  /* hằng số */
  const DIST_ITEM    = 360;
  const DIST_FOLLOW  = 480;
  const TOLERANCE    = 40;
  const PICK_DIST    = 16;
  const GIVE_UP_MS   = 3000;
  const MIN_PROGRESS = 20;    // phải tiến ≥20 px sau 3 s

  /* tốc độ */
  petRabbit.speed = (player.speed ?? 1) + 0.4;

  /* 0. quay về nếu xa player quá */
  if (distance(petRabbit, player) > DIST_FOLLOW) {
    moveTowards(petRabbit, player, petRabbit.speed * 1.6);
    petRabbit.target = null;
    return;
  }

  /* 1. chọn mục tiêu mới */
  if (!petRabbit.target || !petRabbit.target.active) {
    petRabbit.target = items
      .filter(it => {
        if (!it.active) return false;
        if (distance(petRabbit, it) > DIST_ITEM) return false;
        /* cấm chọn lại item vừa bỏ trong 2 s */
        if (it.id === lastGiveUpId &&
            Date.now() - lastGiveUpTime < RESELECT_CD) return false;
        return true;
      })
      .sort((a, b) => distance(petRabbit, a) - distance(petRabbit, b))[0] || null;

    if (petRabbit.target) {
      petRabbit.chaseStart    = Date.now();
      petRabbit.startDistance = distance(petRabbit, petRabbit.target);
    }
  }

  /* 2. đuổi & nhặt */
  if (petRabbit.target) {
    const dNow     = distance(petRabbit, petRabbit.target);
    const elapsed  = Date.now() - petRabbit.chaseStart;
    const progress = petRabbit.startDistance - dNow;

    /* bỏ nếu >3 s mà tiến <20 px */
    if (elapsed > GIVE_UP_MS && progress < MIN_PROGRESS) {
      giveUp();
      return;
    }

    /* bỏ nếu mục tiêu lại quá xa player */
    if (distance(player, petRabbit.target) > DIST_FOLLOW) {
      giveUp();
      return;
    }

    moveTowards(petRabbit, petRabbit.target, petRabbit.speed);

    if (dNow < PICK_DIST) collectLoot();
  }
  /* 3. bám player khi không có mục tiêu */
  else if (distance(petRabbit, player) > TOLERANCE) {
    moveTowards(petRabbit, player, petRabbit.speed * 1.2);
  }

  /* 4. hồi máu & hết giờ */
  if (Date.now() - petLastHealTime >= 10000) {
    petLastHealTime = Date.now();
    player.hearts++;
    showWarning("❤️ Pet hồi máu!");
  }
    if (Date.now() >= petEndTime) { // kiểm tra hết thời gian ngay đầu hàm đảm bảo luôn chạy đúng lúc
    petActive = false;
    petRabbit = null;
    showWarning("🐰 Pet đã rời đi.");
  }
}

/* ───────── helpers ───────── */
function moveTowards(obj, target, spd) {
  const ang = Math.atan2(target.y - obj.y, target.x - obj.x);
  obj.x += Math.cos(ang) * spd;
  obj.y += Math.sin(ang) * spd;
}

function collectLoot() {
  const t = petRabbit.target;
  switch (t.type) {
    case "energy": player.energy++; queueLootPopup("⚡"); break;
    case "mana":   player.mana++;   queueLootPopup("💠"); break;
    case "hp":     player.hearts++; queueLootPopup("❤️"); break;
    case "box":    openItemBox(); break;
  }
  t.active = false;
  petRabbit.target = null;
}

function giveUp() {
  lastGiveUpId   = petRabbit.target.id;   // ghi nhớ id
  lastGiveUpTime = Date.now();
  petRabbit.target = null;
  showWarning("🐰 đừng đi xa, quay về!");
}

//🔄 8. Cập nhật logic game (Main loop logic)
function update() {
  if (!gameStarted || gameOver || isPaused) return; // không cập nhật khi chưa bắt đầu, game over hoặc tạm dừng
// Cập nhật wave logic
// ⏱ Đếm thời gian còn lại của wave
if (lastWaveTime) {
  const elapsed = (Date.now() - lastWaveTime) / 1000; // giây đã trôi qua
  const remaining = Math.max(0, waveTime - elapsed);  // thời gian còn lại
  const min = Math.floor(remaining / 60);
  const sec = Math.floor(remaining % 60);
  const ms = Math.floor((remaining - Math.floor(remaining)) * 100); // lấy 2 chữ số sau dấu .
  document.getElementById("waveTimerDisplay").innerText =
  `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}:${ms.toString().padStart(2, '0')}`;

if (remaining <= 0) {
  wave++;
  pendingWave = wave;         // 🌊 lưu wave để hiển thị sau
  showUpgradePopup();         // 🎁 hiển thị nâng cấp trước
  // Khi lên wave 5, reset thời gian BigBoss đếm từ 0
    if (wave === 5) {
        bigBossRespawnTimer = 0;
        lastBigBossTimerUpdate = performance.now();
    }
  lastWaveTime = Date.now();  // ⏱️ reset timer
  updateWaveUI();
}
}
// Thời gian bigboss hồi sinh
const existingBigBoss = zombies.find(z => z.active && z.isBigBoss);
const bigBossRemain = Math.max(0, Math.ceil(bigBossRespawnInterval - bigBossRespawnTimer));

const box = document.getElementById("bigBossRespawnDisplay");
box.style.display = "block"; // Luôn hiển thị

if (wave < 5) {
    box.innerText = "BigBoss: --";
} else {
    box.innerText = existingBigBoss ? "BigBoss: living" : `BigBoss: ${bigBossRemain}s`;
}
// Xử lý kỹ năng Đao 🔪 tự tạo liên tục trong 30s
if (swordActive) {
  if (Date.now() >= swordEndTime) {
    swordActive = false;
    swords.length = 0;
    document.getElementById("bladeBtn").classList.remove("active");
    document.getElementById("bladeBtn").innerText = "🔪 Đao";
  } else {
    const remain = Math.ceil((swordEndTime - Date.now()) / 1000);
// 🎯 Cập nhật bladeBtn nếu khác giá trị trước đó
const bladeRemain = Math.ceil((swordEndTime - Date.now()) / 1000);
const bladeText = `🔪 ${bladeRemain}s`;
if (bladeText !== lastBladeText) {
  lastBladeText = bladeText;
  document.getElementById("bladeBtn").innerText = bladeText;
}

// 🔪 Tạo đao mới nếu chưa có
if (swords.length === 0) {
  swordTimer = 0;
  const count = skillUpgrades.bladeCount; // 🔪 Số đao từ nâng cấp
  nextFireIndex = 0;
for (let i = 0; i < count; i++) {
  const angle = (2 * Math.PI / count) * i;
  const s = getSword(); // hoặc tạo sword mới
  s.angle = angle;
  s.radius = 60;
  s.state = 'charging';
  s.chargeFrame = 90;
  s.fireDelay = 20 + i * 10; // từng đao delay khác nhau
  s.fireOrder = i; //  đánh số đao
  swords.push(s);
}
}
}
}
// 🎯 Tối ưu xử lý trạng thái của swords
swords = swords.filter(updateSwordByState);
// === XỬ LÝ KỸ NĂNG KIẾM (từ trên cao) ===
if (bladeActive) {
if (Date.now() >= bladeEndTime) {
    bladeActive = false;
    downwardSwords.length = 0;
    document.getElementById("swordBtn").classList.remove("active");
    document.getElementById("swordBtn").innerText = "⚔️ Kiếm";
  } else {
    const remain = Math.ceil((bladeEndTime - Date.now()) / 1000);
// 🎯 Cập nhật swordBtn nếu khác giá trị trước đó
  const swordRemain = Math.ceil((bladeEndTime - Date.now()) / 1000);
  const swordText = `⚔️ ${swordRemain}s`;
if (swordText !== lastSwordText) {
  lastSwordText = swordText;
  document.getElementById("swordBtn").innerText = swordText;
}

// 🌧️ Tạo mưa kiếm mỗi 12 frame
if (frame % 12 === 0) {
  const count = Math.floor(Math.random() * 2) + skillUpgrades.swordLevel; // chỉ 1–2 kiếm mỗi đợt
  for (let i = 0; i < count; i++) {
    const x = Math.random() * canvas.width;
    downwardSwords.push({
      x,
      y: -20,
      speed: 5 + Math.random() * 1.5 // rơi mượt
    });
  }
}
// 🎯 Di chuyển và xử lý kiếm rơi
downwardSwords.forEach((s, si) => {
  s.y += s.speed;
  zombies.forEach((z) => {
    if (!z.active) return;
    if (distance(s, z) < 25) {
  dealDamageToZombie(z, skillUpgrades.swordDamage + playerUpgrades.damageBoost);
}
});
});

// ❌ Xoá kiếm rơi quá màn hình
downwardSwords = downwardSwords.filter(s => s.y < canvas.height + 30);
}
}
if (gameOver) return;
// 🔁 Giảm thời gian miễn sát thương
if (player.hitTimer > 0) {
  player.hitTimer--;
}

// Player move
let moveX = 0;
let moveY = 0;

if (keys.w) moveY -= 1;
if (keys.s) moveY += 1;
if (keys.a) moveX -= 1;
if (keys.d) moveX += 1;

if (moveX !== 0 || moveY !== 0) {
  const length = Math.hypot(moveX, moveY);
  moveX /= length;
  moveY /= length;
  player.x += moveX * player.speed;
  player.y += moveY * player.speed;
  // Giới hạn player trong bản đồ
player.x = Math.max(wallThickness + player.size, Math.min(worldWidth - wallThickness - player.size, player.x));
player.y = Math.max(wallThickness + player.size, Math.min(worldHeight - wallThickness - player.size, player.y));
// 🎥 Cập nhật camera sao cho player luôn ở giữa màn hình
camera.x = player.x - canvas.width / 2;
camera.y = player.y - canvas.height / 2;

// Giới hạn camera trong bản đồ
camera.x = Math.max(0, Math.min(worldWidth - canvas.width, camera.x));
camera.y = Math.max(0, Math.min(worldHeight - canvas.height, camera.y));
}

// === Xử lý điều khiển cảm ứng ===
if (touchStartX !== null && touchMoveX !== null) {
  let dx = touchMoveX - touchStartX;
  let dy = touchMoveY - touchStartY;
  const len = Math.hypot(dx, dy);
  if (len > 10) { // chỉ di chuyển nếu vuốt đủ lớn
    dx /= len;
    dy /= len;
    player.x += dx * player.speed;
    player.y += dy * player.speed;
  }
}

if (autoShoot && player.level >= 1) autoShootBurst();

// === Kỹ năng LỬA ===
  if (fireActive) {
    const remaining = Math.ceil((fireEndTime - Date.now()) / 1000);
    const fireBtn = document.getElementById("fireBtn");
    if (remaining > 0) {
const fireText = `🔥 ${remaining}s`;
if (fireText !== lastFireText) {
  lastFireText = fireText;
  fireBtn.innerText = fireText;
}
    } else {
fireActive = false;
fireballs.forEach(f => releaseFireball(f));
fireballs.length = 0;
fireBtn.innerText = "🔥 Lửa";
fireBtn.classList.remove("active");
    }}

// === Kỹ năng BĂNG ===
  if (iceActive) {
    const remaining = Math.ceil((iceEndTime - Date.now()) / 1000);
    const iceBtn = document.getElementById("iceBtn");
    if (remaining > 0) {
const iceText = `❄️ ${remaining}s`;
if (iceText !== lastIceText) {
  lastIceText = iceText;
  iceBtn.innerText = iceText;
}
} 
else
{
iceActive = false;
iceballs.forEach(i => releaseIceball(i));
iceballs.length = 0;
iceBtn.innerText = "❄️ Băng";
iceBtn.classList.remove("active");
}}
// === Kỹ năng PET ===
if (petActive) {
  const remaining = Math.ceil((petEndTime - Date.now()) / 1000);  
  const petBtn    = document.getElementById("PetBtn");

  if (remaining > 0) {
    const petText = `🐰 ${remaining}s`;
    if (petText !== lastPetText) {        // tránh gán DOM thừa
      lastPetText      = petText;
      petBtn.innerText = petText;
    }
  } else {
    // Hết giờ
    petBtn.innerText = "🐰 Pet";
    petBtn.classList.remove("active");
  }
}

updateBullets(); // gọi hàm đã viết sử dụng object pooling
zombies.forEach(z => {
  // 🔄 Ban đêm buff +5 ~ +10 HP, ban ngày reset HP về gốc
if (isNight()) {
    if (!z.hpNightBuffed) {
        z.hp += Math.floor(Math.random() * 46) + 5; // +5 ~ +10 HP
        z.hpNightBuffed = true;
    }
} else {
    if (z.hpNightBuffed) {
        z.hp = z.baseHp;
        z.hpNightBuffed = false;
    }
}
  // 👣 Cập nhật hướng di chuyển theo trạng thái
  // 🧠 AI hành vi zombie

  if (z.state === "wandering") {
    if (Date.now() >= z.wanderTime) { // Kiểm tra thời gian lang thang
      z.state = "chasing";
      z.speed = z.baseSpeed;
      z.nextStateCheck = Date.now() + 3000;
    } else {
      // 👣 Di chuyển hoặc đứng yên
      if (z.wanderBehavior === "move") {
        z.x += Math.cos(z.wanderAngle) * z.speed;
        z.y += Math.sin(z.wanderAngle) * z.speed;
      }
      // Nếu pause thì không làm gì (đứng yên)
    }
  } else if (z.state === "chasing") {
    if (Date.now() >= z.nextStateCheck) {
      z.nextStateCheck = Date.now() + 3000;

      // ❌ Boss không được chuyển sang wandering
      if (!z.isBoss) {
        const pauseChance = isNight() ? 1 : 0.2; // 🌙 Đêm 100%, ngày 20%
        z.state = "wandering";
        z.wanderTime = Date.now() + 1500 + Math.random() * 8500; // Thời gian hành vi Zzz từ 1.5s - 10s
        z.wanderAngle = Math.random() * Math.PI * 2;
        z.speed = 0.15 + Math.random() * 0.05;
        z.wanderBehavior = Math.random() < pauseChance ? "pause" : "move"; // 50% đêm, 20% ngày
        return;
      }
    }
    // 👊 Nếu vẫn chasing → đuổi theo player
    const angle = Math.atan2(player.y - z.y, player.x - z.x);
    z.x += Math.cos(angle) * z.speed;
    z.y += Math.sin(angle) * z.speed;
  }

  // Zombie bắn trả
  // 🧠 Boss hoặc mini boss bắn 1 lần mỗi 10 giây
  if (z.isBoss || z.type === "miniBoss") {
    if (!z.lastShoot) z.lastShoot = 0;
    const now = Date.now();
    if (now - z.lastShoot >= 8000) { // Boss bắn mỗi 8 giây
      z.lastShoot = now;
      shootEnemyBullet(z.x, z.y, 0.8, 0.8); // 80% xác suất
    }
  }

  // 👾 Zombie thường chỉ bắn sau mỗi 60s và có 1% xác suất
  if (!z.isBoss && z.type !== "miniBoss") {
    if (!z.lastShoot) z.lastShoot = 0;
    const now = Date.now();
    if (now - z.lastShoot >= 60000) { // Zombie thường bắn mỗi 60 giây
      z.lastShoot = now;
      shootEnemyBullet(z.x, z.y, 0.6 + Math.random() * 0.6, 0.001); // 0.1% xác suất
    }
  }

  // 🧟 Xử lý va chạm với player
  if (distance(z, player) < z.radius + player.size) {
    // 🛡️ Nếu khiên đang hoạt động, zombie không được phép vào bên trong
    if (player.shieldActive) {
      const shieldRadius = 48;
      const repelDistance = shieldRadius + z.radius;
      const dist = distance(z, player);
      if (dist < repelDistance) {
        const dx = z.x - player.x;
        const dy = z.y - player.y;
        const angle = Math.atan2(dy, dx);
        const pushBack = (repelDistance - dist) + 20;
        z.x += Math.cos(angle) * pushBack;
        z.y += Math.sin(angle) * pushBack;
        return;
      }
    }

    const dist = distance(z, player);
    if (dist < z.radius + player.size) {
      if (z.canHit) {
        player.hearts--;
        explosions.push(getExplosion(z.x, z.y));
        z.canHit = false;
        setTimeout(() => { z.canHit = true; }, 500);
        if (player.hearts <= 0) {
          gameOver = true;
          document.getElementById("gameOverPanel").style.display = "flex";
        }
      }
      const dx = z.x - player.x;
      const dy = z.y - player.y;
      const angle = Math.atan2(dy, dx);
      const pushBack = (z.radius + player.size - dist) + 1;
      z.x += Math.cos(angle) * pushBack;
      z.y += Math.sin(angle) * pushBack;
    }
  }

  // 🚫 Giới hạn zombie không vượt khỏi bản đồ
  z.x = Math.max(wallThickness + z.radius, Math.min(worldWidth - wallThickness - z.radius, z.x));
  z.y = Math.max(wallThickness + z.radius, Math.min(worldHeight - wallThickness - z.radius, z.y));
});
// BigBoss logic - Tạo bigboss và hồi sinh mỗi 60s
// 🎯 BigBoss chỉ bắt đầu đếm từ wave 5 trở lên
if (wave >= 5) {
    // Kiểm tra xem hiện tại có BigBoss tồn tại không
    const existingBigBoss = zombies.find(z => z.active && z.isBigBoss);

    if (!existingBigBoss) {
        // Nếu vừa mới vào wave 5, reset timer
        if (wave === 5 && bigBossRespawnTimer === 0) {
            bigBossRespawnTimer = 0;
            lastBigBossTimerUpdate = performance.now();
        }

        // Đếm thời gian thực để hồi sinh
        const now = performance.now();
        const elapsed = (now - lastBigBossTimerUpdate) / 1000;
        bigBossRespawnTimer += elapsed;
        lastBigBossTimerUpdate = now;

        if (bigBossRespawnTimer >= bigBossRespawnInterval) {
            spawnBigBoss();
            bigBossRespawnTimer = 0;
        }
    } else {
        // Nếu BigBoss còn sống, reset timer đếm lại từ đầu
        lastBigBossTimerUpdate = performance.now();
        bigBossRespawnTimer = 0;
    }
}
// 🔥 Kỹ năng Lửa Cập nhật fireballs - kỹ năng lửa quay quanh player và gây sát thương
fireballs = fireballs.filter(f => {
// Cập nhật vị trí fireball quay quanh player
  f.angle += 0.05;
  f.x = player.x + Math.cos(f.angle) * f.radius;
  f.y = player.y + Math.sin(f.angle) * f.radius;

// Kiểm tra va chạm với zombie
  zombies.forEach(z => {
    if (!z.active) return;
    if (distance(f, z) < 25) {
  dealDamageToZombie(z, skillUpgrades.fireDamage + playerUpgrades.damageBoost);
      z.state = "wandering"; // chuyển sang trạng thái wandering
      z.wanderTime = Date.now() + 3000 + Math.random() * 2000; // 3–5 giây lang thang
      z.wanderAngle = Math.random() * Math.PI * 2; // góc ngẫu nhiên
}
}
);
// Giữ lại nếu kỹ năng vẫn đang hoạt động
  return fireActive;
}
);
// ❄️ Kỹ năng Băng Cập nhật iceballs - kỹ năng băng quay quanh player và gây sát thương
iceballs = iceballs.filter(f => {
// Cập nhật vị trí iceball quay quanh player
  f.angle += 0.03;
  f.x = player.x + Math.cos(f.angle) * f.radius;
  f.y = player.y + Math.sin(f.angle) * f.radius;
// Kiểm tra va chạm với zombie
  zombies.forEach(z => {
    if (!z.active) return;
    if (distance(f, z) < 25) {
  dealDamageToZombie(z, skillUpgrades.iceDamage + playerUpgrades.damageBoost);
// Làm chậm zombie khi trúng băng - đoạn này test
      z.speed *= 0.5; // giảm 50% tốc độ
      z.state = "wandering"; // chuyển sang trạng thái wandering
      z.wanderTime = Date.now() + 3000 + Math.random() * 2000; // 3–5 giây lang thang
      z.wanderAngle = Math.random() * Math.PI * 2; // góc ngẫu nhiên
}
}
);
// Giữ lại nếu kỹ năng vẫn đang hoạt động
  return iceActive;
}
);
// 🎯 Xử lý nhặt vật phẩm khi người chơi tiến lại gần // Nhặt item ⚡
items.forEach(it => {
  if (!it.active) return;
  if (distance(it, player) < 20) { // Nếu người chơi chạm vào vật phẩm
    switch (it.type) {
      case 'energy':
        player.energy += 1;
        showWarning('⚡ +1 Energy');
        break;
      case 'mana':
        player.mana += 1;
        showWarning('💠 +1 Mana');
        break;
      case 'hp':
        player.hearts += 1;
        showWarning('❤️ +1 HP');
        break;
      case 'box':
        openItemBox(); // Mở hộp vật phẩm đặc biệt
        break;
    }
    it.active = false; // Vật phẩm biến mất sau khi nhặt
  }
});

items = items.filter(it => it.active);
const requiredScore = player.level * 300; // Tăng level #Tăng cấp
if (player.score >= requiredScore) {
  player.level++;
  player.hearts += 1 + (UPGRADE_TIERS.hpBoost[playerUpgrades.hpBoost] || 0);
  player.energy += 2; // 🎁 thưởng 2 năng lượng khi lên cấp
  player.mana += 2;   // 💠 thưởng 2 mana khi lên cấp
  playerUpgrades.damageBoost += 0.5; // 💥 Tăng sát thương mỗi level
  showWarning("+0.5 💥", { top: "30%", left: "45%", transform: "translate(-50%, -50%)"});

// 🪄 Hiển thị popup level
  const popup = document.getElementById("levelUpPopup");
  popup.style.animation = "none"; // reset nếu đã có hiệu ứng trước đó
  void popup.offsetWidth;         // trigger reflow
  popup.style.display = "block";
  setTimeout(() => {
    popup.style.display = "none";
  }, 1200);
  levelUpGlowTime = 60; // ~1s sáng vàng
  showSkillLevelUpPopup(); // <-- gọi thêm popup chọn kỹ năng

// 🎯 Mỗi 2 cấp tạo boss
  if (player.level % 1 === 0) {
  spawnBoss();
}}
  updateExplosions(); // dùng object pooling thay splice
  // 🌊 Cập nhật các vòng nổ phụ
extraShockwaves = extraShockwaves.filter(sw => {
  sw.radius += 8; // tăng bán kính mỗi frame
  sw.alpha -= 0.012; // giảm độ mờ dần
  return sw.alpha > 0;
});

if (levelUpGlowTime > 0) levelUpGlowTime--;
// 🎯 Cập nhật bullets – dùng object pooling thay vì splice
function updateBullets() {
  for (let i = 0; i < bullets.length; i++) {
    const b = bullets[i];
    if (!b.active) continue;

// 🏃 Di chuyển đạn theo hướng và tốc độ lưu riêng
if (b.curveMode) {
  // 🔄 Xoắn ốc quanh player
  b.curveRadius += 0.6;
  b.angle += b.curveSpeed * 0.5;
  b.x = player.x + Math.cos(b.angle) * b.curveRadius;
  b.y = player.y + Math.sin(b.angle) * b.curveRadius;

} else if (b.zigzagMode) {
  // ↔️ Zigzag
  b.travel += b.speed;
  const offset = Math.sin(b.travel * b.oscillateSpeed + b.oscillatePhase) * b.oscillateAmplitude;
  const angle = b.baseAngle;
  b.x = b.startX + Math.cos(angle) * b.travel - Math.sin(angle) * offset;
  b.y = b.startY + Math.sin(angle) * b.travel + Math.cos(angle) * offset;

} else if (b.spiralForwardMode) {
  // 🎯 Xoắn ốc bay thẳng
  b.travel += b.speed;
  const angle = b.baseAngle;
  const centerX = b.startX + Math.cos(angle) * b.travel;
  const centerY = b.startY + Math.sin(angle) * b.travel;
  const offsetAngle = b.spiralPhase + b.travel * b.spiralSpeed;
  const offsetX = Math.cos(offsetAngle) * b.spiralRadius;
  const offsetY = Math.sin(offsetAngle) * b.spiralRadius;
  b.x = centerX + offsetX;
  b.y = centerY + offsetY;

} else {
  // 🟡 Mặc định: đạn bay thẳng
  b.x += b.dx * b.speed;
  b.y += b.dy * b.speed;
}

for (let j = 0; j < zombies.length; j++) {
  const z = zombies[j];
  if (!z.active) continue;

if (distance(b, z) < 20) {
// ✨ NEW: chỉ dùng customDmg nếu đạn đó đã gán sẵn baseDamage,
// còn lại thì mới rơi về damageBoost chung của người chơi.
const dmg = (b.customDmg !== undefined)
            ? b.customDmg                        // Clone & mọi skill gán sẵn baseDamage
            : (playerUpgrades.damageBoost || 1); // Đạn thường của người chơi
dealDamageToZombie(z, dmg);
if (!b.piercing) {
    releaseBullet(b);
    break;
}
}
}
}
  bullets = bullets.filter(b => b.active);
}

function updateEnemyBullets() {
  for (let i = 0; i < enemyBullets.length; i++) {
    const b = enemyBullets[i];
    if (!b.active) continue;
    b.x += b.dx * b.speed;
    b.y += b.dy * b.speed;
    // Nếu trúng người chơi
    if (distance(b, player) < 15) {
    if (player.shieldActive) {
    // Đỡ đạn, không mất máu
    releaseEnemyBullet(b);
    continue;
  }
if (player.hitTimer === 0) {
        player.hearts--;
        player.hitTimer = 30;
        explosions.push(getExplosion(b.x, b.y));

if (player.hearts <= 0) {
          gameOver = true;
          document.getElementById("gameOverPanel").style.display = "flex";
}
}
b.hit = true;
}
// Nếu ra khỏi màn hình
    const outOfBounds =
      b.x < -50 || b.x > worldWidth + 50 ||
      b.y < -50 || b.y > worldHeight + 50;
if (b.hit || outOfBounds) {
      releaseEnemyBullet(b);
}
}
// Chỉ giữ lại các đạn còn active
  enemyBullets = enemyBullets.filter(b => b.active);
}
// 💥 Cập nhật hiệu ứng nổ – thay thế splice bằng release
function updateExplosions() {
  explosions.forEach(e => {
    if (!e.active) return;
    e.radius += 2;
    e.life--;
    if (e.life <= 0) {
      releaseExplosion(e);
    }
  });
}
// 💥 Xử lý các vòng nổ lan (dùng cho bom hạt nhân)
expandingExplosions = expandingExplosions.filter(exp => {
  const prevRadius = exp.radius;
  exp.radius += exp.maxRadius / exp.duration;
  exp.duration--;
// 💀 Gây sát thương khi vòng vừa chạm tới zombie
  zombies.forEach(z => {
    const dist = distance(exp, z);
    if (z.active && dist >= prevRadius && dist < exp.radius && !exp.hitSet.has(z)) {
    dealDamageToZombie(z, exp.damage);
    exp.hitSet.add(z);
    }
  }
);
    return exp.duration > 0;
});

if (satelliteActive) {
  if (Date.now() >= satelliteEndTime) {
    satelliteActive = false;
    satellites = [];
  } else {
// Cập nhật vị trí vệ tinh
    const satCount = satellites.length;
    if (satCount === 2) {
      satellites[0].x = player.x + 30; satellites[0].y = player.y - 30;
      satellites[1].x = player.x - 30; satellites[1].y = player.y - 30;
    } else if (satCount === 1) {
      satellites[0].x = player.x + 30; satellites[0].y = player.y - 30;
    }

// Xử lý mỗi vệ tinh đều bắn laze độc lập
    satellites.forEach((sat, idx) => {
      if (!sat.laserCooldown) sat.laserCooldown = 0;
// bắn mỗi 2s
      if (Date.now() - sat.laserCooldown >= 2000) {
        sat.laserCooldown = Date.now();
        const target = zombies.find(z => z.active && distance(sat, z) < 300);
        if (target) {
          const angle = Math.atan2(target.y - sat.y, target.x - sat.x);
          sat.laserBeam = {
            angle: angle,
            life: 60,
            damageCooldown: 0
          };
        }
      }
// Xử lý damage cho laserBeam nếu tồn tại
      if (sat.laserBeam && sat.laserBeam.life > 0) {
        sat.laserBeam.life--;
        if (sat.laserBeam.damageCooldown > 0) sat.laserBeam.damageCooldown--;

// Xác định gốc bắn
        const x1 = sat.x, y1 = sat.y;
        const angle = sat.laserBeam.angle;
        const dx = Math.cos(angle), dy = Math.sin(angle);

        zombies.forEach(z => {
          if (!z.active) return;
// Kiểm tra zombie gần tia bắn
          const proj = (z.x - x1) * dx + (z.y - y1) * dy;
          const perp = Math.abs((z.x - x1) * dy - (z.y - y1) * dx);

if (proj > 0 && proj < 500 && perp < 20) {
if (sat.laserBeam.damageCooldown <= 0) {
// Sát thương laze (có thể cho sát thương = baseDamage của skill)
  const skill = activeSkills.find(s => s.name === "Vệ tinh laze");
  dealDamageToZombie(z, (skill?.baseDamage ?? 5) * 2); // gợi ý: tăng damage cho cảm giác đã nâng cấp
  sat.laserBeam.damageCooldown = 5;
}
}
});
// Hết thời gian thì xóa tia
if (sat.laserBeam.life <= 0) sat.laserBeam = null;
}
});
}
}

// 🌩️ Kỹ năng Sét
if (lightningActive) { // cập nhật logic mỗi frame
  const now   = Date.now();
  const bobY  = Math.sin(frame * 0.05) * 4;        // mây nhấp nhô
  const cycle = (now - lightningStartTime) % 5500; // 5s bắn /0.5s nghỉ
  const shoot = cycle < 5000;

  lightningBolts.forEach(bolt => {
    // Vị trí cloud luôn theo player
    bolt.x = player.x + bolt.offsetX;
    bolt.y = player.y - 90 + bobY;

    // Xử lý strike đã có
if (bolt.currentStrike) {
  bolt.currentStrike.life--;
  // 🔁 Cập nhật path để luôn bắt đầu từ vị trí bolt hiện tại
  const target = bolt.currentStrike.target;
  if (target && target.active) {
    bolt.currentStrike.path = getZigZag({x: bolt.x, y: bolt.y + 8}, target, 8);
  }
  if (bolt.currentStrike.life <= 0) bolt.currentStrike = null;
}
    // Bắn mới
    if (shoot && now - bolt.lastShot >= 1000) {
      const target = zombies
        .filter(z => z.active && distance(bolt, z) < 360) // chỉ bắn zombie trong bán kính 360
        .sort((a,b)=>distance(bolt,a)-distance(bolt,b))[0];

      if (target) {
        bolt.lastShot = now;
        dealDamageToZombie(target, bolt.damage);
        explosions.push(getExplosion(target.x, target.y)); // hiệu ứng nổ

        // Tạo đường zig-zag
        bolt.currentStrike = {
          path: getZigZag({x: bolt.x, y: bolt.y+8}, target, 8),
          life: 60, // 1s tồn tại
          target: target // lưu zombie để cập nhật
        };
      }
    }
  });
}
blackHoles = blackHoles.filter(hole => {
  if (Date.now() >= hole.endTime) return false; // hết thời gian thì xoá
  hole.tick++;

  // 🧲 Hút zombie xung quanh vào hố đen
  zombies.forEach(z => {
    if (!z.active) return;
    const d = distance(hole, z);
    if (d < hole.radius) {
      const angle = Math.atan2(hole.y - z.y, hole.x - z.x);
      z.x += Math.cos(angle) * hole.pullSpeed;
      z.y += Math.sin(angle) * hole.pullSpeed;

      // 💥 Gây sát thương mỗi 30 frame (giữ nguyên)
      if (hole.tick % 30 === 0) {
        dealDamageToZombie(z, hole.damage);
      }
    }
  });

  // 🧲 Hút đạn zombie vào hố đen (mới thêm)
  enemyBullets.forEach(b => {
    if (!b.active) return;
    const d = distance(hole, b);
    if (d < hole.radius) {
      const angle = Math.atan2(hole.y - b.y, hole.x - b.x);
      b.x += Math.cos(angle) * hole.pullSpeed;
      b.y += Math.sin(angle) * hole.pullSpeed;

      if (d < 20) {
        releaseEnemyBullet(b); // 💥 Xóa đạn nếu vào gần tâm
      }
    }
  });
// ➕ Di chuyển chậm
hole.x += hole.dx;
hole.y += hole.dy;

// 🚫 Giới hạn trong bản đồ
hole.x = Math.max(wallThickness, Math.min(worldWidth - wallThickness, hole.x));
hole.y = Math.max(wallThickness, Math.min(worldHeight - wallThickness, hole.y));
  // —— Spawn bụi bị hút —— //
  if (hole.tick % 5 === 0) {               // 60 fps → 12 hạt/giây
  createSuctionDust(hole.x, hole.y, hole.radius + 60);
}
  return true;
});
// 🎯 Clone tự tìm zombie gần và bắn
if (clonesActive) {
  // ⏱ Hết thời gian hoạt động → xóa clone
  if (Date.now() >= clonesEndTime) {
    clonesActive = false;
    clones = [];
  } else {
    clones.forEach(clone => {
      // 🎯 Tìm zombie gần nhất trong phạm vi 600px
      const target = zombies.find(z => z.active && distance(clone, z) < 600);

      if (target) {
        const angle = Math.atan2(target.y - clone.y, target.x - clone.x);
        const dist = distance(clone, target);

        // 👣 Chỉ di chuyển nếu clone cách zombie > 250px
        if (dist > 250) {
          clone.x += Math.cos(angle) * clone.moveSpeed;  // tốc độ di chuyển
          clone.y += Math.sin(angle) * clone.moveSpeed;
        }
        // 🔫 Bắn đạn mỗi 1s nếu trong tầm
        if (Date.now() - clone.lastShot >= 1000) {
          clone.lastShot = Date.now();
          const b = getBullet();
          b.x = clone.x;
          b.y = clone.y;
          b.dx = Math.cos(angle);
          b.dy = Math.sin(angle);
          b.speed = 3;                        // tốc độ đạn
          b.active = true;
          b.customDmg = clone.baseDamage;     // sát thương riêng clone
          b.color = "#ff66ff"; // 💜 đạn clone hiện màu tím
          bullets.push(b);
        }
      } else {
// 😴 Nếu không có zombie → clone lượn quanh player trong phạm vi 600
const distFromPlayer = distance(clone, player);
if (distFromPlayer > 600) {
  // ⚠️ Đã vượt xa 600 → ép quay đầu và kéo về gần player ngay lập tức
  const angleBack = Math.atan2(player.y - clone.y, player.x - clone.x);
  clone.x += Math.cos(angleBack) * clone.moveSpeed * 2;
  clone.y += Math.sin(angleBack) * clone.moveSpeed * 2;

  // Cập nhật hướng di chuyển lại nếu cần tiếp tục di chuyển tự do sau đó
  clone.moveAngle = angleBack;
} else {
  // 🌀 Nếu còn trong phạm vi → tiếp tục lượn tự do
  clone.x += Math.cos(clone.moveAngle) * clone.moveSpeed;
  clone.y += Math.sin(clone.moveAngle) * clone.moveSpeed;
}

      }

      // 🧱 Giới hạn clone trong bản đồ
      clone.x = Math.max(wallThickness, Math.min(worldWidth - wallThickness, clone.x));
      clone.y = Math.max(wallThickness, Math.min(worldHeight - wallThickness, clone.y));
      // ⚖️ Giữ khoảng cách giữa 2 clone tối thiểu 20px
if (clones.length === 2) {
  const a = clones[0], b = clones[1];
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const minDist = 40; // khoảng cách tối thiểu giữa 2 clone

  if (dist < minDist && dist > 0.1) {
    const push = (minDist - dist) / 2;
    const angle = Math.atan2(dy, dx);
    const offsetX = Math.cos(angle) * push;
    const offsetY = Math.sin(angle) * push;

    // đẩy nhẹ mỗi clone ra xa nhau
    a.x -= offsetX;
    a.y -= offsetY;
    b.x += offsetX;
    b.y += offsetY;
  }
}

    });
  }
}
// === Kỹ năng "🩸 Quả Cầu Hấp Huyết"
if (bloodOrbActive) {
    if (Date.now() > bloodOrbEndTime) {
        bloodOrbActive = false;
        bloodOrbs = [];
        return; // Kết thúc kỹ năng ngay khi hết thời gian
    }

    bloodOrbs.forEach(o => {
        o.angle += 0.01; // Tốc độ xoay quanh player
        o.x = player.x + Math.cos(o.angle) * o.radius;
        o.y = player.y + Math.sin(o.angle) * o.radius;

        // Tìm zombie gần nhất trong bán kính 300
        let nearest = null;
        let nearestDist = Infinity;
        zombies.forEach(z => {
            if (!z.active) return;
            const d = distance(o, z);
            if (d < 300 && d < nearestDist) {
                nearest = z;
                nearestDist = d;
            }
        });

        if (nearest !== o.target) {
            o.target = nearest;
            o.lockTime = Date.now();
        }

        if (!o.target) return;

        // Chỉ hút máu sau khi lock mục tiêu 0.4 giây
        if (Date.now() - o.lockTime > 400 && Date.now() - bloodOrbLastDrain > 300) {
            bloodOrbLastDrain = Date.now();
            const skill = activeSkills.find(s => s.name === "Quả cầu hấp huyết");
            dealDamageToZombie(o.target, skill?.baseDamage || 1);
            player.hearts++;
            showWarning("❤️ Hút máu +1");
            // Trong update Blood Orb mỗi lần hút máu:
for (let i = 0; i < 2; i++) {
    createBloodOrbParticle(o);
}
// Trong hút máu Blood Orb:
for (let i = 0; i < 2; i++) {
    createBloodOrbParticleOnBeam(o);
}
}
});
}
updateParticles();

updatePet();   // 🐰 xử lý pet mỗi frame

zombies = zombies.filter(z => z.active);

  updateUI();
  updateStatsOverlay();
  updateEnemyBullets();
}
// === 🌍 MINI MAP ===
// Toàn bản đồ rộng 3000 x 2000 (có thể điều chỉnh)
const worldWidth = 3000;
const worldHeight = 2000;
const wallThickness = 10; // Độ dày tường viền bản đồ
const miniMapCanvas = document.getElementById("miniMap");
const miniCtx = miniMapCanvas.getContext("2d");
let showMiniMap = false; //false để ẩn ban đầu

// Bắt phím M để bật/tắt
document.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "m") {
    showMiniMap = !showMiniMap;
    miniMapCanvas.style.display = showMiniMap ? "block" : "none";
  }
  // ⌨️ Ẩn/hiện menu UI khi bấm phím C
  if (e.key.toLowerCase() === "c") {
    uiVisible = !uiVisible;
    const ui = document.getElementById("ui");
    ui.style.display = uiVisible ? "flex" : "none";
}
});

// Hàm vẽ mini map
function drawMiniMap() {
  if (!showMiniMap) return;

  miniCtx.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

  const scaleX = miniMapCanvas.width / worldWidth;
  const scaleY = miniMapCanvas.height / worldHeight;
 // 👇 mới thêm – dễ chỉnh kích thước sau này
  const ITEM_SIZE   = 1.2;   // chiều rộng/ cao dấu vật phẩm (px trên minimap)
  const ZOMBIE_SIZE = 2;     // zombie thường (ô vuông)
  const DOT_PLAYER  = 3;     // bán kính chấm player & boss/mini
  // Draw items (energy, mana, hp)
  for (let it of items) {
    if (!it.active) continue;
    switch (it.type) {
      case "energy": miniCtx.fillStyle = "yellow"; break; // Màu vàng cho năng lượng
      case "mana": miniCtx.fillStyle = "cyan"; break; // Màu xanh lam cho mana
      case "hp": miniCtx.fillStyle = "lime"; break; // Màu xanh lá cây cho HP
      case "box": miniCtx.fillStyle = "blue"; break; // Màu xanh dương cho hộp
      default: miniCtx.fillStyle = "gray";
    }
    miniCtx.fillRect(it.x * scaleX - 0.5, it.y * scaleY - 0.5, 1, 1); // Vẽ kích thước vật phẩm trên minimap
  }
// 💜 Vẽ clone trên minimap
clones.forEach(clone => {
  const mapX = (clone.x / worldWidth) * miniMapCanvas.width;
  const mapY = (clone.y / worldHeight) * miniMapCanvas.height;
  miniCtx.fillStyle = "#cc66ff";
  miniCtx.beginPath();
  miniCtx.arc(mapX, mapY, 2, 0, Math.PI * 2);
  miniCtx.fill();
});
// 🟦 Vẽ máy bay trên minimap
activePlanes.forEach(plane => {
  const mapX = (plane.x / worldWidth) * miniMapCanvas.width;
  const mapY = (plane.y / worldHeight) * miniMapCanvas.height;
  miniCtx.fillStyle = "#cc66ff";
  miniCtx.beginPath();
  miniCtx.arc(mapX, mapY, 2, 0, Math.PI * 2);
  miniCtx.fill();
});
  // Draw zombies
for (let z of zombies) {
  if (!z.active) continue;

  const mapX = (z.x / worldWidth) * miniMapCanvas.width;
  const mapY = (z.y / worldHeight) * miniMapCanvas.height;

  if (z.isBigBoss) {
    // 💚 BigBoss – to nhất, màu rõ ràng khác hẳn
    miniCtx.fillStyle = "purple";
    miniCtx.beginPath();
    miniCtx.arc(mapX, mapY, 3, 0, Math.PI * 2);
    miniCtx.fill();
  } 
  else if (z.isBoss) {
    // 🔴 Boss thường – màu đỏ hoặc cam, tuỳ bạn
    miniCtx.fillStyle = "orange";
    miniCtx.beginPath();
    miniCtx.arc(mapX, mapY, 2, 0, Math.PI * 2);
    miniCtx.fill();
  } 
  else if (z.type === "miniBoss") {
    // 🟠 MiniBoss – khác boss thường chút
    miniCtx.fillStyle = "gold";
    miniCtx.beginPath();
    miniCtx.arc(mapX, mapY, 1.5, 0, Math.PI * 2);
    miniCtx.fill();
  } 
  else {
    // 🔲 Zombie thường – vuông nhỏ
    miniCtx.fillStyle = "red";
    miniCtx.fillRect(mapX - 1, mapY - 1, 2, 2);
  }
}
  // Draw player
  miniCtx.fillStyle = "#00ccff";  // Xanh dương đồng bộ tên
  miniCtx.beginPath();
  miniCtx.arc(player.x * scaleX, player.y * scaleY, 2, 0, Math.PI * 2);
  miniCtx.fill();
  /* — chấm pet Thỏ màu hồng — */
if (petRabbit && petActive) {
  miniCtx.fillStyle = "#ff4dc4";          // hồng đậm
  miniCtx.beginPath();
  miniCtx.arc(petRabbit.x * scaleX, petRabbit.y * scaleY, 2, 0, Math.PI * 2);
  miniCtx.fill();
}
}
// 🎨 Vẽ đường chéo sọc (diagonal stripes) trên canvas
function drawDiagonalStripes(ctx, x, y, width, height, stripeColor = "#666", spacing = 10) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(x, y, width, height);
  ctx.clip();

  ctx.strokeStyle = stripeColor;
  ctx.lineWidth = 1; // Độ dày đường sọc

  const maxLength = width + height;
  for (let i = -height; i < maxLength; i += spacing) {
    ctx.beginPath();
    ctx.moveTo(x + i, y);
    ctx.lineTo(x + i - height, y + height);
    ctx.stroke();
  }

  ctx.restore();
}
function drawBloodOrb(ctx) {
    if (!bloodOrbActive) return;
    bloodOrbs.forEach(o => {
        ctx.save();
        ctx.translate(o.x, o.y);

        // Quả cầu tự xoay quanh chính nó
        ctx.rotate(frame / 100);

        // === Vẽ các gai dài ===
        ctx.shadowBlur = 6;         // Thêm blur cho các gai
        ctx.shadowColor = "red";
        for (let i = 0; i < 12; i++) {
            const angle = (Math.PI * 2 / 12) * i;
            const x = Math.cos(angle) * 24; // Gai dài hơn hẳn
            const y = Math.sin(angle) * 24;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(x, y);
            ctx.strokeStyle = "rgba(50, 0, 0, 0.7)";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // === Vẽ vòng tròn ngoài tối, viền đỏ bóng ===
        ctx.beginPath();
        ctx.arc(0, 0, 16, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(60, 0, 0, 0.9)";
        ctx.strokeStyle = "rgba(255,0,0,0.7)";
        ctx.lineWidth = 2;
        ctx.fill();
        ctx.stroke();

        // === Vẽ vòng tròn trong đỏ nhạt, trong suốt hơn ===
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255, 80, 80, 0.05)"; // 📍 Đỏ rất nhạt, trong suốt
        ctx.fill();
        ctx.restore();

        // === Icon 🩸 chính giữa ===
        ctx.font = "1rem Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "white";
        ctx.fillText("🩸", o.x, o.y);

        // === Beam nhịp tim ===
        if (!o.target) return;
        const z = o.target;
        ctx.beginPath();
        ctx.moveTo(o.x, o.y);
        const segments = 16;
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const x = o.x + (z.x - o.x) * t;
            const y = o.y + (z.y - o.y) * t + Math.sin(t * 6 * Math.PI + frame / 8) * 5;
            ctx.lineTo(x, y);
        }
        ctx.strokeStyle = "rgba(255,0,0,0.6)";
        ctx.lineWidth = 2;
        ctx.shadowBlur = 4;
        ctx.shadowColor = "red";
        ctx.stroke();
        ctx.shadowBlur = 0;
    });
}
function createBloodOrbParticleOnBeam(orb) {
    if (!orb.target) return;

    // Random vị trí dọc theo beam từ quả cầu tới zombie
    const t = Math.random(); // Từ 0 đến 1
    const x = orb.x + (orb.target.x - orb.x) * t;
    const y = orb.y + (orb.target.y - orb.y) * t;

    const dx = orb.x - x;
    const dy = orb.y - y;
    const speed = 0.5 + Math.random() * 0.5;

    particles.push({
        x: x,
        y: y,
        vx: dx * 0.02 * speed,
        vy: dy * 0.02 * speed,
        alpha: 1,
        size: 1 + Math.random() * 1,
        color: 'rgba(255, 0, 0, 0.6)',
        fastFade: true // Đánh dấu hạt tan nhanh
    });
}

// Tạo 1 hạt nhỏ bay ngược vào quả cầu mỗi khi hút máu
function createBloodOrbParticle(orb) {
  createSuctionDust(orb.x, orb.y, 40, "rgba(255,0,0,0.6)", true);
}
/**
 * Sinh 1 hạt bụi bay vào (cx, cy)
 * @param {number} cx, cy   – toạ độ tâm cần hút
 * @param {number} spread   – khoảng đặt hạt (mặc định 250-300 px)
 * @param {string} color    – màu/độ mờ hạt
 * @param {boolean} fast    – tan nhanh (dùng cho tia máu)
 */
function createSuctionDust(cx, cy, spread = 250,
                           color = "rgba(200,200,200,0.5)",
                           fast = false) {
  const a      = Math.random() * Math.PI * 2;
  const r      = spread + Math.random() * 50;
  const px     = cx + Math.cos(a) * r;
  const py     = cy + Math.sin(a) * r;
  const speed  = 0.02;

  particles.push({
    x : px,          y : py,
    vx: (cx - px) * speed,
    vy: (cy - py) * speed,
    size  : 1 + Math.random() * 2,
    alpha : 1,
    color ,
    fastFade: fast
  });
}
// Update vị trí hạt, giảm dần alpha để biến mất
function updateParticles() {
    particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        // Hạt hút máu tan nhanh, hạt khác tan chậm
        if (p.fastFade) {
            p.alpha -= 0.006; // tan cực nhanh
        } else {
            p.alpha -= 0.0006; // tan mượt mượt ~5s
        }
    });
    particles = particles.filter(p => p.alpha > 0);
}
// Vẽ hạt máu bay về quả cầu
function drawParticles(ctx) {
    particles.forEach(p => {
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    });
}
function updateDayNight() {
    const now = Date.now();
    const deltaTime = (now - lastUpdateTime) / 1000;
    lastUpdateTime = now;

    dayTime += deltaTime / dayDuration;
    if (dayTime >= 1) {
        dayTime -= 1; // Reset về 0 liên tục
    }
    // Lưu lại để chỗ khác dùng
    globalDeltaTime = deltaTime;
}

function drawBackgroundByTime(ctx) {
    const w = canvas.width;
    const h = canvas.height;

    // 🕒 Tính giờ 0 - 23
    const hour = Math.floor(dayTime * 24) % 24;

    // 🌗 Xác định độ tối / sáng theo thực tế
    let darkness = 0;

    if (hour >= 0 && hour < 4) {
        darkness = 0.6;
    } else if (hour >= 4 && hour < 6) {
        darkness = (6 - hour) / 2 * 0.6; // từ 0.6 -> 0
    } else if (hour >= 6 && hour < 11) {
        darkness = 0;
    } else if (hour >= 11 && hour < 13) {
        darkness = -0.2; // sáng hơn bình thường
    } else if (hour >= 13 && hour < 17) {
        darkness = 0;
    } else if (hour >= 17 && hour < 19) {
        darkness = (hour - 17) / 2 * 0.4; // từ 0 -> 0.4
    } else if (hour >= 19 && hour <= 23) {
        darkness = 0.6;
    }

    // 🌓 Phủ tối hoặc làm sáng hơn
    if (darkness > 0) {
        ctx.fillStyle = `rgba(0, 0, 0, ${darkness})`;
        ctx.fillRect(0, 0, w, h);
    } else if (darkness < 0) {
        ctx.fillStyle = `rgba(255, 255, 255, ${-darkness})`;
        ctx.fillRect(0, 0, w, h);
    }

    // ☀️ / 🌙 Vẽ biểu tượng báo ngày / đêm
    const iconX = 30;
    const iconY = 100;

    if (hour >= 6 && hour < 18) {
        ctx.beginPath();
        ctx.arc(iconX, iconY, 14, 0, Math.PI * 2);
        ctx.fillStyle = '#FFD966';
        ctx.fill();
        ctx.strokeStyle = '#CC9900';
        ctx.stroke();
    } else {
        ctx.beginPath();
        ctx.arc(iconX, iconY, 12, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(200, 200, 255, 0.8)`;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(iconX - 4, iconY - 2, 10, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(0,0,0,0.6)`;
        ctx.fill();
    }

    // 🕒 Số giờ 0-23
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(`${hour}`, iconX + 20, iconY);
}
const balloonColors = ['#f87171', '#fbbf24', '#34d399', '#60a5fa', '#c084fc'];
function randomizeBackground() {
    backgroundStars = [];
    backgroundBirds = [];
    backgroundTrees = [];
    backgroundClouds = [];
    backgroundPlanes = [];
    backgroundMushrooms = [];
    backgroundRocks = [];
    backgroundBalloons = [];
    backgroundSeeds = [];
    backgroundBigStars = [];

const bigStarCount = isNight() ? 10 : 3;
for (let i = 0; i < bigStarCount; i++) {
    backgroundBigStars.push([
        Math.random() * worldWidth,
        Math.random() * (worldHeight / 2)
    ]);
}
    // ⭐ Ngôi sao nhỏ, trải dài nửa trên map
const starCount = isNight() ? 300 : 50; // Ban đêm nhiều hơn, ban ngày ít hơn
for (let i = 0; i < starCount; i++) {
    backgroundStars.push([
        Math.random() * worldWidth,
        Math.random() * (worldHeight / 2)
    ]);
}
    // 🕊️ Chim, bay ở cao trung bình
    for (let i = 0; i < 15; i++) {
        backgroundBirds.push([
            Math.random() * worldWidth,
            50 + Math.random() * 100
        ]);
    }

    // 🌳 Cây phía xa dưới mặt đất
    for (let i = 0; i < 50; i++) {
        backgroundTrees.push([
            Math.random() * worldWidth,
            worldHeight - 150 + Math.random() * 20
        ]);
    }

    // ☁️ Mây đơn giản phía trên cây
for (let i = 0; i < 5; i++) {
    backgroundClouds.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 250 - Math.random() * 200,
        size: 0.5 + Math.random() * 1.5,
        speed: 0.05 + Math.random() * 0.1,
        isDark: Math.random() < 0.2 // 20% là mây xám
    });
}
    // ✈️ 🛩️Máy bay đơn giản phía trên mây
const planeIcons = ['✈️', '🛩️', '🚀'];
// Nhóm 1: Dọc rìa trái world map
for (let i = 0; i < 3; i++) {
    backgroundPlanes.push({
        x: -200 - Math.random() * 200,  // rìa trái ngoài map
        y: worldHeight / 2 + Math.random() * (worldHeight / 2), // giữa xuống dưới
        vx: 0.5 + Math.random() * 0.3,
        vy: -0.3 - Math.random() * 0.2,
        size: 0.8 + Math.random() * 1.5,
        opacity: 0.4 + Math.random() * 0.5,
        icon: planeIcons[Math.floor(Math.random() * planeIcons.length)]
    });
}
// Nhóm 2: Trải dài phía dưới toàn bản đồ
for (let i = 0; i < 3; i++) {
    backgroundPlanes.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 100 - Math.random() * 100,
        vx: 0.5 + Math.random() * 0.3,
        vy: -0.3 - Math.random() * 0.2,
        size: 0.8 + Math.random() * 1.5,
        opacity: 0.4 + Math.random() * 0.5,
        icon: planeIcons[Math.floor(Math.random() * planeIcons.length)]
    });
}
    // 🍄 Nấm dưới đất
    for (let i = 0; i < 30; i++) {
        backgroundMushrooms.push([
            Math.random() * worldWidth,
            worldHeight - 70 + Math.random() * 10
        ]);
    }

    // 🪨 Đá nhỏ dưới đất
    for (let i = 0; i < 30; i++) {
        backgroundRocks.push([
            Math.random() * worldWidth,
            worldHeight - 70 + Math.random() * 10
        ]);
    }

    // 🎈 Bóng bay màu ngẫu nhiên giữa map
for (let i = 0; i < 10; i++) {
    backgroundBalloons.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 300 - Math.random() * 100,
        vx: -0.05 + Math.random() * 0.1, // bay nhẹ trái/phải
        speed: 0.15 + Math.random() * 0.1, // bay lên chậm
        color: balloonColors[Math.floor(Math.random() * balloonColors.length)]
    });
}
    // 🌼 Hoa bồ công anh xuất hiện thấp, bay lên cao
for (let i = 0; i < 35; i++) {
    backgroundSeeds.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 300 - Math.random() * 100,
        vx: -0.1 + Math.random() * 0.2, // ngẫu nhiên từ -0.1 (trái) -> +0.1 (phải)
        speed: 0.02 + Math.random() * 0.05
    });
}
}
function drawCuteCloud(ctx, x, y, scale = 1, isDark = false) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    const gradient = ctx.createLinearGradient(0, -20, 0, 20);
    if (isDark) {
        gradient.addColorStop(0, 'rgba(150, 150, 150, 0.5)');
        gradient.addColorStop(1, 'rgba(100, 100, 100, 0.4)');
    } else {
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
        gradient.addColorStop(1, 'rgba(230, 230, 230, 0.7)');
    }
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(-30, 0, 20, Math.PI * 0.5, Math.PI * 1.5);
    ctx.arc(0, -20, 35, Math.PI, 0);
    ctx.arc(30, 0, 20, Math.PI * 1.5, Math.PI * 0.5);
    ctx.closePath();
    ctx.shadowColor = 'rgba(0,0,0,0.1)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetY = 4;
    ctx.fill();
    ctx.restore();
}
if (prevIsNight !== isNight()) {
    randomizeBackground();
    prevIsNight = isNight();
}

function isNight() {
    const hour = Math.floor(dayTime * 24) % 24;
    return hour >= 19 || hour < 6;
}
// Hình nền
function drawBackground() {
    // ===== BẦU TRỜI =====
    const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    skyGradient.addColorStop(0, '#0f172a');
    skyGradient.addColorStop(0.6, '#1e3a8a');
    skyGradient.addColorStop(1, '#60a5fa');
    ctx.fillStyle = skyGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

// ===== SAO NHỎ =====
backgroundStars.forEach(([x, y], index) => {
    const flicker = (Math.sin(performance.now() / 1000 + index) + 1) / 2; // 0 ~ 1 chậm, nhấp nháy nhẹ
    const alpha = isNight() ? 0.5 + flicker * 0.5 : 0.1; // Đêm sáng 0.5-1, ngày mờ nhẹ
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.fillRect(x - camera.x, y - camera.y, 1, 1);
});

// ===== SAO LỚN =====
backgroundBigStars.forEach(([x, y], index) => {
    const flicker = (Math.sin(performance.now() / 1500 + index) + 1) / 2; // chậm hơn sao nhỏ
    const alpha = isNight() ? 0.7 + flicker * 0.3 : 0.1;
    ctx.fillStyle = `rgba(255, 214, 64, ${alpha})`; // Màu vàng nhạt giống sao thật

    ctx.fillRect(x - 2 - camera.x, y - camera.y, 4, 1);
    ctx.fillRect(x - camera.x, y - 2 - camera.y, 1, 4);
});

    // ===== CHIM =====
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.beginPath();
    backgroundBirds.forEach(([x, y]) => {
        ctx.moveTo(x - camera.x, y - camera.y);
        ctx.lineTo(x + 4 - camera.x, y - 3 - camera.y);
        ctx.lineTo(x + 8 - camera.x, y - camera.y);
    });
    ctx.stroke();

    // ===== CÂY XA =====
    ctx.fillStyle = '#14532d';
    backgroundTrees.forEach(([x, y]) => {
        ctx.fillRect(x - camera.x, y - camera.y, 4, 40);
        ctx.beginPath();
        ctx.arc(x + 2 - camera.x, y - 10 - camera.y, 10, 0, Math.PI * 2);
        ctx.fill();
    });

    // ===== CÂY LỚN =====
    ctx.fillStyle = '#14532d';
    ctx.fillRect(120 - camera.x, worldHeight - 180 - camera.y, 10, 100);
    ctx.beginPath();
    ctx.arc(125 - camera.x, worldHeight - 180 - camera.y, 30, 0, Math.PI * 2);
    ctx.fill();
    for (let i = 0; i < 3; i++) {
        let x = 160 + i * 20;
        ctx.fillRect(x - camera.x, worldHeight - 130 - camera.y, 5, 50);
        ctx.beginPath();
        ctx.arc(x + 2.5 - camera.x, worldHeight - 130 - camera.y, 10, 0, Math.PI * 2);
        ctx.fill();
    }

    // ===== MÂY CUTE =====
backgroundClouds.forEach((cloud) => {
    cloud.x += cloud.speed;
    if (cloud.x - camera.x > canvas.width + 150) {
        cloud.x = camera.x - 200;
    }
    drawCuteCloud(ctx, cloud.x - camera.x, cloud.y - camera.y, cloud.size, cloud.isDark);
});
    // ===== MÁY BAY =====
backgroundPlanes.forEach(plane => {
    plane.x += plane.vx;
    plane.y += plane.vy;

    if (plane.x > worldWidth + 300 || plane.y < camera.y - 300) {
        if (Math.random() < 0.5) {
            // Reset kiểu dọc rìa trái
            plane.x = -200 - Math.random() * 200;
            plane.y = worldHeight / 2 + Math.random() * (worldHeight / 2);
        } else {
            // Reset kiểu dưới map trải ngang
            plane.x = Math.random() * worldWidth;
            plane.y = worldHeight - 100 - Math.random() * 100;
        }
        plane.vx = 0.5 + Math.random() * 0.3;
        plane.vy = -0.3 - Math.random() * 0.2;
    }

    const posX = plane.x - camera.x;
    const posY = plane.y - camera.y;

    ctx.save();
    ctx.globalAlpha = plane.opacity;
    ctx.font = `${18 * plane.size}px Arial`;
    ctx.fillText(plane.icon, posX, posY);
    ctx.restore();
});
    // ===== CỎ =====
    ctx.fillStyle = '#16a34a';
    ctx.beginPath();
    ctx.moveTo(0 - camera.x, worldHeight - 80 - camera.y);
    for (let i = 0; i <= worldWidth; i += 30) {
        ctx.lineTo(i + 15 - camera.x, worldHeight - 100 + (i % 60 ? -10 : 10) - camera.y);
    }
    ctx.lineTo(worldWidth - camera.x, worldHeight - 80 - camera.y);
    ctx.lineTo(worldWidth - camera.x, worldHeight - camera.y);
    ctx.lineTo(0 - camera.x, worldHeight - camera.y);
    ctx.closePath();
    ctx.fill();

    // ===== ĐẤT =====
    ctx.fillStyle = '#fbd38d';
    ctx.fillRect(0 - camera.x, worldHeight - 80 - camera.y, worldWidth, 40);
    ctx.fillStyle = '#d97706';
    ctx.fillRect(0 - camera.x, worldHeight - 40 - camera.y, worldWidth, 4);

    // ===== NẤM =====
    backgroundMushrooms.forEach(([x, y]) => {
        ctx.fillStyle = '#b91c1c';
        ctx.beginPath();
        ctx.arc(x - camera.x, y - camera.y, 4, 0, Math.PI);
        ctx.fill();
        ctx.fillStyle = '#92400e';
        ctx.fillRect(x - 1 - camera.x, y - camera.y, 2, 5);
    });

    // ===== ĐÁ =====
    ctx.fillStyle = '#444';
    backgroundRocks.forEach(([x, y]) => {
        ctx.beginPath();
        ctx.ellipse(x - camera.x, y - camera.y, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
    });

    // ===== BÓNG BAY =====
backgroundBalloons.forEach(balloon => {
    balloon.x += balloon.vx;
    balloon.y -= balloon.speed;

    // Khi bay quá cao so với camera thì reset về dưới thấp
    if (balloon.y < camera.y + 100) {
        balloon.x = Math.random() * worldWidth;
        balloon.y = worldHeight - 300 - Math.random() * 100;
        balloon.vx = -0.05 + Math.random() * 0.1;
        balloon.speed = 0.15 + Math.random() * 0.1;
    }

    // Vẽ dây nhỏ
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath();
    ctx.moveTo(balloon.x - camera.x, balloon.y + 20 - camera.y);
    ctx.lineTo(balloon.x - camera.x, balloon.y + 30 - camera.y);
    ctx.stroke();

    // Vẽ bóng bay
    ctx.fillStyle = balloon.color;
    ctx.beginPath();
    ctx.ellipse(balloon.x - camera.x, balloon.y - camera.y, 10, 15, 0, 0, Math.PI * 2);
    ctx.fill();

    // Hiệu ứng sáng nhẹ
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath();
    ctx.ellipse(balloon.x - 4 - camera.x, balloon.y - 6 - camera.y, 2, 4, 0, 0, Math.PI * 2);
    ctx.fill();
});
    // ===== HOA BỒ CÔNG ANH =====
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.lineWidth = 0.5;
    backgroundSeeds.forEach((seed) => {
        seed.x += seed.vx;
        seed.y -= seed.speed;

        if (seed.y < camera.y + 100) {
            seed.x = Math.random() * worldWidth;
            seed.y = worldHeight - 300 - Math.random() * 100;
            seed.vx = -0.1 + Math.random() * 0.2;
            seed.speed = 0.02 + Math.random() * 0.05;
        }

        let posX = seed.x - camera.x;
        let posY = seed.y - camera.y;

        ctx.beginPath();
        ctx.moveTo(posX, posY);
        ctx.lineTo(posX, posY + 6);
        ctx.stroke();

        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            let angle = (Math.PI * 2 / 8) * i;
            let endX = posX + Math.cos(angle) * 4;
            let endY = posY + Math.sin(angle) * 2;
            ctx.moveTo(posX, posY);
            ctx.lineTo(endX, endY);
        }
        ctx.stroke();
    });
}

//🎨 9. Vẽ khung hình (draw canvas)
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  updateDayNight();
  drawBackground();
  drawBackgroundByTime(ctx);
  ctx.save();
  ctx.translate(-camera.x, -camera.y); // dịch toàn bộ hệ tọa độ theo camera

// 🧱 Vẽ tường dày có sọc chéo
ctx.fillStyle = "#123"; // nền tối
ctx.fillRect(0, 0, worldWidth, wallThickness); // Trên
ctx.fillRect(0, worldHeight - wallThickness, worldWidth, wallThickness); // Dưới
ctx.fillRect(0, 0, wallThickness, worldHeight); // Trái
ctx.fillRect(worldWidth - wallThickness, 0, wallThickness, worldHeight); // Phải

// 🎨 Vẽ sọc chéo lên từng cạnh
drawDiagonalStripes(ctx, 0, 0, worldWidth, wallThickness); // Trên
drawDiagonalStripes(ctx, 0, worldHeight - wallThickness, worldWidth, wallThickness); // Dưới
drawDiagonalStripes(ctx, 0, 0, wallThickness, worldHeight); // Trái
drawDiagonalStripes(ctx, worldWidth - wallThickness, 0, wallThickness, worldHeight); // Phải

// 🎯 Vẽ tên người chơi trên đầu
ctx.font = "1rem sans-serif";
ctx.fillStyle = "#00ccff"; // 💙 Màu xanh dương
ctx.shadowColor = "#00ccff";
ctx.shadowBlur = 8;
ctx.textAlign = "center";
ctx.textBaseline = "bottom";
ctx.fillText(player.name, player.x, player.y - player.size - 4); // Vẽ tên trên đầu player
ctx.shadowBlur = 0; // reset sau khi vẽ
ctx.shadowColor = "transparent";
// Vẽ hình tròn player
if (disguiseActive) {
  // 🐸 Vẽ ếch thay cho player
  ctx.save();
  ctx.font = "2rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.shadowColor = "lime";
  ctx.shadowBlur = 8;
  ctx.globalAlpha = 0.6;
  ctx.fillStyle = "white";
  ctx.fillText("🐸", player.x, player.y);
  ctx.restore();
} else {
  // 🧍 Vẽ player bình thường
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);

  if (levelUpGlowTime > 0) {
    ctx.shadowBlur = 4;
    ctx.shadowColor = "gold";
    ctx.fillStyle = "gold";
  } else {
    ctx.shadowBlur = 0;
    ctx.shadowColor = "transparent";
    ctx.fillStyle = (player.hitTimer % 10 < 5) ? "#ff4c4c" : "#00ff00";
  }

  ctx.fill();
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = "rgba(0, 255, 255, 0.4)";
  ctx.shadowColor = "rgba(0, 255, 255, 0.25)";
  ctx.stroke();
}
// 🎭 Vẽ các ảo ảnh phân thân
clones.forEach((c,i) => {
  ctx.save();
  ctx.beginPath();
  ctx.arc(c.x, c.y, player.size * 0.75, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
  ctx.shadowBlur = 8;
  ctx.shadowColor = "#aaaaff";
  ctx.fill();
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = "rgba(0,255,255,0.6)";
  ctx.stroke();
  ctx.restore();

  // 👁️ Mắt của clone
  ctx.beginPath();
  ctx.arc(c.x - 3, c.y - 5, 1.5, 0, Math.PI * 2);
  ctx.arc(c.x + 3, c.y - 5, 1.5, 0, Math.PI * 2);
  ctx.fillStyle = "white";
  ctx.fill();
// 👄 Miệng clone
  ctx.beginPath();
  ctx.arc(c.x, c.y + 4, 5, 0, Math.PI); // nửa cung tròn hướng lên (miệng cười)
  ctx.strokeStyle = "rgba(0, 100, 200, 0.6)";
  ctx.lineWidth = 1.2;
  ctx.stroke();
   // 🏷️ Tên clone (Clone 1, 2, ...)
  ctx.font = "bold 12px Segoe UI";
  ctx.fillStyle = "#00ccff"; // Màu xanh dương
  ctx.textAlign = "center";
  ctx.fillText(`Clone ${i + 1}`, c.x, c.y - 22);
});

  bullets.forEach(b => {
  if (!b.active) return; // 🛡 bỏ qua đạn đã bị gỡ
ctx.save();
ctx.translate(b.x, b.y);
if (b.piercing) {
  b.rotation = (b.rotation || 0) + 0.3;
  ctx.rotate(b.rotation);
  ctx.fillStyle = b.color || "cyan";
  ctx.beginPath();
  ctx.moveTo(-6, -3); // Vẽ đạn zigzag
  ctx.lineTo(6, 0);
  ctx.lineTo(-6, 3);
  ctx.closePath();
  ctx.shadowBlur = 4; // Thêm hiệu ứng phát sáng
  ctx.shadowColor = b.color || "cyan";
  ctx.fill();
} else {
  ctx.beginPath();
  ctx.arc(0, 0, 5, 0, Math.PI * 2); // Vẽ hình tròn đạn
  ctx.fillStyle = b.color || "yellow";
  //ctx.shadowBlur = 8;
  //ctx.shadowColor = b.color || "yellow"; // hiệu ứng sáng cùng màu
  ctx.fill();
}
ctx.restore();
});

// 🔫 Vẽ đạn từ boss & mini boss
enemyBullets.forEach(b => {
  ctx.beginPath();
  ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
  ctx.fillStyle = "red";
  ctx.fill();
});
// Vẽ bigboss
function drawBigBoss(ctx, x, y, radius, hp) {
    ctx.save();
    ctx.translate(x, y);

    // Ánh sáng nền
    ctx.beginPath();
    ctx.arc(0, 0, radius + 20, 0, Math.PI * 2);
    ctx.fillStyle = "#150d25";
    ctx.shadowColor = "#a445f5";
    ctx.shadowBlur = 50;
    ctx.fill();
    ctx.shadowBlur = 0;

    // Tay trái
    ctx.beginPath();
    ctx.moveTo(-radius * 0.55, -radius * 0.1);
    ctx.quadraticCurveTo(-radius, 0, -radius * 0.9, radius * 0.3);
    ctx.quadraticCurveTo(-radius * 0.8, radius * 0.1, -radius * 0.5, 0);
    ctx.closePath();
    ctx.fillStyle = "#4e2d6d";
    ctx.fill();

    // Tay phải
    ctx.beginPath();
    ctx.moveTo(radius * 0.55, -radius * 0.1);
    ctx.quadraticCurveTo(radius, 0, radius * 0.9, radius * 0.3);
    ctx.quadraticCurveTo(radius * 0.8, radius * 0.1, radius * 0.5, 0);
    ctx.closePath();
    ctx.fill();

    // Chân trái (dài hơn)
    ctx.beginPath();
    ctx.moveTo(-20, radius * 0.4);
    ctx.lineTo(-30, radius * 0.8);
    ctx.lineTo(-10, radius * 0.8);
    ctx.lineTo(0, radius * 0.4);
    ctx.closePath();
    ctx.fill();

    // Chân phải (dài hơn)
    ctx.beginPath();
    ctx.moveTo(20, radius * 0.4);
    ctx.lineTo(30, radius * 0.8);
    ctx.lineTo(10, radius * 0.8);
    ctx.lineTo(0, radius * 0.4);
    ctx.closePath();
    ctx.fill();

    // Cơ thể
    ctx.beginPath();
    ctx.moveTo(-radius * 0.6, -radius * 0.1);
    ctx.bezierCurveTo(-radius * 0.75, radius * 0.3, -30, radius * 0.6, 0, radius * 0.5);
    ctx.bezierCurveTo(30, radius * 0.6, radius * 0.75, radius * 0.3, radius * 0.6, -radius * 0.1);
    ctx.closePath();
    ctx.fillStyle = "#4e2d6d";
    ctx.fill();

    // Bụng rách
    ctx.beginPath();
    ctx.moveTo(-15, 20);
    ctx.lineTo(0, 30);
    ctx.lineTo(15, 20);
    ctx.lineTo(0, 40);
    ctx.closePath();
    ctx.fillStyle = "#8b1f1f";
    ctx.fill();

    // Đầu
    ctx.beginPath();
    ctx.ellipse(0, -radius * 0.35, 45, 60, 0, 0, Math.PI * 2);
    ctx.fillStyle = "#6f3c9c";
    ctx.fill();
    ctx.strokeStyle = "#26142e";
    ctx.lineWidth = 3;
    ctx.stroke();

    // Mắt đỏ glow
    function eye(x, y) {
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fillStyle = "#ff3333";
        ctx.shadowColor = "#ff0000";
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
    }
    eye(-18, -radius * 0.4);
    eye(18, -radius * 0.4);

    // Lông mày
    ctx.strokeStyle = "#2e163a";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-28, -radius * 0.47);
    ctx.lineTo(-8, -radius * 0.5);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(28, -radius * 0.47);
    ctx.lineTo(8, -radius * 0.5);
    ctx.stroke();

    // Tóc
    ctx.beginPath();
    ctx.arc(0, -radius * 0.6, 30, Math.PI, 0);
    ctx.fillStyle = "#1e0f2a";
    ctx.fill();

    // Mũi
    ctx.beginPath();
    ctx.moveTo(-5, -radius * 0.2);
    ctx.lineTo(0, -radius * 0.15);
    ctx.lineTo(5, -radius * 0.2);
    ctx.fillStyle = "#3a1f4d";
    ctx.fill();

    // Miệng đen + răng nanh đen
    ctx.beginPath();
    ctx.moveTo(-18, -radius * 0.1);
    ctx.quadraticCurveTo(0, 0, 18, -radius * 0.1);
    ctx.quadraticCurveTo(0, 10, -18, -radius * 0.1);
    ctx.closePath();
    ctx.fillStyle = "#120000";
    ctx.fill();

    // Răng nanh đen nhỏ
    ctx.fillStyle = "#120000";
    function fang(x, y, h, flip = 1) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 3 * flip, y + h);
        ctx.lineTo(x - 3 * flip, y + h);
        ctx.closePath();
        ctx.fill();
    }
    fang(-8, -radius * 0.1 + 5, 6);
    fang(8, -radius * 0.1 + 5, 6);

    // Vết nứt đầu
    ctx.beginPath();
    ctx.moveTo(-10, -radius * 0.6);
    ctx.lineTo(-5, -radius * 0.5);
    ctx.lineTo(-15, -radius * 0.4);
    ctx.lineTo(-5, -radius * 0.3);
    ctx.strokeStyle = "#4b2b60";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Sẹo mặt
    ctx.beginPath();
    ctx.moveTo(22, -8);
    ctx.lineTo(18, 3);
    ctx.lineTo(28, 6);
    ctx.strokeStyle = "#8a477e";
    ctx.stroke();

    // Sẹo ngực
    ctx.beginPath();
    ctx.moveTo(-18, 28);
    ctx.lineTo(-8, 38);
    ctx.lineTo(-22, 48);
    ctx.stroke();

    // Giáp vai
    ctx.fillStyle = "#2b2b2b";
    ctx.beginPath();
    ctx.moveTo(-55, -5);
    ctx.quadraticCurveTo(-90, 10, -70, 35);
    ctx.quadraticCurveTo(-40, 20, -35, 25);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(55, -5);
    ctx.quadraticCurveTo(90, 10, 70, 35);
    ctx.quadraticCurveTo(40, 20, 35, 25);
    ctx.closePath();
    ctx.fill();

    // Sừng vỡ
    function horn(x, y, flip = 1) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.bezierCurveTo(x + 15 * flip, y - 35, x + 25 * flip, y - 55, x + 10 * flip, y);
        ctx.lineTo(x + 4 * flip, y);
        ctx.closePath();
        ctx.fillStyle = "#444";
        ctx.fill();
        ctx.strokeStyle = "#222";
        ctx.stroke();
    }
    horn(-30, -radius * 0.6, -1);
    horn(30, -radius * 0.6, 1);

    // BIG + HP
    ctx.font = `${radius * 0.3}px sans-serif`;
    ctx.fillStyle = "violet";
    ctx.textAlign = "center";
    ctx.strokeStyle = "#bb99ff";
    ctx.lineWidth = 2;
    ctx.strokeText(`BIG ${hp}`, 0, -radius - 30);
    ctx.fillText(`BIG ${hp}`, 0, -radius - 30);

    ctx.restore();
}
// Vẽ toàn bộ zombie hoạt động kèm icon, HP, trạng thái, biểu cảm (tối ưu fillText)
zombies.forEach(z => {
  if (!z.active) return;
  // 🆕 Vẽ BigBoss giống Boss nhưng riêng block để dễ quản lý
if (z.isBigBoss) {
    drawBigBoss(ctx, z.x, z.y, z.radius, z.hp);
    return;
}
  ctx.save();

// ✨ Glow cho Boss hoặc MiniBoss
  if (z.isBoss || z.type === "miniBoss") {
    ctx.shadowColor = z.color || "#ffffff";
    ctx.shadowBlur = z.isBoss ? 4 : 2;
  } else {
    ctx.shadowColor = "transparent";
    ctx.shadowBlur = 0;
  }

// 🎯 Vẽ hình tròn zombie
  ctx.beginPath();
  ctx.arc(z.x, z.y, z.radius, 0, Math.PI * 2);
  ctx.fillStyle = z.color || "#ff69b4";
  ctx.fill();
  ctx.restore();

// === 🆕 fillText gộp toàn bộ thông tin ===
ctx.save();

// 🧠 Font chung
ctx.fillStyle = "#fff";
ctx.textAlign = "center";
ctx.textBaseline = "middle";

// 🅰️ Vẽ cấp + HP trên đầu zombie
let levelChar = "";
if (z.isBoss) levelChar = "SS";
else if (z.type === "miniBoss") levelChar = "S";
else levelChar = String.fromCharCode(96 + (z.level || 1));

// ✨ Giảm kích thước font nếu là boss hoặc mini boss
let levelFontSize = z.radius * 0.9; // mặc định cho zombie thường
if (z.type === "miniBoss") levelFontSize = z.radius * 0.6;
if (z.isBoss) levelFontSize = z.radius * 0.5;

ctx.font = `${levelFontSize}px sans-serif`;
ctx.textAlign = "center";
ctx.textBaseline = "middle"; // Vị trí icon zombie
ctx.fillStyle = z.color || "#fff";
ctx.fillText(`${levelChar}-${z.hp}`, z.x, z.y - z.radius - 8); // Chữ trên đầu zombie

// 🧟 Vẽ icon zombie ở giữa thân
ctx.font = `${z.radius * 1.5}px sans-serif`;
const iconChar = z.isBoss ? "💀" : "🧟";
ctx.fillText(iconChar, z.x, z.y);

// 😴 Trạng thái (chỉ zombie thường & có icon)
// 🎯 Hiển thị icon hành vi: 😡 khi chasing, 😖/💤Zzz khi wandering (30%)
let behaviorIcon = null;
// Boss sẽ không có icon trạng thái
if (!z.isBoss && z.state === "chasing" && z.showStatusIcon) {
  behaviorIcon = "😡";
} else if (!z.isBoss && z.type !== "miniBoss" && z.state === "wandering") {
  const isSleeping = z.wanderBehavior === "pause";

  // 💤 Đang lang thang & đứng im
  if (isSleeping && isNight()) {
    behaviorIcon = "💤"; // 💯 luôn hiển thị khi ban đêm
  } else if (z.showStatusIcon) {
    behaviorIcon = isSleeping ? "💤" : "😖"; // Ngày thường theo 30%
  }
}

if (behaviorIcon) {
  ctx.font = `${z.radius}px sans-serif`;
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillStyle = "#fff";
  ctx.fillText(behaviorIcon, z.x + z.radius * 0.6, z.y - z.radius * 1.2);
}
ctx.restore();

  // 💬 Biểu cảm (chỉ zombie thường mới có)
  if (!z.isBoss && z.iconToDraw) {
    ctx.save();
    ctx.font = `${z.radius * 1.2}px serif`;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#fff";
    ctx.shadowColor = "#000";
    ctx.shadowBlur = 4;
ctx.font = `${z.radius}px sans-serif`;
ctx.textAlign = "left";
ctx.textBaseline = "top";
ctx.fillStyle = "#fff";
ctx.fillText(z.iconToDraw, z.x + z.radius * 0.6, z.y - z.radius * 1.2);
    ctx.restore();
}
});
// Mắt và miệng xoay theo hướng zombie gần nhất
if (zombies.length > 0) {
  const target = zombies.reduce((a, b) => distance(a, player) < distance(b, player) ? a : b);
  const angle = Math.atan2(target.y - player.y, target.x - player.x);
  const eyeOffsetX = Math.cos(angle) * 6;
  const eyeOffsetY = Math.sin(angle) * 6;
  const mouthOffsetX = Math.cos(angle) * 10;
  const mouthOffsetY = Math.sin(angle) * 10;

// Mắt trái
  ctx.beginPath();
  ctx.arc(player.x + eyeOffsetX - 4, player.y + eyeOffsetY - 4, 2, 0, Math.PI * 2);
  ctx.fillStyle = "white";
  ctx.fill();

// Mắt phải
  ctx.beginPath();
  ctx.arc(player.x + eyeOffsetX + 4, player.y + eyeOffsetY - 4, 2, 0, Math.PI * 2);
  ctx.fill();

// Miệng
  ctx.beginPath();
  ctx.arc(player.x + mouthOffsetX, player.y + mouthOffsetY + 3, 2, 0, Math.PI);
  ctx.strokeStyle = "white";
  ctx.lineWidth = 1;
  ctx.stroke();
}
// Vẽ lớp khiên nếu đang hoạt động
function drawHex3D(ctx, x, y, size) {
  const gradient = ctx.createRadialGradient(x, y, size * 0.3, x, y, size);
  gradient.addColorStop(0, "rgba(0,255,255,0.25)");
  gradient.addColorStop(1, "rgba(0,200,255,0.05)");

  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const angle = Math.PI / 3 * i;
    const px = x + size * Math.cos(angle);
    const py = y + size * Math.sin(angle);
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fillStyle = gradient;
  ctx.strokeStyle = "rgba(0,255,255,0.1)";
  ctx.lineWidth = 0.8;
  ctx.fill();
  ctx.stroke();
}

if (player.shieldActive) {
// Vòng tròn ngoài cùng
  const pulse = Math.sin(Date.now() / 200) * 2;
  ctx.save();
  ctx.globalAlpha = 0.6;
  ctx.beginPath();
  ctx.arc(player.x, player.y, 48 + pulse, 0, Math.PI * 2);
  ctx.strokeStyle = "rgba(0,200,255,0.7)";
  ctx.lineWidth = 4;
  ctx.shadowColor = "#00eaff";
  ctx.shadowBlur = 10;
  ctx.stroke();
  ctx.restore();

// Vẽ mạng lưới lục giác đều trong khiên
const hexSize = 10;
const spacingX = hexSize * Math.sqrt(3);
const spacingY = hexSize * 1.5;
const radius = 45;
const angleOffset = Date.now() / 3000; // Góc xoay theo thời gian

for (let row = -5; row <= 5; row++) {
  for (let col = -5; col <= 5; col++) {
    const offsetX = (row % 2 === 0) ? 0 : spacingX / 2;
    const x0 = col * spacingX + offsetX;
    const y0 = row * spacingY;

    const dx = x0;
    const dy = y0;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < radius) {
// 👉 Xoay điểm quanh tâm player
      const angle = angleOffset;
      const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
      const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
      const px = player.x + rotatedX;
      const py = player.y + rotatedY;
      drawHex3D(ctx, px, py, hexSize);
}
}
}
}

// Vẽ vệ tinh laze 🛰️
satellites.forEach(sat => {
  ctx.save();
  ctx.translate(sat.x, sat.y);
  ctx.shadowBlur = 10;
  ctx.shadowColor = "cyan";
  ctx.fillStyle = "white";
  ctx.font = "1.2rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("🛰️", 0, 0);
  ctx.restore();
});

explosions.forEach(e => {
  ctx.beginPath();
  ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
  ctx.fillStyle = `rgba(255, 200, 0, ${e.life / 20})`;
  ctx.fill();
});
// Vẽ tia laze cho từng vệ tinh
satellites.forEach(sat => {
  if (sat.laserBeam && sat.laserBeam.life > 0) {
    const x1 = sat.x, y1 = sat.y;
    const angle = sat.laserBeam.angle;
    const x2 = x1 + Math.cos(angle) * 500;
    const y2 = y1 + Math.sin(angle) * 500;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = "rgba(0, 255, 255, 0.8)";
    ctx.lineWidth = 3;
    ctx.shadowColor = "cyan";
    ctx.shadowBlur = 12;
    ctx.stroke();
    ctx.restore();
  }
});
if (ufoActive) {
    ufos.forEach(ufo => {
    ufo.x += ufo.speed;

// Nếu đi hết trái màn hình → vòng lại bên phải
    if (ufo.x < -100) {
      ufo.x = canvas.width + 100;
      ufo.y = 300 + (Math.random() * 150 - 150); // Vòng lại trên cao
}

// Bắn laze mỗi 1s
    if (Date.now() - ufo.laserCooldown > 1000) {
      ufo.laserCooldown = Date.now();
      ufo.laserLife = 60;

// Tìm mục tiêu gần nhất
      const origin = { x: ufo.x, y: ufo.y };
      const target = zombies.find(z => z.active && distance(origin, z) < 300);
if (target) {
        const angle = Math.atan2(target.y - ufo.y, target.x - ufo.x);
        ufo.angle = angle;

// Gây sát thương xuyên
    zombies.forEach(z => {
if (!z.active) return;
    const dx = Math.cos(angle), dy = Math.sin(angle);
    const proj = (z.x - ufo.x) * dx + (z.y - ufo.y) * dy;
    const perp = Math.abs((z.x - ufo.x) * dy - (z.y - ufo.y) * dx);
// Nếu zombie nằm gần đường bắn và trong khoảng bắn
if (proj > 0 && proj < 1200 && perp < 20) {
    dealDamageToZombie(z, ufo.damage);
}
});
}
}
if (ufo.laserLife > 0) ufo.laserLife--;
});
}
ufos.forEach(ufo => {
  // UFO icon
  ctx.save();
  ctx.translate(ufo.x, ufo.y);
  ctx.shadowBlur = 10;
  ctx.shadowColor = "red";
  ctx.fillStyle = "white";
  ctx.font = "1.4rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("🛸", 0, 0);
  ctx.restore();

  // Tia laze đỏ
  if (ufo.laserLife > 0) {
    const x1 = ufo.x;
    const y1 = ufo.y;
const laserLength = 1200; // hoặc 1000 nếu bạn muốn xuyên toàn bản đồ
const x2 = x1 + Math.cos(ufo.angle) * laserLength;
const y2 = y1 + Math.sin(ufo.angle) * laserLength;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = "rgba(255, 0, 0, 0.8)";
    ctx.lineWidth = 3;
    ctx.shadowColor = "red";
    ctx.shadowBlur = 15;
    ctx.stroke();
    ctx.restore();
  }
});
extraShockwaves.forEach(sw => {
  ctx.save();
  ctx.beginPath();
  ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2);
  ctx.strokeStyle = sw.color;
  ctx.globalAlpha = sw.alpha;
  ctx.lineWidth = 3;
  ctx.shadowColor = sw.color;
  ctx.shadowBlur = 12;
  ctx.stroke();
  ctx.restore();
});

drawItems();
drawEffects();

// 🎨 Vẽ vật phẩm hiện có trên màn hình
function drawItems() {
  items.forEach(it => {
    if (!it.active) return;
    ctx.save();

// Cài đặt font chữ và căn chỉnh cho vật phẩm
    ctx.font = "0.9rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    let icon, color;

// Chọn icon và màu sắc phù hợp với từng vật phẩm
    switch (it.type) {
      case 'energy':
        icon = "⚡";
        color = "gold";
        break;
      case 'mana':
        icon = "💠";
        color = "cyan";
        break;
      case 'hp':
        icon = "❤️";
        color = "red";
        break;
      case 'box':
        icon = "📦";
        color = "#fff";
        break;
}

// Tạo hiệu ứng nhẹ (bóng đổ và chuyển động nhẹ nhàng)
    ctx.shadowBlur = 3;
    ctx.shadowColor = color;
    ctx.fillStyle = color;
    const bob = Math.sin(frame / 10 + it.x + it.y) * 2;
    ctx.fillText(icon, it.x, it.y + bob);
    ctx.restore();
  });
}
// 🌩️ Vẽ tia sét
function drawLightningBolts() { // render mây & tia sét
  if (!lightningActive) return;

  ctx.save();                      // ① bảo toàn camera
  lightningBolts.forEach(bolt => {
    /* ☁️ 1. Vẽ mây */
    ctx.save();
    ctx.font = "2rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "yellow";
    ctx.shadowColor = "gold";
    ctx.shadowBlur = 16;
    ctx.fillText("🌩️", bolt.x, bolt.y);
    ctx.restore();

    /* ⚡ 2. Vẽ đường sét ngoằn ngoèo (nếu đang tồn tại) */
    if (bolt.currentStrike) {
      const pts = bolt.currentStrike.path;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.strokeStyle = "rgba(255,255,0,0.9)";
      ctx.lineWidth = 2;
      ctx.shadowColor = "yellow";
      ctx.shadowBlur = 22;
      ctx.stroke();
      ctx.restore();
    }
  });
  ctx.restore();                   // ② khôi phục camera
}
function drawBlackHole() {
  // 📦 Lọc ra các máy bay sắp bị hút
  const blackHolePlanes = activePlanes.filter(p => p.x > worldWidth - 200);

  if (blackHolePlanes.length === 0) return; // ❌ Không có máy bay nào gần hố đen thì không vẽ

  // 📍 Xác định vị trí hố đen dựa trên máy bay gần nhất
  const blackHoleX = worldWidth - 100;

  // 🎯 Tính trung bình độ cao các máy bay đang tới gần
  const blackHoleY = blackHolePlanes.reduce((sum, p) => sum + p.y, 0) / blackHolePlanes.length;

  // 🔵 Hiệu ứng phồng nhẹ
  const pulse = Math.sin(Date.now() / 300);
  const radius = 40 + pulse * 5;

  // 🎨 Vẽ hố đen
  ctx.save();
  ctx.beginPath();
  ctx.arc(blackHoleX, blackHoleY, radius, 0, Math.PI * 2);
  ctx.fillStyle = "black";
  ctx.shadowColor = "purple";
  ctx.shadowBlur = 20;
  ctx.fill();
  ctx.restore();
}
if (petRabbit && petActive) {
  const { x, y, radius } = petRabbit;

  /* — thân — */
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fillStyle   = "#fff0fa";   // thân trắng-hồng
  ctx.fill();
  ctx.strokeStyle = "#ff7ad9";   // viền hồng nhạt
  ctx.lineWidth   = 2;
  ctx.stroke();

  /* — tai — */
  ctx.beginPath();
  ctx.ellipse(x - 6, y - 18, 3, 6, 0, 0, Math.PI * 2);
  ctx.ellipse(x + 6, y - 18, 3, 6, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  /* — mắt — */
  ctx.beginPath();
  ctx.arc(x - 4, y - 3, 1.5, 0, Math.PI * 2);
  ctx.arc(x + 4, y - 3, 1.5, 0, Math.PI * 2);
  ctx.fillStyle = "#000";
  ctx.fill();

  /* — miệng — */
  ctx.beginPath();
  ctx.arc(x, y + 4, 2, 0, Math.PI);
  ctx.strokeStyle = "#000";
  ctx.stroke();

  /* — tên “Thỏ” — */
  ctx.font         = "0.8rem sans-serif";
  ctx.fillStyle    = "#ff7ad9";   // cùng màu viền
  ctx.shadowColor  = "#ff7ad9";
  ctx.shadowBlur   = 8;
  ctx.textAlign    = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText("Thỏ", x, y - radius - 10);
  ctx.shadowBlur   = 0;
  ctx.shadowColor  = "transparent";
}
drawParticles(ctx);

drawBloodOrb(ctx);
drawBlackHole();
drawLightningBolts(); // 🌩️ Vẽ tia sét
ctx.restore(); // kết thúc dịch chuyển camera
drawMiniMap();
// 🎨 Vẽ bản đồ thu nhỏ
}

// 🎨 Vẽ tất cả hiệu ứng kỹ năng gọn lại
function drawEffects() {
  fireballs.forEach(f => {
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.shadowBlur = 8;
    ctx.shadowColor = "orange";
    ctx.fillStyle = "orange";
    ctx.font = "1.3rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("🔥", 0, 0);
    ctx.restore();
  });

  iceballs.forEach(f => {
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.shadowBlur = 10;
    ctx.shadowColor = "#00e5ff";
    ctx.fillStyle = "#00e5ff";
    ctx.font = "1.3rem serif";
// ctx.font = (f.radius * 0.9) + " serif"; Kỹ năng to ra khi lên level
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("❄️", 0, 0);
    ctx.restore();
  });

swords.forEach(s => {
    ctx.save();
    ctx.translate(s.x, s.y);
    if (s.state === 'charging') {
  ctx.shadowBlur = 2; // Hiệu ứng bóng mờ
  ctx.shadowColor = '#00ffff';
  ctx.fillStyle = '#00ffff';
} else {
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'white';
}
    ctx.font = "1.2rem serif";
//ctx.font = (s.radius * 0.9) + " serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("🔪", 0, 0);
    ctx.restore();
  });

downwardSwords.forEach(s => {
  ctx.save();
  ctx.translate(s.x, s.y);
  ctx.shadowBlur = 10;
  ctx.shadowColor = '#00ffff';
  ctx.fillStyle = 'white';
  ctx.font = "1.2rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("⚔️", 0, 0);
  ctx.restore();
});
// Vẽ tên lửa
missiles.forEach(m => {
  ctx.save();
  ctx.translate(m.x, m.y);
  ctx.shadowColor = m.state === "delay" ? "gray" : "orange";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "white";
  ctx.font = "1.5rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("🚀", 0, 0);
  ctx.restore();
});
missiles = missiles.filter(m => {
  if (m.state === "delay") {
    m.delay--;
    if (m.delay <= 0) {
      m.state = "fly";
    }
    return true;
  }

  // 🎯 Bay dẫn hướng tới zombie mục tiêu (bay mềm như tên lửa)
  if (m.target && m.target.active) {
    const desiredAngle = Math.atan2(m.target.y - m.y, m.target.x - m.x);
    const currentAngle = Math.atan2(m.dy, m.dx);

    // 🔁 Chuyển hướng dần
    const turnRate = 0.05; // 🎯 độ linh hoạt – tăng nếu muốn xoay nhanh
    let delta = desiredAngle - currentAngle;
    if (delta > Math.PI) delta -= 2 * Math.PI;
    if (delta < -Math.PI) delta += 2 * Math.PI;

    const newAngle = currentAngle + Math.sign(delta) * Math.min(turnRate, Math.abs(delta));
    const speed = 3.5; // 🚀 tốc độ tên lửa – giảm nếu muốn bay chậm hơn

    m.dx = Math.cos(newAngle) * speed;
    m.dy = Math.sin(newAngle) * speed;
  }

  m.x += m.dx;
  m.y += m.dy;
  m.life--;

  // 💥 Nổ diện rộng
if (m.life <= 0 || (m.target && distance(m, m.target) < 25 && m.target.active)) {
    zombies.forEach(z => {
if (z.active && distance(m, z) < 120) { // 80 là bán kính nổ
    dealDamageToZombie(z, m.damage);
}
});
    explosions.push(getExplosion(m.x, m.y));
    return false;
}

if (m.life <= 0) {
    explosions.push(getExplosion(m.x, m.y));
    return false;
}

  return true;
});
// 💣 B52 Bombs + 🛬 Máy bay
ctx.save();
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.font = "1.5rem serif";
ctx.shadowBlur = 8;
ctx.shadowColor = "black";

// 🛬 Vẽ máy bay đang hoạt động
activePlanes.forEach(plane => {
  ctx.fillStyle = "cyan";
ctx.save();
  ctx.shadowBlur = 2;
  ctx.shadowColor = "cyan";
ctx.translate(plane.x, plane.y);
ctx.scale(plane.scale ?? 1, plane.scale ?? 1);
ctx.globalAlpha = plane.opacity ?? 1;
ctx.fillText("🛬", 0, 0);
ctx.restore();
});

// 💣 Vẽ từng quả bom đang rơi hoặc sắp nổ
bombsB52.forEach(bomb => {
  if (bomb.exploded) return;
  ctx.fillStyle = bomb.landed ? "orange" : "white";
  ctx.fillText("💣", bomb.x, bomb.y);
});

ctx.restore();
// ☢️ Vẽ bom hạt nhân
nuclearBombs.forEach(bomb => {
// ----------- Vẽ bom hạt nhân khi chưa nổ -----------
if (!bomb.exploded) {
  let offsetX = 0, offsetY = 0;

  // 🔔 Nếu còn ≤ 3 giây và đã chạm đất → rung lắc
  if (bomb.landed && bomb.timerAfterLand <= 180) {
    offsetX = (Math.random() - 0.5) * 4;
    offsetY = (Math.random() - 0.5) * 4;
  }

  ctx.save();
  // Vẽ icon bom ☢️ to, sáng (có rung)
  ctx.font = "2.2rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.shadowBlur = 12;
  ctx.shadowColor = "orange";
  ctx.fillStyle = "white";
  ctx.fillText("☢️", bomb.x + offsetX, bomb.y + offsetY);

  // -- Nếu đã chạm đất, vẽ icon 💥 và giây countdown nằm ngang --
  if (bomb.landed) {
    const baseY = bomb.y - 35;
    const iconX = bomb.x - 1;
    const secX  = bomb.x + 1;

    // Vẽ icon 💥 nhỏ
    ctx.font = "1rem serif";
    ctx.shadowBlur = 2;
    ctx.textAlign = "right";
    ctx.fillStyle = "#ffb300";
    ctx.fillText("💥", iconX, baseY);

    // Vẽ số giây nhỏ, màu đỏ
    ctx.font = "1rem sans-serif";
    ctx.fillStyle = "#ff3333";
    ctx.textAlign = "left";
    let sec = Math.max(1, Math.ceil(bomb.timerAfterLand / 60));
    ctx.fillText(`${sec}`, secX, baseY - 2);
  }

  ctx.restore();
}

// ----------- Vẽ hiệu ứng sóng xung kích khi bom phát nổ -----------
if (bomb.exploded && bomb.shockwave) {
// Hiệu ứng vòng nổ chính – nét to, vàng đậm rõ ràng
  ctx.save();
  ctx.beginPath();
  ctx.arc(bomb.x, bomb.y, bomb.shockwaveRadius, 0, Math.PI * 2);
  ctx.strokeStyle = "rgba(255, 222, 44, 0.88)";   // Vàng tươi, gần như vàng nguyên chất
  ctx.lineWidth = 16;
  ctx.shadowBlur = 42;
  ctx.shadowColor = "#ffec70";
  ctx.globalAlpha = 0.58; // Đậm và rõ
  ctx.stroke();
  ctx.restore();

  // Viền ngoài phụ - vàng trắng, rõ hơn, tạo cảm giác “hào quang”
  ctx.save();
  ctx.beginPath();
  ctx.arc(bomb.x, bomb.y, bomb.shockwaveRadius + 8, 0, Math.PI * 2);
  ctx.strokeStyle = "rgba(255,255,180,0.73)";
  ctx.lineWidth = 7;
  ctx.shadowBlur = 28;
  ctx.shadowColor = "#fffbe2";
  ctx.globalAlpha = 0.45;
  ctx.stroke();
  ctx.restore();
}
});
blackHoles.forEach(h => {
  ctx.save();
  ctx.beginPath();
  ctx.arc(h.x, h.y, h.radius, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
  ctx.shadowColor = "purple";
  ctx.shadowBlur = 20;
  ctx.fill();
  ctx.closePath();

  // Icon giữa hố đen
  ctx.font = "2rem serif";
  ctx.fillStyle = "#fff";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("🕳️", h.x, h.y);
  ctx.restore();
});
}

//🔁 10. Vòng lặp chính và khởi tạo game
let fps = 0, lastFrameTime = performance.now(), frameCount = 0, lastFpsUpdate = performance.now(); // biến cập nhật FPS

function loop() {
  const now = performance.now();
  frameCount++;

// Cập nhật FPS mỗi 500ms
if (now - lastFpsUpdate >= 500) {
    fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
    const fpsText = `FPS: ${fps}`;
if (fpsText !== lastFpsText) {
  lastFpsText = fpsText;
  document.getElementById("fpsCounter").innerText = fpsText;
}
    frameCount = 0;
    lastFpsUpdate = now;
}

  update();
  draw();
  frame++;
  
if (frame % 30 === 0 && gameStarted) {
// Giới hạn zombie tối đa là 300 - Số lượng zombie hiện tại
if (zombies.length < 300) {
    const spawnCount = Math.min(1, 300 - zombies.length);
    for (let i = 0; i < spawnCount; i++) {
    spawnZombie();
}
}
}
updateDayNight();

requestAnimationFrame(loop);
}

// ▶️ Khởi chạy ban đầu
spawnZombie();
loop();

//🧼 11. Các đoạn khởi tạo UI sau canvas
// Hàm bắt đầu game
function startGame() {
  spawnBigBoss(); // chỉ để test

  randomizeBackground();
  // Hiển thị tổng điểm
  document.getElementById("highScoreDisplay").innerText = `🏆 Kỷ lục: ${localStorage.getItem('highScore') || 0}`;
  const nameInput = document.getElementById("playerNameInput");
  player.name = nameInput.value.trim() || "Player";
  document.getElementById("startMenu").style.display = "none";
  gameStarted = true;
  waveTimer = waveTime;
  showUpgradePopup();        // 🎁 Gọi nâng cấp trước
  pendingWave = wave;        // 🌊 Wave sẽ hiển thị sau khi nâng cấp xong
//Test
// 🚀 Tăng nhanh để test wave 20+
/* wave = 5;
  player.level = 1;
  player.score = 3000; // Đảm bảo đủ điểm để không bị tụt cấp */
//Test
}

// 🌊 Hiện popup "Wave X bắt đầu"
function showWavePopup() {
  const popup = document.getElementById("wavePopup");
  popup.innerText = `Wave ${wave} bắt đầu!`;
  popup.style.animation = "none";
  void popup.offsetWidth; // force reflow để reset animation
  popup.style.display = "block";
  popup.style.animation = "waveFade 1s ease-out forwards";
  setTimeout(() => {
    popup.style.display = "none";
  }, 2000); // ẩn sau 2 giây
}

// 🎯 Giá trị theo cấp độ kỹ năng (mỗi cấp tăng dần)
const UPGRADE_TIERS = {
  fireRate: [1, 2, 3],
  damageBoost: [0.5, 1, 1.5],
  hpBoost: [2, 3, 5],            
  bulletSpeed: [0.25, 0.5, 1]
};

// 🌟 Hiển thị popup chọn nâng cấp kỹ năng
function showUpgradePopup() {
  const popup = document.getElementById("upgradePopup");
  const container = document.getElementById("upgradeChoices");
  container.innerHTML = "";

// 📌 Bảng giá trị tương ứng với từng bậc nâng cấp
const UPGRADE_VALUES = {
  Bạc:  { fireRate: 1, damageBoost: 0.5, hpBoost: 2, bulletSpeed: 0.25 },
  Vàng: { fireRate: 2,  damageBoost: 1,   hpBoost: 3, bulletSpeed: 0.5 },
  Kim:  { fireRate: 3,    damageBoost: 1.5, hpBoost: 5, bulletSpeed: 1 },
  Rare: { moveSpeed: 0.2 } // 👟 tốc độ chạy – bậc hiếm
};
// 🎖 Màu viền tương ứng từng bậc
const TIER_COLORS = {
  Bạc: "#aaa",
  Vàng: "gold",
  Kim: "#c770ff",
  Rare: "#3399ff" // 💚 màu xanh bậc hiếm
};
// Giới hạn nâng cấp kỹ năng
const MAX_FIRE_RATE = 21; // 🔫 hướng bắn
const MAX_LINE_BULLETS = 10; // 🔫 số lượng đạn
const MAX_MOVE_SPEED = 3; // 👟 tốc độ di chuyển tối đa
const MAX_BULLET_SPEED = 10; // 🚀 tốc độ đạn tối đa

const allUpgrades = [];

// 🔪 Đao – tăng số lượng (tối đa 20), sau đó tăng sát thương
if (skillUpgrades.bladeCount < 20) {
  const tier = randomTier();
  const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];
  allUpgrades.push({
  name: `🔪 +${value} đao xoay quanh`,
  tier,
  effect: () => {
skillUpgrades.bladeCount = Math.min(skillUpgrades.bladeCount + value, 20);
  showWarning(`🔪 +${value} đao`);
  updateStatsOverlay();
}
});
} else {
  const tier = randomTier();
  const value = { Bạc: 0.5, Vàng: 1, Kim: 1.5 }[tier];
allUpgrades.push({
  name: `🔪 +${value} sát thương đao`,
  tier,
  effect: () => {
skillUpgrades.bladeDamage += value;
  showWarning(`🔪 +${value} dmg`);
  updateStatsOverlay();
}
});
}

// ⚔️ Kiếm – tăng cấp (tối đa 10), sau đó tăng sát thương
if (skillUpgrades.swordLevel < 10) {
  const tier = randomTier();
  const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];
  allUpgrades.push({
    name: `⚔️ +${value} cấp mưa kiếm`,
    tier,
    effect: () => {
skillUpgrades.swordLevel = Math.min(skillUpgrades.swordLevel + value, 10);
      showWarning(`⚔️ +${value} cấp kiếm`);
      updateStatsOverlay();
}
});
} else {
  const tier = randomTier();
  const value = { Bạc: 0.5, Vàng: 1, Kim: 1.5 }[tier];
  allUpgrades.push({
    name: `⚔️ +${value} sát thương kiếm`,
    tier,
    effect: () => {
    skillUpgrades.swordDamage += value;
    showWarning(`⚔️ +${value} dmg`);
    updateStatsOverlay();
}
});
}

// 🔥 Lửa – tăng số lượng (tối đa 10), sau đó tăng sát thương
if (skillUpgrades.fireCount < 10) {
  const tier = randomTier();
  const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];
  allUpgrades.push({
    name: `🔥 +${value} cầu lửa`,
    tier,
    effect: () => {
    skillUpgrades.fireCount = Math.min(skillUpgrades.fireCount + value, 10);
    showWarning(`🔥 +${value} lửa`);
    updateStatsOverlay();
}
});
} else {
  const tier = randomTier();
  const value = { Bạc: 0.5, Vàng: 1, Kim: 1.5 }[tier];
  allUpgrades.push({
    name: `🔥 +${value} sát thương lửa`,
    tier,
    effect: () => {
    skillUpgrades.fireDamage += value;
    showWarning(`🔥 +${value} dmg`);
    updateStatsOverlay();
}
});
}

// ❄️ Băng – tăng số lượng (tối đa 10), sau đó tăng sát thương
if (skillUpgrades.iceCount < 10) {
  const tier = randomTier();
  const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];
  allUpgrades.push({
    name: `❄️ +${value} cầu băng`,
    tier,
    effect: () => {
    skillUpgrades.iceCount = Math.min(skillUpgrades.iceCount + value, 10);
    showWarning(`❄️ +${value} băng`);
    updateStatsOverlay();
}
});
} else {
  const tier = randomTier();
  const value = { Bạc: 0.5, Vàng: 1, Kim: 1.5 }[tier];
  allUpgrades.push({
    name: `❄️ +${value} sát thương băng`,
    tier,
    effect: () => {
    skillUpgrades.iceDamage += value;
    showWarning(`❄️ +${value} dmg`);
    updateStatsOverlay();
}
});
}

// 🔫 Hướng bắn – nếu chưa max
if (playerUpgrades.fireRate < MAX_FIRE_RATE) {
  const tier = randomTier();
  const value = UPGRADE_VALUES[tier].fireRate;
  allUpgrades.push({
    name: "🔫 Hướng bắn",
    key: "fireRate",
    tier,
    value,
effect: () => {
  const added = Math.min(playerUpgrades.fireRate + value, MAX_FIRE_RATE) - playerUpgrades.fireRate;
  playerUpgrades.fireRate += added;
  showWarning(`🔫 +${added} hướng bắn`);
  updateStatsOverlay();
}
});
}

// 💥 Sát thương – luôn có thể nâng
{
  const tier = randomTier();
  const value = UPGRADE_VALUES[tier].damageBoost;
  allUpgrades.push({
    name: "💥 Sát thương",
    key: "damageBoost",
    tier,
    value,
effect: () => {
  playerUpgrades.damageBoost += value;
  showWarning(`💥 +${value} sát thương`);
  updateStatsOverlay();
}
});
}

// ❤️ Máu – luôn có thể nâng
{
  const tier = randomTier();
  const value = UPGRADE_VALUES[tier].hpBoost;
  allUpgrades.push({
    name: "❤️ Tăng máu",
    key: "hpBoost",
    tier,
    value,
    effect: () => {
      player.hearts += value;
      playerUpgrades.hpBoost += 1;
      showWarning(`❤️ +${value}`);
      updateUI();
      updateStatsOverlay();
    }
  });
}

// 💨 Tốc độ đạn tối đa 10
if (playerUpgrades.bulletSpeed < MAX_BULLET_SPEED) {
  const tier = randomTier();
  const value = UPGRADE_VALUES[tier].bulletSpeed;
  allUpgrades.push({
    name: "💨 Tốc độ đạn",
    key: "bulletSpeed",
    tier,
    value,
    effect: () => {
      const added = Math.min(playerUpgrades.bulletSpeed + value, MAX_BULLET_SPEED) - playerUpgrades.bulletSpeed;
      playerUpgrades.bulletSpeed += added;
      showWarning(`💨 +${added.toFixed(1)} tốc độ đạn`);
      updateStatsOverlay();
    }
  });
}

// 🧨 Số lượng đạn – nếu chưa max
if (playerUpgrades.lineBulletCount < MAX_LINE_BULLETS) {
  const tier = randomTier();
  const value = 1;
  allUpgrades.push({
    name: "🧨 số lượng đạn",
    key: "lineBulletCount",
    tier,
    value,
    effect: () => {
      playerUpgrades.lineBulletCount += value;
      showWarning(`🧨 +${value} viên mỗi hàng`);
      updateStatsOverlay();
    }
  });
}

// 👟 Tốc độ chạy – hiếm và chỉ 1 cấp (nếu chưa max)
if (player.speed < MAX_MOVE_SPEED) {
  const value = UPGRADE_VALUES.Rare.moveSpeed;
  allUpgrades.push({
    name: "👟 Tốc độ chạy",
    key: "moveSpeed",
    tier: "Rare",
    value,
    effect: () => {
      player.speed = Math.min(player.speed + value, MAX_MOVE_SPEED);
      showWarning(`👟 +${value.toFixed(1)} tốc độ`);
      updateStatsOverlay();
    }
  });
}


// 🎲 Xáo trộn và chọn ngẫu nhiên 3 nâng cấp
const choices = allUpgrades.sort(() => Math.random() - 0.5).slice(0, 3);
// 🖱️ Tạo nút cho từng nâng cấp
choices.forEach(up => {
const btn = document.createElement("button");
    btn.innerText = up.name;
    btn.style.borderColor = TIER_COLORS[up.tier]; // viền theo bậc
 btn.onclick = () => {
  up.effect(); // thực thi nâng cấp
  popup.style.display = "none";
  isPaused = false;
  lastWaveTime = Date.now(); // ⏱️ bắt đầu đếm thời gian

// ⏳ Chờ 500ms mới hiển thị wave
if (pendingWave !== null) {
    setTimeout(() => {
      showWavePopup();
      pendingWave = null;
    }, 500);
}
};
    container.appendChild(btn);
});

  popup.style.display = "block"; // hiển thị popup
  isPaused = true; // ⏸️ Tạm dừng game
  popup.style.display = "block";
}

// 🎲 Chọn bậc nâng cấp ngẫu nhiên theo tỷ lệ
function randomTier() {
  const tiers = ["Bạc", "Vàng", "Kim"];
  const weights = [0.7, 0.25, 0.05]; // tỷ lệ gặp: 60% Bạc, 30% Vàng, 10% Kim
  const r = Math.random();
  let sum = 0;
  for (let i = 0; i < tiers.length; i++) {
    sum += weights[i];
    if (r < sum) return tiers[i];
  }
  return "Bạc"; // fallback nếu có lỗi
}

// 🌟 Hiển thị popup chọn kỹ năng khi tăng level
/* ========= CẤU HÌNH ========= */
const MAX_LV = {                         // giới hạn số-lượng
  ufo        : 3,                        // UFO tấn công
  missile    : 5,                        // tên lửa F18
  lightning  : 5,                        // tia sét diện rộng
  satellite  : 2,                        // vệ tinh laze
  blackhole  : 2,                        // Hố đen
  bloodorb   : 2
};

/* tên ngắn → regex nhận diện chuỗi nâng cấp */
const UP_RX = {
  ufo       : /\+1 UFO/i,
  missile   : /\+1 tên lửa/i,
  lightning : /\+1 tia sét/i,
  satellite : /\+1 vệ tinh/i,
  blackhole : /\+1 hố đen/i,
  bloodorb  : /\+1 quả cầu/i
};

/* ========= TRỢ GIÚP ========= */
const rand    = arr => arr[Math.random() * arr.length | 0];          // pickRandom
const shuffle = a => a.sort(() => Math.random() - .5);               // Fisher–Yates 1-liner

/* kiểm tra 1 nâng cấp có “hết đát” chưa */
function isOverLimit(upgrade){
  const key = Object.keys(UP_RX).find(k => UP_RX[k].test(upgrade.name));
  if (!key) return false;                                            // gói sát thương, v.v.
  const active = activeSkills.find(s => s.name === upgrade.skillName);
  return active && (active.level || 0) >= MAX_LV[key];
}

/* ========= POPUP ========= */
function showSkillLevelUpPopup(){
  isPaused = true;                                                   // ⏸️

  const popup     = document.getElementById('skillPopup');
  const container = document.getElementById('skillChoices');
  container.innerHTML = '';

  /* 1️⃣ kỹ năng chưa học & nâng cấp hợp lệ */
  const unlearned = skillsData.filter(sk => !activeSkills.includes(sk));
  const upgrades  = activeSkills
      .flatMap(sk => (sk.upgrades || []).map(up => ({ ...up, skillName: sk.name })))
      .filter(up => !isOverLimit(up));                               // bỏ gói max

  /* 2️⃣ ghép pool & chọn 3 lựa chọn */
  let choices;
  if (unlearned.length){                                             // luôn có ≥1 skill mới
    const pickNew = rand(unlearned);
    const pool    = [...unlearned.filter(s => s!==pickNew), ...upgrades];
    choices = [pickNew, ...shuffle(pool).slice(0, 2)];
  } else {                                                           // đã học hết
    const unique = {};                                               // mỗi skill 1 upgrade ngẫu nhiên
    upgrades.forEach(up => (unique[up.skillName] ||= []).push(up));
    choices = shuffle(Object.values(unique).map(rand)).slice(0, 3);
  }

  /* 3️⃣ render nút */
  choices.forEach(ch => {
    const btn = document.createElement('button');
    if (ch.icon){                                                    // kỹ năng mới
      btn.textContent = `${ch.icon} ${ch.name}`;
      btn.onclick = () => {
        learnSkill(skillsData.indexOf(ch));
        popup.style.display = 'none';
        isPaused = false;                                            // ▶️
      };
    } else {                                                         // nâng cấp
      btn.textContent = ch.name;
      btn.style.borderColor =
        {Bạc:'#aaa',Vàng:'gold',Kim:'#c770ff',Đỏ:'red'}[ch.tier] || '#ccc';
      btn.onclick = () => {
        ch.effect?.();              // thực thi
        showWarning(` ${ch.name}`);
        popup.style.display = 'none';
        isPaused = false;            // ▶️
      };
    }
    container.appendChild(btn);
  });

  popup.style.display = 'block';
}

// 🧾 Cập nhật thông tin thống kê trong overlay
function updateStatsOverlay() {
  /* 👇 1. Tính lại tổng mỗi lần vẽ */
  const alive  = zombies.length;      // đang còn trên bản đồ
  const killed = zombieKillCount;     // đã tiêu diệt
  const total  = alive + killed;      // tổng thực
document.getElementById("stat-damage").innerText =
  `💥 Sát thương: ${(playerUpgrades.damageBoost || 1).toFixed(1)}`;
  document.getElementById("stat-spawned").innerText = `🧟 Tổng số zombie: ${total}`;
  document.getElementById("stat-alive").innerText   = `🧟 Đang còn sống: ${alive}`;
  document.getElementById("stat-total").innerText   = `🧟 Đã tiêu diệt: ${killed}`;
  document.getElementById("stat-speed").innerText = `💨 Tốc độ: ${playerUpgrades.bulletSpeed.toFixed(1)}`;
  document.getElementById("stat-fireRate").innerText = `🔫 Hướng bắn: ${playerUpgrades.fireRate}`;
  document.getElementById("stat-lineCount").innerText = `🧨 Số lượng đạn: ${playerUpgrades.lineBulletCount}`;
  document.getElementById("stat-moveSpeed").innerText = `👟 Tốc độ chạy: ${player.speed.toFixed(1)}`;
  // 🔪 Thống kê kỹ năng mặc định
document.getElementById("stat-blade").innerText = `🔪 Đao: ${skillUpgrades.bladeCount} đao, ${skillUpgrades.bladeDamage.toFixed(1)} dmg`;
document.getElementById("stat-sword").innerText = `⚔️ Kiếm: Lv${skillUpgrades.swordLevel}, ${skillUpgrades.swordDamage.toFixed(1)} dmg`;
document.getElementById("stat-fire").innerText = `🔥 Lửa: ${skillUpgrades.fireCount} lửa, ${skillUpgrades.fireDamage.toFixed(1)} dmg`;
document.getElementById("stat-ice").innerText = `❄️ Băng: ${skillUpgrades.iceCount} băng, ${skillUpgrades.iceDamage.toFixed(1)} dmg`;
// Kỹ năng khác
const skillText = Object.entries(skillStats)
    .map(([key, value]) => `${key}: ${value}`)
    .join("<br>");
    document.getElementById("stat-skills").innerHTML = skillText;

// 🧟 Zombie theo cấp: chỉ hiển thị từ Cấp 1 → 10
  let breakdown = "";
  for (let i = 1; i <= 10; i++) {
    breakdown += `<div>🧟 Cấp ${i}: ${zombieByLevel[i] || 0}</div>`;
  }

// 💀 Thống kê Mini Boss & Boss ở cuối
  const miniBossLine = `<div>💀 Mini Boss: ${zombieByLevel.miniBoss || 0}</div>`;
  const bossLine = `<div>💀 Boss: ${zombieByLevel.boss || 0}</div>`;
  const bigBossLine = `<div>💀 BigBoss: ${zombieByLevel.bigBoss || 0}</div>`;
  document.getElementById("stat-breakdown").innerHTML =
  breakdown + miniBossLine + bossLine + bigBossLine;
}
const activeSkills = [];

// Kỹ năng mẫu
const skillsData = [
  {
    name: "Khiên bảo vệ",
    icon: "🛡️",
    manaCost: 10,
    duration: 60000,
    description: "Tạo một vòng bảo vệ xung quanh người chơi trong 30 giây."
  },
  {
    name: "Vệ tinh laze",
    icon: "🛰️",
    manaCost: 15,
    duration: 30000,
    baseDamage: 5,
    description: "Triệu hồi vệ tinh xoay quanh người chơi và bắn laze xuyên zombie."
  },
{
  name: "Tên lửa F18",
  icon: "🚀",
  manaCost: 15,
  duration: 30000,
  baseDamage: 6,
  description: "Gọi 2 tên lửa bay vòng tròn quanh người chơi và xuyên phá zombie.",
  upgrades: []
},
{
  name: "UFO tấn công",
  icon: "🛸",
  manaCost: 15,
  duration: 30000,
  baseDamage: 5,
  description: "Gọi UFO bay ngang màn hình, bắn laze đỏ xuống zombie mỗi giây.",
  upgrades: []
},
{
  name: "Sét đánh diện rộng",
  icon: "🌩️",
  manaCost: 20,
  duration: 33000,
  baseDamage: 8,
  description: "Gọi sét ngẫu nhiên đánh quanh bản đồ.",
  upgrades: []
},
{
  name: "Bom B52",
  icon: "💣",
  manaCost: 25,
  duration: 52000,
  baseDamage: 10,
  description: "Mỗi giây rơi 1 bom, phát nổ sau 1-3 giây hoặc khi chạm zombie."
},
  {
    name: "Ảo ảnh phân thân",
    icon: "🎭",
    manaCost: 30,
    duration: 45000,
    baseDamage: 5,
    description: "Triệu hồi 2 bản sao hỗ trợ bắn."
  },
  {
    name: "Hố đen",
    icon: "🕳️",
    manaCost: 30,
    duration: 30000,
    baseDamage: 7,
    description: "Tạo một hố đen hút zombie xung quanh."
  },
  {
    name: "Biến hình",
    icon: "🐸",
    manaCost: 5,
    duration: 6000,
    description: "Giả dạng thành ếch, zombie sẽ bỏ đi không tấn công trong 5s."
  },
  {
    name: "Boom hạt nhân",
    icon: "☢️",
    manaCost: 100,
    duration: 20000,
    baseDamage: 100,
    description: "Bom hạt nhân phát nổ toàn bản đồ, sát thương cực lớn."
  },
{
    name: "Quả cầu hấp huyết",
    icon: "🩸",
    manaCost: 45,
    duration: 25000,
    baseDamage: 2,
    description: "Triệu hồi quả cầu đỏ bay quanh người chơi.\nMỗi giây hút máu zombie gần nhất, gây sát thương và hồi 1 HP.",
    upgrades: []
},
  {
    name: "Kỹ năng B",
    icon: "🅱️",
    manaCost: 0,
    duration: 0,
    description: "Kỹ năng thử nghiệm B"
  },
];
/* đặt sau khai báo skillsData */
const skillTooltipMap = Object.fromEntries(
  skillsData.map(sk => [
    sk.name,
    `${sk.icon} ${sk.name}\n─ Mana ${sk.manaCost}💠, ${sk.duration/1000}s\n${sk.description}`
  ])
);

// 🧪 Thêm nâng cấp cho từng kỹ năng có baseDamage
skillsData.forEach(skill => {
  if (skill.baseDamage !== undefined) {
      skill.upgrades = [
{
        name: `${skill.icon} +1 sát thương`,
        tier: "Bạc",
        effect: () => { skill.baseDamage += 1; 
        updateSkillsList(); 
}
},
{
      name: `${skill.icon} +2 sát thương`,
      tier: "Vàng",
      effect: () => { skill.baseDamage += 2;
      updateSkillsList();
}
},
{
        name: `${skill.icon} +3 sát thương`,
        tier: "Kim",
        effect: () => { skill.baseDamage += 3;
        updateSkillsList();
}
}
];

    if (skill.name === "Sét đánh diện rộng") {
    skill.upgrades.push({
    name: "🌩️ +1 tia sét (tối đa 5)",
    tier: "Đỏ",
    effect: () => {
  const skill = activeSkills.find(s => s.name === "Sét đánh diện rộng");
  if (skill) {
    skill.level = (skill.level || 0) + 1;
    showWarning("🌩️ +1 tia sét!");
    updateSkillsList();
}
}
});
}
if (skill.name === "Hố đen") {
  skill.upgrades.push({
    name: "🕳️ +1 hố đen (tối đa 2)",
    tier: "Đỏ",
    effect: () => {
      const skill = activeSkills.find(s => s.name === "Hố đen");
      if (skill) {
        skill.level = Math.min((skill.level || 0) + 1, 2); // +1 tới tối đa 2 hố đen
        showWarning("🕳️ +1 hố đen!");
        updateSkillsList();
      }
    }
  });
}

if (skill.name === "Vệ tinh laze") {
  skill.upgrades.push({
    name: "🛰️ +1 vệ tinh (tối đa 2)",
    tier: "Đỏ",
    effect: () => {
      const skill = activeSkills.find(s => s.name === "Vệ tinh laze");
      if (skill) {
        skill.level = Math.min((skill.level || 0) + 1, 2); // +1 tới tối đa 2 vệ tinh
        showWarning("🛰️ +1 vệ tinh!");
        updateSkillsList();
}
}
});
}

if (skill.name === "UFO tấn công") {
  skill.upgrades.push({
    name: "🛸 +1 UFO (tối đa 3)",
    tier: "Đỏ",
effect: () => {
  const skill = activeSkills.find(s => s.name === "UFO tấn công");
  if (skill) {
    skill.level = (skill.level || 0) + 1;
    showWarning("🛸 +1 UFO!");
    updateSkillsList();
}
}
});
}

// 🎯 Nếu là kỹ năng Tên lửa thì thêm nâng cấp số lượng
    if (skill.name === "Tên lửa F18") {
      skill.upgrades.push({
        name: `${skill.icon} +1 tên lửa (tối đa 5)`,
        tier: "Đỏ",
effect: () => {
  const skill = activeSkills.find(s => s.name === "Tên lửa F18");
  if (skill) {
    skill.level = (skill.level || 0) + 1;
    showWarning("🚀 +1 tên lửa!");
    updateSkillsList();
}
}
});
}
if (skill.name === "Quả cầu hấp huyết") {
    skill.upgrades.push({
        name: "🩸 +1 quả cầu (tối đa 2)",
        tier: "Đỏ",
        effect: () => {
            const skill = activeSkills.find(s => s.name === "Quả cầu hấp huyết");
            if (skill) {
                skill.level = Math.min((skill.level || 0) + 1, 2);
                showWarning("🩸 +1 Quả cầu!");
                updateSkillsList();
            }
        }
    });
}
}
});
// 🔍 Ghép mô tả chi tiết cho mỗi skill
function buildSkillTooltip(skill) {
  const secs = (skill.duration ?? 0) / 1000;
  const rows = [
    `${skill.icon} ${skill.name}`,
    `Mana: ${skill.manaCost}💠  •  Thời gian: ${secs ? secs + " s" : "tức thì"}`,
  ];

  // --- Sát thương hiện tại (nếu có) ---
  if (skill.baseDamage !== undefined)
    rows.push(`Sát thương: ${skill.baseDamage}`);

  // --- Level hiện tại của các nâng cấp đỏ ---
  if (skill.level !== undefined)
    rows.push(`Cấp hiện tại: ${skill.level}`);

  // --- Danh sách nâng cấp khả dụng ---
  /*if (skill.upgrades?.length) {
    rows.push("Nâng cấp:");
    skill.upgrades.forEach(u => rows.push(`• ${u.name}  [${u.tier}]`));
  }*/

  // --- Mô tả gốc --- "", chèn trước mô tả nếu có
  if (skill.description) rows.push(`Mô tả: ${skill.description}`);

  return rows.join("\n");
}
// 🧪 Hàm học kỹ năng mới
function updateSkillsList() {
  const list = document.getElementById('skills-list');
  list.innerHTML = '';
  activeSkills.forEach(skill => {
    const div = document.createElement('div');
    div.className = 'skill-item';
    // gán tooltip 💡
    div.dataset.tooltip = buildSkillTooltip(skill);
   // div.dataset.tooltip = skillTooltipMap[skill.name] || skill.description || '';
    // Hiển thị mana & disable nếu không đủ
    const canUse = player.mana >= skill.manaCost;
    div.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${skill.manaCost}💠`;

    if (!canUse) {
      div.style.opacity = 0.5;
      div.style.pointerEvents = 'none';
}

    div.onclick = () => {
      activateSkill(skill); // Gọi hàm đã định nghĩa
};

    list.appendChild(div);
});
/* sau khi render skills list: */
document.querySelectorAll('.skill-item[data-tooltip]').forEach(it=>{
  it.addEventListener('mouseenter',()=>{
    /* ---------- 1. ƯỚC LƯỢNG CAO TOOLTIP ---------- */
    const ln    = (it.dataset.tooltip.match(/\n/g)?.length || 0) + 1; // số dòng
    const hTip  = ln * 18 + 12;      // 14 px/line + padding (≈)

    /* ---------- 2. TÍNH DỊCH LÊN/XUỐNG ---------- */
    const r     = it.getBoundingClientRect();
    const gap   = 8;
    const overTop    = Math.max(gap - r.top, 0);                       // thiếu phía trên
    const overBottom = Math.max((r.top + hTip) - (innerHeight - gap), 0);
    const shiftValue = overTop - overBottom;                           // + xuống | – lên

    it.style.setProperty('--tip-shift', `${shiftValue}px`);
  });

  it.addEventListener('mouseleave',()=>{
    it.style.removeProperty('--tip-shift');
  });
});
}
// 🧪 Test: Thêm kỹ năng bất kỳ bằng phím số 1–9, 0
document.addEventListener("keydown", (e) => {
  const keys = "1234567890-=";
  const index = keys.indexOf(e.key);
  if (index >= 0 && skillsData[index] && !activeSkills.includes(skillsData[index])) {
  activeSkills.push(skillsData[index]);
  showWarning(`🧪 Đã thêm kỹ năng: ${skillsData[index].name}`);
  updateSkillsList();
}
});

function activateSkill(skill) {
  if (!skill || player.mana < skill.manaCost) return;
  player.mana -= skill.manaCost;
  switch (skill.name) {
    case "Khiên bảo vệ": activateShield(skill); break;
    case "Vệ tinh laze":
      satelliteActive = true;
      satelliteEndTime = Date.now() + skill.duration;
      // Số lượng vệ tinh = 1 + (skill.level || 0), tối đa 2
      const satCount = Math.min(skill.level, 2);// nếu không có level thì mặc định là 1
      // Vị trí vệ tinh: 1 bên phải, 1 bên trái player
      satellites = [];
      if (satCount === 1) {
      satellites.push({ x: player.x + 30, y: player.y - 30 });
  } else {
    satellites.push({ x: player.x + 30, y: player.y - 30 });  // phải
    satellites.push({ x: player.x - 30, y: player.y - 30 });  // trái
  }
    break;
    case "Tên lửa F18": activateTwinMissiles(skill); break;
    case "UFO tấn công": activateUFO(skill); break;
    case "Sét đánh diện rộng": activateLightning(skill); break;
    case "Bom B52": activateBombs(skill); break;
    case "Ảo ảnh phân thân": activateClones(skill); break;
    case "Hố đen": activateBlackHole(skill); break;
    case "Biến hình": activateDisguise(skill); break;
    case "Boom hạt nhân": activateNuclearBomb(skill); break;
    case 'Quả cầu hấp huyết':activateBloodOrb(skill); break;
  }
// Làm sáng nút kỹ năng tương ứng và đếm ngược
const list = document.getElementById('skills-list').children;
for (let i = 0; i < list.length; i++) {
  const item = list[i];
  if (item.textContent.includes(skill.name)) {
    item.classList.add("active");
    const endTime = Date.now() + skill.duration;
    const interval = setInterval(() => {
      const remain = Math.ceil((endTime - Date.now()) / 1000);
      if (remain > 0) {
        item.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${remain}s`;
} else {
        item.classList.remove("active");
        item.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${skill.manaCost}💠`;
        clearInterval(interval);
}
}, 1000);
break;
}
}
// Hiển thị thông báo kỹ năng đã kích hoạt
  showWarning(`${skill.icon} ${skill.name}!`);
}
// 🧟‍♂️ Kỹ năng: Tạo các kỹ năng đặc biệt cho người chơi
// 🛡️ Khiên bảo vệ: Tạo lớp chắn chặn sát thương và hiển thị hiệu ứng
function activateShield(skill) {
  player.shieldActive = true;
  player.shieldEndTime = Date.now() + skill.duration;

  setTimeout(() => {
    player.shieldActive = false;
}, skill.duration);
}

// 🚀 Tên lửa F18: 2 tên lửa bay quanh người chơi, xuyên và gây sát thương zombie
function activateTwinMissiles(skill) {
  const createMissilePair = () => {
  const targets = zombies.filter(z => z.active);
if (targets.length === 0) return;
  const missileCount = Math.min(0 + (skill.level || 1), 5); // Tối đa 5 tên lửa
for (let i = 0; i < missileCount; i++) {
      const angleOffset = Math.random() * Math.PI * 2;
      const radius = 40;
      const x = player.x + Math.cos(angleOffset) * radius;
      const y = player.y + Math.sin(angleOffset) * radius;
      const target = targets[Math.floor(Math.random() * targets.length)];

      missiles.push({
        x, y,
        dx: 0,
        dy: 0,
        target,
        damage: skill.baseDamage,
        delay: 120,       // ⏱ chờ 2 giây
        life: 360,        // sống thêm 3s sau khi bay - thời gian sống tên lửa
        state: "delay"
});
}
};

// 🟢 Tạo NGAY lập tức
  createMissilePair();

// ⏱ Sau đó tiếp tục tạo mỗi 2s
  const interval = setInterval(createMissilePair, 2000);
  setTimeout(() => clearInterval(interval), skill.duration);
}

// UFO tấn công
function activateUFO(skill) {
  ufoActive = true;
  ufoEndTime = Date.now() + skill.duration;
  ufoCooldown = 0;

  const maxCount = Math.min(0 + (skill.level || 0), 3);
  ufoCount = maxCount;

  const damage = skill.baseDamage;

ufos = Array.from({ length: maxCount }, (_, i) => ({
    x: canvas.width + 100 + i * 150, // bắt đầu ngoài rìa phải
    y: 300,                  // cố định vùng phía trên - y càng càng thì càng thấp
    speed: -0.5, // Tốc độ bay của UFO, giảm để chậm
    damage,
    laserCooldown: 0,
    laserLife: 0,
    angle: 0
  }));

  setTimeout(() => {
    ufoActive = false;
    ufos = [];
  }, skill.duration);
}
// === Helper: vẽ đường sét ngoằn ngoèo =========================
function getZigZag(start, target, segments = 8, jitter = 20) {
  const pts = [start];                         // điểm đầu là đám mây
  for (let i = 1; i < segments; i++) {
    const t = i / segments;                    // nội suy tuyến tính
    pts.push({
      x: start.x + (target.x - start.x) * t + (Math.random() - 0.5) * jitter,
      y: start.y + (target.y - start.y) * t + (Math.random() - 0.5) * jitter
    });
  }
    pts.push({
      x: target.x + (Math.random() - 0.5) * jitter,
      y: target.y + (Math.random() - 0.5) * jitter
});
  return pts;                                  // mảng [{x,y}, …]
}

// 🌩️ Sét đánh diện rộng: Gọi sét ngẫu nhiên gây sát thương diện rộng
function activateLightning(skill) { // Kích hoạt kỹ năng sét
  lightningActive   = true;
  lightningStartTime = Date.now();
  lightningEndTime   = lightningStartTime + skill.duration;

  const boltCount = Math.min(skill.level, MAX_LV.lightning); // ≤5
  lightningBolts  = [];                         // reset
  const spread    = 80;                         // rộng 2*80 = 160px

  for (let i = 0; i < boltCount; i++) {
    const offsetX = (i - (boltCount - 1) / 2) * spread; // -80,0,80,…
    lightningBolts.push({
      offsetX,
      x: 0, y: 0,            // sẽ được tính mỗi frame
      damage: skill.baseDamage,
      lastShot: 0,
      phase: Math.random() * Math.PI * 2,     // bob cloud
      currentStrike: null                     // sẽ chứa path & life
    });
  }
  setTimeout(() => { lightningActive = false; lightningBolts = []; }, skill.duration);
}
// Kích hoạt kỹ năng Bom B52 - tái sử dụng hàm activateBombs
function spawnPlanes(skill, amount = 3) {
  const planeYBase = player.y - 180; // Vị trí máy bay bắt đầu

  for (let i = 0; i < amount; i++) {
    const plane = {
      x: -100,
      y: planeYBase - i * 20,
      targetY: planeYBase - i * 20,
      vx: 1.5 + i * 0.5,
      lastDropTime: Date.now(),
      nextDropDelay: 5000 + i * 500 + Math.random() * 300,

      // 👇 Hiệu ứng biến mất
      scale: 1,
      opacity: 1,
      disappearing: false
    };

    activePlanes.push(plane);

    // ✅ Cập nhật tốc độ ngang mỗi 1–5 giây
    function schedulePlaneSpeedAdjust() {
      const delay = Math.random() * (5000 - 1000) + 1000;
      plane._speedTimeout = setTimeout(() => {
        plane.vx = Math.random() * (5 - 0.5) + 0.5;
        schedulePlaneSpeedAdjust(); // Gọi lại để lặp
      }, delay);
    }

    // ✅ Cập nhật độ cao dao động mỗi 1–5 giây
    function schedulePlaneHeightAdjust() {
      const delay = Math.random() * (5000 - 1000) + 1000;
      plane._heightTimeout = setTimeout(() => {
        plane.targetY += (Math.random() - 0.5) * 40; // dao động ±20
        schedulePlaneHeightAdjust(); // Lặp tiếp
      }, delay);
    }

    // 🔄 Kích hoạt 2 chu kỳ điều chỉnh
    schedulePlaneSpeedAdjust();
    schedulePlaneHeightAdjust();

    // 🎮 Cập nhật chuyển động và thả bom định kỳ
    const planeInterval = setInterval(() => {
      const now = Date.now();

      // ➡ Di chuyển theo tốc độ hiện tại
      plane.x += plane.vx;

      // 📈 Bay mượt đến targetY
      plane.y += (plane.targetY - plane.y) * 0.05;

      // 💣 Thả bom nếu đến thời điểm
      if (now - plane.lastDropTime > plane.nextDropDelay) {
        plane.lastDropTime = now;
        plane.nextDropDelay = 1000 + Math.random() * 2000; // từ 1–3s

        const targetY = plane.y + 100 + Math.random() * (canvas.height * 0.9); // 90%
        bombsB52.push({
          x: plane.x,
          y: plane.y,
          vy: 3,
          exploded: false,
          landed: false,
          finalY: targetY,
          timerAfterLand: 180,
          radius: 15,
          damage: skill.baseDamage
        });
      }

      // 🌀 Khi gần rìa map thì bắt đầu biến mất
      if (!plane.disappearing && plane.x > worldWidth - 180) {
        plane.disappearing = true;
      }

      // 🧼 Hiệu ứng thu nhỏ và xoá máy bay
      if (plane.disappearing) {
        plane.scale *= 0.95;
        plane.opacity -= 0.05;

        if (plane.scale < 0.1 || plane.opacity <= 0) {
          clearInterval(planeInterval);
          clearTimeout(plane._speedTimeout);
          clearTimeout(plane._heightTimeout);
          activePlanes.splice(activePlanes.indexOf(plane), 1);
        }
      }
    }, 50);
  }
}
const planeWaves = [
  { delay: 0, amount: 1 },      // tạo 3 máy bay ngay lập tức
  { delay: 3000, amount: 1 },  // tạo 5 máy bay sau 30s
  { delay: 6000, amount: 1 },
  { delay: 9000, amount: 1 },  // tạo 2 máy bay sau 60s
];
// 💣 Bom B52: rơi xuống, nổ khi trúng zombie, nếu không trúng thì nổ sau 5s khi chạm đất
function activateBombs(skill) {
  const skillEndTime = Date.now() + skill.duration;

  planeWaves.forEach(wave => {
    setTimeout(() => {
      spawnPlanes(skill, wave.amount);
    }, wave.delay);
  });
  // 💣 Update bom rơi như cũ
  const updateInterval = setInterval(() => {
    for (let i = bombsB52.length - 1; i >= 0; i--) {
      const bomb = bombsB52[i];
      if (bomb.exploded) continue;

      if (!bomb.landed) {
        bomb.y += bomb.vy;
        for (let z of zombies) {
          if (z.active && distance(bomb, z) < bomb.radius + z.radius) {
            explodeB52Bomb(bomb);
            bombsB52.splice(i, 1);
            break;
          }
        }
        if (bomb.y >= bomb.finalY) {
          bomb.y = bomb.finalY;
          bomb.landed = true;
        }
      } else {
        bomb.timerAfterLand--;
        if (bomb.timerAfterLand <= 0) {
          explodeB52Bomb(bomb);
          bombsB52.splice(i, 1);
        }
      }
    }

    if (Date.now() > skillEndTime && bombsB52.length === 0) {
      clearInterval(updateInterval);
    }
  }, 1000 / 60);

  function explodeB52Bomb(bomb) {
    bomb.exploded = true;
    explosions.push(getExplosion(bomb.x, bomb.y));
    zombies.forEach(z => {
      if (z.active && distance(bomb, z) < 240) {
        dealDamageToZombie(z, bomb.damage);
      }
    });
  }
}
// 🎭 Ảo ảnh phân thân: Tạo 2 bản sao bắn đạn hỗ trợ
function activateClones(skill) {
  clonesActive = true;
  clonesEndTime = Date.now() + skill.duration;
  clones = [];

  const moveAngle = Math.random() * Math.PI * 2; // hướng di chuyển chung

  for (let i = 0; i < 2; i++) {
    const offset = (i === 0 ? -40 : 40); // clone trái và phải cách nhau 80px
    clones.push({
      x: player.x + Math.cos(moveAngle + Math.PI / 2) * offset,
      y: player.y + Math.sin(moveAngle + Math.PI / 2) * offset,
      moveAngle: moveAngle,
      moveSpeed: 1.2,                     // Tốc độ di chuyển clone
      baseDamage: skill.baseDamage || 5, // Sát thương riêng
      lastShot: 0
    });
  }
}
// 🕳️ Hố đen: Hút zombie vào tâm và gây sát thương liên tục
function activateBlackHole(skill) {
  const holeCount = Math.min(skill.level, 2); // Tối đa 2 hố đen
  const radius = 150; // bán kính hố đen
  const holePositions = [];

  // 🌀 Tạo hố đầu tiên gần player (trong bán kính 120px)
  const angle = Math.random() * Math.PI * 2;
  const distance = 60 + Math.random() * 60; // cách player từ 60–120px
  const x1 = Math.max(radius, Math.min(canvas.width - radius, player.x + Math.cos(angle) * distance));
  const y1 = Math.max(radius, Math.min(canvas.height - radius, player.y + Math.sin(angle) * distance));
  holePositions.push({ x: x1, y: y1 });

  // 💫 Nếu có hố thứ 2 → tạo xa hố đầu tiên (tối thiểu 250px)
  if (holeCount >= 2) {
    const minDistance = 250;
    const maxAttempts = 50;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      const x2 = radius + Math.random() * (canvas.width - radius * 2);
      const y2 = radius + Math.random() * (canvas.height - radius * 2);
      const dx = x2 - x1;
      const dy = y2 - y1;
      const dist = Math.hypot(dx, dy);
      if (dist >= minDistance) {
        holePositions.push({ x: x2, y: y2 });
        break;
      }
    }
  }

  // 🌪️ Thêm vào game
holePositions.forEach(pos => {
  blackHoles.push({
    x: pos.x,                      // Vị trí X ban đầu
    y: pos.y,                      // Vị trí Y ban đầu
    radius: radius,               // Bán kính ảnh hưởng
    damage: skill.baseDamage,     // Sát thương
    duration: skill.duration,     // Thời gian tồn tại
    pullSpeed: 3.5,               // Lực hút mỗi frame
    tick: 0,                      // Đếm frame
    dustTimer: 0, 
    endTime: Date.now() + skill.duration, // Thời điểm kết thúc

    // ➕ Thêm hướng di chuyển cực chậm
    dx: (Math.random() - 0.5) * 0.1,  // tốc độ X cực nhỏ
    dy: (Math.random() - 0.5) * 0.1   // tốc độ Y cực nhỏ
  });
});
}

// 🐸 Biến hình: Zombie tạm thời không phát hiện người chơi (ẩn thân)
function activateDisguise(skill) {
  disguiseActive = true;
  disguiseEndTime = Date.now() + skill.duration;

  // Cập nhật trạng thái cho zombie
  zombies.forEach(z => {
    if (!z.isBoss) {
      z.state = "wandering";
      z.wanderTime = Date.now() + 6000 + Math.random() * 4000;// Thời gian đi lang thang ngẫu nhiên từ 3s đến 7s
      z.wanderAngle = Math.random() * Math.PI * 2;

      // 💬 Biểu cảm ngẫu nhiên nếu không phải boss
      if (Math.random() < 0.6) {
        const expressions = ["😕", "🤢", "😴", "😳", "🤮"];
        z.iconToDraw = expressions[Math.floor(Math.random() * expressions.length)];
        setTimeout(() => { z.iconToDraw = null; }, 5000); // Biểu cảm biến mất sau 5s
      }
    }
  });
  setTimeout(() => {
    disguiseActive = false;
  }, skill.duration);
}
// Màu cho bom hạt nhân khi phát nổ
const colors = [
    "rgba(255,255,255,0.7)", // trắng
    "rgba(255,0,0,0.7)",     // đỏ
    "rgba(0,255,0,0.7)",     // xanh lá
    "rgba(0,200,255,0.7)",   // cyan
    "rgba(255,200,0,0.7)",   // vàng
    "rgba(255,0,255,0.7)"    // tím
];
// ☢️ Bom Hạt Nhân: Rơi xuống giữa màn hình, đếm ngược 5s rồi tạo vòng nổ lan rộng
function activateNuclearBomb(skill) {
    if (nuclearBombs.length >= 1) return;
    nuclearBombs.push({
        x: player.x,
        y: 100,
        vy: 3.5,
        exploded: false,
        landed: false,
        timerAfterLand: 5 * 60,
        damage: skill.baseDamage * 10,
        radius: 22,
        finalY: player.y,
        shockwave: false,
        shockwaveRadius: 0,
        shockwaveSpeed: 2
    });
    const updateInterval = setInterval(() => {
        if (nuclearBombs.length === 0) {
            clearInterval(updateInterval);
            return;
        }

        const bomb = nuclearBombs[0];
        if (bomb.exploded && !bomb.shockwave) return;
        // 💨 Khi bom chạm đất – tạo hạt bụi bay vào tâm bom
        if (bomb.landed && !bomb.exploded) {
        for (let i = 0; i < 2; i++) {
        createSuctionDust(bomb.x, bomb.y, 0.6); // Tốc độ tan nhanh chậm
        }
        }
        // Bom rơi xuống
        if (!bomb.landed) {
            bomb.y += bomb.vy;
            if (bomb.y >= bomb.finalY) {
                bomb.landed = true;
                bomb.y = bomb.finalY;
            }
        }
        // Đếm ngược nổ
        else if (!bomb.exploded) {
            bomb.timerAfterLand--;
            if (bomb.timerAfterLand <= 0) {
                explodeNuclearBomb(bomb);
            }
        }

        // Sóng xung kích sau khi nổ
        if (bomb.exploded && bomb.shockwave) {
            bomb.shockwaveRadius += bomb.shockwaveSpeed;
            zombies.forEach(z => {
                if (z.active && distance(bomb, z) < bomb.shockwaveRadius) {
                    dealDamageToZombie(z, bomb.damage);
                }
            });
            enemyBullets.forEach(b => {
                if (!b.active) return;
                if (distance(bomb, b) < bomb.shockwaveRadius) {
                    releaseEnemyBullet(b);
                    explosions.push(getExplosion(b.x, b.y));
                }
            });
            if (bomb.shockwaveRadius > Math.max(canvas.width, canvas.height) * 1.4) {
                nuclearBombs.shift();
                bomb.shockwave = false;
            }
        }
    }, 1000 / 60);
    // Hàm phát nổ
    function explodeNuclearBomb(bomb) {
        bomb.exploded = true;
        bomb.shockwave = true;
        bomb.shockwaveRadius = 0;
        explosions.push(getExplosion(bomb.x, bomb.y)); // 💥 hiệu ứng nổ nhỏ trung tâm
        // 🌊 Thêm 2 vòng nổ phụ mỗi 2 giây
        setTimeout(() => {
            extraShockwaves.push({
                x: bomb.x,
                y: bomb.y,
                radius: 0,
                maxRadius: 300,
                color: "red",
                alpha: 1
            });
        }, 2000);
        setTimeout(() => {
            extraShockwaves.push({
                x: bomb.x,
                y: bomb.y,
                radius: 0,
                maxRadius: 400,
                color: "cyan",
                alpha: 1
            });
        }, 4000);
        // 💨 Hạt bụi bay ra khi bom phát nổ
        for (let i = 0; i < 60; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 4 + 1;
    const color = colors[Math.floor(Math.random() * colors.length)]; // màu ngẫu nhiên
    particles.push({
        x: bomb.x,
        y: bomb.y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: Math.random() * 3 + 1,
        color: color,
        alpha: 1
    });
}
}
}
// 🩸 Quả cầu hấp huyết
function activateBloodOrb(skill) {
    bloodOrbActive = true;
    bloodOrbEndTime = Date.now() + skill.duration;
    player.mana -= skill.manaCost;

    // Xác định số lượng quả cầu theo level (tối đa 2)
    const maxCount = Math.min(1 + (skill.level || 0), 2);
    bloodOrbCount = maxCount;

    bloodOrbs = Array.from({ length: maxCount }, (_, i) => ({
        angle: (2 * Math.PI / maxCount) * i,
        radius: 60,
        x: player.x,
        y: player.y
    }));
}
// 📌 Bật/tắt bảng kỹ năng bằng phím X
document.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'x') {
    document.getElementById('skillsOverlay').classList.toggle('hidden');
    updateSkillsList();
  }
});

// Thêm kỹ năng mới (gọi hàm này khi lên cấp)
function learnSkill(index) {
  const skill = skillsData[index];
if (!activeSkills.includes(skill)) {
  activeSkills.push(skill);
  /* SỬA khối gán level */
    skill.level = 1;              // ← luôn bắt đầu ở cấp 1
if (skill.baseDamage !== undefined && skill.level === undefined) {
  skill.level = 0;
}
  updateSkillsList();
  showWarning(`🎉 Học kỹ năng: ${skill.icon} ${skill.name}`, { left: "40%", transform: "translate(-50%, -50%)" });
}
}

// 🎯 Phím Z để bật/tắt bảng thống kê
document.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "z") {
    const panel = document.getElementById("statsOverlay");
    panel.classList.toggle("hidden");
}
});

// 🎯 Gán phím ` để bật/tắt FPS
document.addEventListener("keydown", (e) => {
  if (e.key === "`") {
    const fpsDiv = document.getElementById("fpsCounter");
    fpsDiv.style.display = fpsDiv.style.display === "none" ? "block" : "none";
}
});
function showGuide() {
  document.getElementById("guideOverlay").style.display = "block";
}
function hideGuide() {
  document.getElementById("guideOverlay").style.display = "none";
}
function showInfo() {
  document.getElementById("infoOverlay").style.display = "block";
}
function hideInfo() {
  document.getElementById("infoOverlay").style.display = "none";
}

</script>
<!-- 🌟 Popup khi lên cấp -->
<div id="levelUpPopup">Level Up!</div>
<!-- 🌟 Popup chọn nâng cấp -->
<div id="upgradePopup">
  <h3 class="upgradeTitle">⏫ Chọn nâng cấp</h3>
  <div id="upgradeChoices" class="upgradeChoices"></div>
</div>

<!-- 📊 Overlay hiển thị thống số kỹ năng -->
<div id="statsOverlay" class="hidden">
  <h3>📊 Thống kê</h3>
  <div id="highScoreDisplay" style="text-align: center; font-weight: 300; margin: 2px 0; position: relative; top: -6px;">
  🏆 Kỷ lục: 0
  </div>
  <div id="stat-moveSpeed">👟 Tốc độ chạy: - </div>
  <div id="stat-moveSpeed1">👟 test 1: - </div>
  <div id="stat-damage">💥 Sát thương: - </div>
  <div id="stat-fireRate">🔫 Hướng bắn: - </div>
  <div id="stat-speed">💨 Tốc độ: - </div>
  <div id="stat-lineCount">🧨 Số lượng đạn: - </div>
  <div id="stat-blade">🔪 Đao: -</div>
  <div id="stat-sword">⚔️ Kiếm: -</div>
  <div id="stat-fire">🔥 Lửa: -</div>
  <div id="stat-ice">❄️ Băng: -</div>
  <div id="stat-skills"></div> <!-- kỹ năng khác -->
  <div id="stat-spawned">🧟 Tổng số zombie: 0</div>
  <div id="stat-alive">🧟 Đang còn sống: 0</div>
  <div id="stat-total">🧟 Đã tiêu diệt: 0</div>
  <div id="stat-breakdown">
    <!-- sẽ được cập nhật bằng JS -->
  </div>
</div>
<!-- 📚 Bảng Kỹ Năng Active mở bằng phím X -->
<div id="skillsOverlay" class="hidden">
<h3>📚 Kỹ năng Active</h3>
<div id="ui-mana" style="text-align: center; font-weight: 300; margin: 2px 0; position: relative; top: -2px;">💠 Mana: 0</div>
<div id="skills-list"></div>
</div>

<!-- 🎯 Hiển thị FPS realtime -->
<div id="fpsCounter" style="
  display: none;
  position: fixed;
  top: 0.2rem;
  left: 0.3rem;
  color: lime;
  background: rgba(0, 0, 0, 0);
  padding: 0.4rem 0.8rem;
  border-radius: 0.5rem;
  font-family: monospace;
  font-size: 0.9rem;
  z-index: 9999;
  pointer-events: none;
">
FPS: --
</div>
<!-- 🎓 Popup kỹ năng khi lên cấp -->
<div id="skillPopup">
  <h3>🎓 Chọn kỹ năng hoặc nâng cấp</h3>
  <div class="upgradeChoices" id="skillChoices"></div>
</div>
<div id="notificationContainer" aria-live="polite"></div>

</body>
</html>
