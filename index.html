<!--🎮 Zombie Survivor  ✨ Version: 1.2  🖋️ Tác giả: Dang -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Zombie Survivor - Dang</title>
<style>
  :root {
  /* 🎨 Màu sắc chính */
  --color-bg-dark: #111;
  --color-primary: #00ffff;
  --color-accent: gold;
  --color-danger: #ff4c4c;
  --color-text: #e0f7fa;
  --color-hover-bg: #22404c;
  --color-hover-border: #3d6c78;
  --color-title: #aefeff;
  --glow-title: 0 0 6px #7f7fff, 0 0 12px #4d4dfb;
 
  /* 🌈 Màu sắc giao diện */
  --menu-width: 24rem;
  --menu-min-height: 20rem;
  --menu-radius: 1rem;
  --menu-padding: 2rem 1.5rem;

  /* 🔘 Màu button riêng */
  --btn-bg: #1a2b33;
  --btn-border: #294e5a;

  /* 🔤 Kích thước font chữ */
  --font-xs: 0.75rem;
  --font-sm: 0.9rem;
  --font-md: 1rem;
  --font-lg: 1.25rem;
  --font-xl: 1.5rem;
  --font-xxl: 2.5rem;

  /* 📏 Kích thước padding/margin chuẩn */
  --space-xs: 0.4rem;
  --space-sm: 0.6rem;
  --space-md: 1rem;
  --space-lg: 1.5rem;
  --space-xl: 2rem;

  /* 🌟 Độ sáng bóng / hiệu ứng */
  --glow-primary: 0 0 8px var(--color-primary);
  --glow-accent: 0 0 8px var(--color-accent);
}

  body { margin: 0; background: #111; overflow: hidden; font-family: sans-serif; }
  canvas { display: block; margin: auto; transition: background 1s ease; }
/* 🎯 Giao diện chính */
#ui {
  position: absolute;
  top: 0vh; /* cách top theo chiều cao màn hình */
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 0.2rem; /* khoảng cách giữa các nút */
  padding: 0.2rem 0.2rem; 
  background: rgb(0, 0, 0); /* nền trong suốt */
  border-radius: 0rem;
  width: 90%; /* tỷ lệ theo chiều ngang */
  max-width: 60rem; /* giới hạn tối đa */
  justify-content: center;
  z-index: 1000;
  flex-wrap: wrap;
  border-radius: 10px;
}
/* --- CSS đã được sửa lỗi cho Logo và thanh UI --- */

/* Style chung cho cả hai logo (giờ đây được định vị tuyệt đối) */
.ui-logo {
  position: fixed; /* Định vị cố định trên màn hình */
  top: 1.2rem;     /* Vị trí cách đỉnh */
  color: var(--color-title);
  font-family: 'Segoe UI', sans-serif;
  font-weight: bold;
  text-shadow: 0 0 4px var(--color-primary);
  z-index: 1001;   /* Luôn nổi lên trên thanh UI */
  pointer-events: none; /* Cho phép click xuyên qua logo */
}

/* Style riêng cho logo bên trái (Tên game) */
.left-logo {
  left: 18.1rem; /* Vị trí cách lề trái */
  line-height: 1;
  font-size: 0.8rem;
  text-align: center;
}

/* Style riêng cho logo bên phải (Tên tác giả) */
.right-logo {
  right: 18.1rem; /* Vị trí cách lề phải */
  line-height: 1;
  font-size: 0.8rem;
  text-align: center;
}
/* --- Kết thúc CSS cho Logo và thanh UI --- */
/* 🔘 Nút trong UI (nhỏ gọn hơn nút mặc định) */
#ui button {
  padding: 0.6rem 0.6rem;
  font-size: 0.75rem;
  min-width: 4.5rem;
  margin-bottom: 0.6rem;
  margin-top: 0.6rem;
}

/* 🔘 Nút mặc định cho toàn giao diện */
button {
  font-family: 'Segoe UI', sans-serif;
  padding: 0.65rem 1.25rem;
  font-size: 1rem;
  cursor: pointer;
  min-width: 5rem;
  text-align: center;
  background-color: #1a2b33;
  border: 0.125rem solid #294e5a;
  border-radius: 0.5rem;
  color: #e0f7fa;
  transition: all 0.2s ease;
  box-shadow: 0 0.125rem 0.3rem rgba(0, 0, 0, 0.2);
}

/* 🔁 Hiệu ứng hover cho nút */
button:hover {
  background-color: #22404c;
  border-color: #3d6c78;
  color: #ffffff;
  transform: translateY(-0.06rem);
}

/* 🖱 Hiệu ứng khi click giữ */
button:active {
  transform: scale(0.97);
  box-shadow: 0 0.06rem 0.2rem rgba(0, 0, 0, 0.3);
}

/* ✳️ Nút đang active (được chọn) */
button.active {
  border-color: #00ffff;
  box-shadow: 0 0 0.625rem #00ffffaa;
}

/* Trạng thái active dùng cho nhiều thành phần */
.active {
  outline: 0.125rem solid gold;
  border-radius: 0.5rem;
}

/* 📊 Vùng hiển thị điểm số hoặc thông tin */
#score {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-width: 7.5rem;
  text-align: center;
  color: white;
  font-size: 0.8rem;
  padding: 0.2rem 0.2rem;
}

/* 🔄 Nút restart đặc biệt */
#restartBtn {
  padding: 0.75rem 1.75rem;
  font-weight: bold;
  background-color: #1c2e36;
  border: 0.125rem solid #3a6b75;
  border-radius: 0.5rem;
  font-size: 1rem;
  color: #aefeff;
  cursor: pointer;
  transition: 0.25s ease;
}

/* 🖱 Hover cho restart */
#restartBtn:hover {
  background-color: #28515f;
  color: white;
  transform: translateY(-0.06rem);
}

/* ⏳ Hiển thị đồng hồ đếm wave */
#waveTimerDisplay {
  position: fixed;
  top: 10vh;
  left: 48.5%;
  transform: translateX(-50%);
  font-size: 1.2rem;
  color: gold;
  z-index: 10;
  text-shadow: 0 0 8px gold;
  font-weight: bold;
  font-family: 'Courier New', monospace;
  letter-spacing: 0.1rem;
  pointer-events: none;
}

/* 🌊 Popup khi bắt đầu Wave */
#wavePopup {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 2.5rem;
  font-weight: bold;
  color: #fff3b0;
  text-shadow:
    0 0 6px #ffd54f,
    0 0 12px #ffb300;
  background: none;
  border: none;
  pointer-events: none;
  z-index: 1000;
  transition: opacity 0.5s ease;
  opacity: 0;
}

/* ✨ Animation xuất hiện mềm mượt */
@keyframes waveFade {
  0% {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.7);
  }
  50% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1.05);
  }
  100% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
}

/* 📋 Menu bắt đầu game */
#startMenu {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  width: 90%;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  border-radius: var(--menu-radius);
  padding: var(--menu-padding);
  max-width: var(--menu-width);
  min-height: var(--menu-min-height);
  text-align: center;
  background: linear-gradient(to bottom, #0e1a26, #0a121a);
  backdrop-filter: blur(6px);
  border: 1px solid #446688;
  box-shadow:
    0 0 8px rgba(102, 170, 255, 0.1),
    inset 0 0 6px rgba(102, 170, 255, 0.05);
  z-index: 999;
}
#startMenu:hover {
  box-shadow:
    0 0 12px rgb(0, 153, 255),
    inset 0 0 8px rgba(0, 187, 255, 0.393);
}
#startMenu .btn-group {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 1rem;
}
#startMenu button {
  min-width: 10rem;
}

/* 🌟 Popup khi lên cấp */
#levelUpPopup {
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 2.5rem;
  color: gold;
  font-weight: bold;
  text-shadow: 0 0 15px #ffff00;
  display: none;
  z-index: 2000;
}

/* 💀 Panel Game Over hiển thị khi thua */
.gameOverPanel {
  position: fixed;
  top: 50%;
  left: 50%;
  /* Bắt đầu ẩn và nhỏ */
  transform: translate(-50%, -50%) scale(0.7);
  opacity: 0;
  visibility: hidden; /* Dùng visibility để ẩn hoàn toàn */

  color: white;
  display: flex; /* Giữ lại flex để căn giữa nội dung */
  flex-direction: column;
  align-items: center;
  backdrop-filter: blur(6px);
  z-index: 2000;
  padding: 2rem 1rem;
  border: 2px solid #ff5722;
  background: linear-gradient(145deg, #1a0f0f, #300d0d);
  box-shadow: 0 0 1rem #ff572288;
  border-radius: 1rem;
  text-align: center;
  
  /* Hiệu ứng chuyển động */
  transition: opacity 0.4s ease-out, transform 0.4s ease-out, visibility 0.4s;
}

/* Khi có class 'visible', panel sẽ hiện ra */
.gameOverPanel.visible {
  opacity: 1;
  visibility: visible;
  transform: translate(-50%, -50%) scale(1);
}

/* 🎯 Tiêu đề Game Over */
.gameOverTitle {
  color: #ff5722;
  font-size: 2.5rem;
  text-shadow: 0 0 4px #ffff00, 0 0 4px #ffff00;
  margin-bottom: 1rem;
}

/* 🔁 Nút Chơi lại trong Game Over Panel */
.restartButton {
  margin-top: 1rem;
  padding: 0.75rem 2rem;
  font-size: 1.2rem;
  font-weight: 300;
  background-color: #330000;
  color: #fff5cc;
  border: 2px solid #ff9800;
  border-radius: 0.75rem;
  cursor: pointer;
  box-shadow: 0 0 0.5rem #ff5722aa;
  transition: all 0.25s ease;
  text-shadow: 0 0 3px #ffaa00;
}

.restartButton:hover {
  background-color: #551100;
  color: #ffffff;
  transform: scale(1.05);
  box-shadow: 0 0 1rem #ff5722cc;
}

/* 🕹️ Tiêu đề game ở menu bắt đầu */
.gameTitle {
  font-size: 2.5rem;
  font-weight: 900;
  color: var(--color-title);
  text-shadow: var(--glow-title);
  margin-bottom: 1.5rem;
  font-family: 'Segoe UI', sans-serif;
}

/* ⚠️ Popup cảnh báo (dùng cho showWarning) */
.warningPopup{
  position:fixed;
  top:20%;                /* ① đặt tâm dọc  */
  left:50%;               /* ② đặt tâm ngang */
  transform:translate(-50%,-50%); /* ③ kéo ngược lại 50 % kích thước chính nó */
  background:rgba(0,32,64,.9);
  color:var(--color-text);
  padding:var(--space-sm) var(--space-lg);
  border-radius:.75rem;
  font:var(--font-md) 'Segoe UI',sans-serif;
  font-weight:500;
  z-index:9999;
  box-shadow:0 0 10px #00bcd4aa;
  pointer-events:none;
  animation:popupFade 1.5s ease-out forwards;
  max-width:70vw;         /* nếu text quá dài sẽ tự xuống hàng */
  text-align:center;
}

/*  Vì transform nay đã chứa translate(-50%,-50%),
    animation chỉ lắc trục Y thêm một chút  */
@keyframes popupFade{
  0%   {opacity:0; transform:translate(-50%,-30%);}
  10%  {opacity:1; transform:translate(-50%,-50%);}
  90%  {opacity:1; transform:translate(-50%,-50%);}
  100% {opacity:0; transform:translate(-50%,-70%);}
}
#notificationContainer{
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translate(-50%, -50%);   /* căn đúng tâm như popup cũ */
  display: flex;
  flex-direction: column;             /* xếp dọc */
  align-items: center;                /* mỗi popup vẫn giữa ngang */
  gap: .5rem;                         /* khoảng cách giữa các popup */
  pointer-events: none;
  z-index: 10000;
}

/* ✨ Popup bên trong khay – bỏ fixed & translate cũ */
#notificationContainer .warningPopup{
  position: relative;                 /* relative → theo khay */
  left: auto; top: 0;
  transform: none;                    /* khay đã lo căn giữa */
  animation: popupFadeStack 1.5s ease-out forwards;
}

/* Hiệu ứng gần giống cũ nhưng không chứa -50% nữa */
@keyframes popupFadeStack{
  0%   {opacity:0;   transform: translateY(20px);}
  10%  {opacity:1;   transform: translateY(0);}
  90%  {opacity:1;}
  100% {opacity:0;   transform: translateY(-20px);}
}

/* 🌟 Giao diện popup nâng cấp */
#upgradePopup {
  /* display: none; */ /* Bỏ display none để dùng opacity và visibility */
  opacity: 0;
  visibility: hidden;
  transform: translate(-50%, -50%) scale(0.9); /* Bắt đầu nhỏ hơn một chút */
  transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s; /* Hiệu ứng chuyển động */
  
  position: fixed;
  top: 50%;
  left: 50%;
  background: rgba(0, 0, 0, 0.85);
  border: 2px solid gold;
  padding: 2rem;
  border-radius: 1rem;
  z-index: 9999;
  max-width: 42rem;
  width: 90%;
  text-align: center;
  box-shadow: 0 0 15px gold;
}

/* Thêm class .visible để kích hoạt hiệu ứng */
#upgradePopup.visible {
    opacity: 1;
    visibility: visible;
    transform: translate(-50%, -50%) scale(1);
}
.upgradeTitle {
  color: gold;
  font-size: 1.8rem;
  font-weight: bold;
  margin-bottom: 1.5rem;
  text-shadow: 0 0 6px gold;
  margin-top: 1rem;
}

.upgradeChoices {
  display: flex;
  justify-content: space-evenly;
  gap: 1rem;
  flex-wrap: wrap;
}

.upgradeChoices button {
  padding: 0.8rem 1.2rem;
  border: 2px solid #ccc;
  border-radius: 0.6rem;
  background: #111;
  color: white;
  font-size: 1rem;
  font-weight: bold;
  min-width: 8rem;
  cursor: pointer;
  transition: 0.2s ease;
}

.upgradeChoices button:hover {
  background: #22404c;
  border-color: gold;
  color: #fff;
  box-shadow: 0 0 10px gold;
}

/* 📊 Overlay thống kê */
#statsOverlay {
  position: fixed;
  top: 0.2rem;
  right: 0.5rem;
  background: rgba(0, 0, 0, 0.7);
  border: 2px solid #00ffff;
  border-radius: 1rem;
  padding: 1rem;
  color: #e0f7fa;
  font-size: 0.95rem;
  line-height: 1.5;
  z-index: 9999;
  width: 15rem;
  font-family: 'Segoe UI', sans-serif;
}

#statsOverlay h3 {
  font-size: 1rem;
  margin-top: 0;
  margin-bottom: 0.5rem;
  color: gold;
  text-align: center;
}

#statsOverlay.hidden {
  display: none;
}
/* 📚 Giao diện bảng kỹ năng active */
#skillsOverlay {
  position: fixed;
  top: 0.2rem;
  left: 0.5rem;
  background: rgba(0, 0, 0, 0.7);
  border: 2px solid #00ffff;
  border-radius: 1rem;
  padding: 1rem;
  color: #e0f7fa;
  font-size: 0.95rem;
  line-height: 1.5;
  z-index: 9999;
  width: 15rem;
  font-family: 'Segoe UI', sans-serif;
}

#skillsOverlay h3 {
  font-size: 1rem;
  margin-top: 0;
  margin-bottom: 0.5rem;
  color: gold;
  text-align: center;
}

#skillsOverlay.hidden {
  display: none;
}

.skill-item {
  margin-bottom: 0.5rem;
  padding: 0.4rem;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 0.5rem;
  cursor: pointer;
  transition: background 0.3s;
}

.skill-item:hover {
  background: rgba(0, 255, 255, 0.3);
}

.skill-icon {
  font-size: 1.2rem;
  margin-right: 0.5rem;
}
#skillPopup {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 32, 64, 0.9);
  border: 2px solid #00ffff;
  padding: 2rem;
  border-radius: 1rem;
  z-index: 9999;
  max-width: 42rem;
  width: 90%;
  text-align: center;
  box-shadow: 0 0 15px #00ffffaa;
}

#skillPopup h3 {
  color: #00ffff;
  font-size: 1.6rem;
  font-weight: bold;
  margin-bottom: 1.2rem;
  text-shadow: 0 0 6px #00ffff;
}

#skillPopup .upgradeChoices {
  display: flex;
  justify-content: space-evenly;
  gap: 1rem;
  flex-wrap: wrap;
}

#skillPopup .upgradeChoices button {
  padding: 0.8rem 1rem;
  border: 2px solid #0d1aa0; /* màu kỹ năng active */
  border-radius: 0.6rem;
  background: #001f2f;
  color: white;
  font-size: 1rem;
  font-weight: bold;
  min-width: 9rem;
  cursor: pointer;
  transition: 0.2s ease;
}
#skillPopup .upgradeChoices button:hover {
  background: #003344;
  border-color: cyan;
  box-shadow: 0 0 10px cyan;
}

.skill-item.active {
  border: 2px solid #00ffff;
  background: rgba(0, 255, 255, 0.2);
  box-shadow: 0 0 8px cyan;
  pointer-events: none; /* không cho click vào kỹ năng đã chọn */
}
.infoOverlay {
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(10, 25, 40, 0.95); /* xanh đen dịu */
  border: 2px solid #446688;
  border-radius: var(--menu-radius);
  max-width: 24rem;
  min-height: 22rem;
  width: 90%;
  padding: var(--menu-padding);
  box-shadow: 0 0 10px rgba(50, 100, 150, 0.3);
  color: #eef;
  z-index: 9999;
  font-family: 'Segoe UI', sans-serif;
  font-size: 0.95rem;
  line-height: 1.6; /* khoảng cách dòng */
  text-align: center;
}
.spacer {
  height: 2rem;  /* hoặc 4rem tùy độ cao bạn muốn */
}
/* 🔧 Spacer cân bằng layout trong overlay hướng dẫn */
.spacerguide {
  height: 1rem; /* khoảng cách giữa các mục */
}

.infoOverlay button {
  min-width: 10rem;
}
.custom-input {
  font-family: 'Segoe UI', sans-serif;
  padding: 0.65rem 1.25rem;
  font-size: 0.9rem;
  min-width: 6.5rem;
  width: 100%;
  max-width: 7.2rem;
  text-align: center;
  background-color: #1a2b33;
  border: 0.125rem solid #294e5a;
  border-radius: 0.5rem;
  color: #e0f7fa;
  transition: all 0.2s ease;
  box-shadow: 0 0.125rem 0.3rem rgba(0, 0, 0, 0.2);
}

.custom-input:focus {
  outline: none;
  background-color: #22404c;
  border-color: #3d6c78;
  color: #ffffff;
  box-shadow: 0 0 0.625rem #00ffffaa;
}
#waveNumberDisplay {
  position: fixed;
  top: 14vh; /* giống waveTimerDisplay */
  left: 48.5%; /* lệch phải so với thời gian ở 50% */
  transform: translateX(-50%);
  font-size: 1.1rem;
  color: #aefeff;
  font-weight: bold;
  text-shadow: 0 0 6px #00ffff;
  z-index: 10;
  pointer-events: none;
}
#miniMap {
  position: fixed;
  top: 6.5rem;
  right: 18rem;
  width: 150px;
  height: 150px;
  border: 2px solid #00ffff;
  border-radius: 0.5rem;
  background: rgba(0, 0, 0, 0.4);
  z-index: 9999;
  display: none; /* ẩn mini map ban đầu */
}
/* Tooltip cho item trong bảng kỹ năng (phím X) */
.skill-item[data-tooltip] {
  position: relative;
}
.skill-item[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 105%;               /* hiện bên phải bảng */
  top: -2rem;
  transform: translateY(var(--tip-shift,0)); /* DỊCH theo biến */
  margin-left: .6rem;
  min-width: 18rem;
  white-space: pre-line;    /* xuống dòng theo \n */
  padding: .55rem .7rem;
  font-size: .8rem;
  background: rgba(0,0,0,.85);
  color: #e0f7fa;
  border: 1px solid #00ffff;
  border-radius: .5rem;
  pointer-events: none;
  opacity: 0;
  transition: opacity .25s;
  z-index: 10000;
}
.skill-item:hover::after { opacity: 1; }
#bigBossRespawnDisplay {
    position: fixed;
    top: 10vh;
    left: 29.1vw;
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid violet;
    border-radius: 0.5rem;
    padding: 0.4rem 0.6rem;
    color: violet;
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    text-align: center;
    min-width: 6rem;
    z-index: 10;
    text-shadow: 0 0 5px violet;
}
/* CSS cho bộ đếm ngày mới (có định vị) */
#dayCounterDisplay {
    position: fixed;
    top: 10vh; /* Cùng độ cao với BigBoss */
    left: 23.2vw; /* Đặt ở vị trí bên phải của BigBoss */
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid gold;
    border-radius: 0.5rem;
    padding: 0.4rem 0.6rem;
    color: gold;
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    text-align: center;
    min-width: 4rem;
    z-index: 10;
    text-shadow: 0 0 5px gold;
}
#ui button[data-tooltip] {
  position: relative;
}

#ui button[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 110%;
  top: 4rem;
  transform: translateX(-40%);
  margin-left: .6rem;
  min-width: 18rem;
  white-space: pre-line;
  padding: .55rem .7rem;
  font-size: .8rem;
  background: rgba(0, 0, 0, 0.85);
  color: #e0f7fa;
  border: 1px solid #00ffff;
  border-radius: .5rem;
  pointer-events: none;
  opacity: 0;
  transition: opacity .25s;
  text-align: left; /* chữ canh trái */
  z-index: 10000;
}

#ui button:hover::after {
  opacity: 1;
}

/* --- CSS cho Debug Menu (Phiên bản thanh kéo) --- */
#debugMenu {
  max-width: 24rem;
  width: 90%;
  padding-bottom: 1rem;
  
  /* BỔ SUNG: Giới hạn chiều cao và dùng Flexbox */
  display: flex;
  flex-direction: column;
  max-height: 90vh; /* Chiều cao tối đa bằng 85% chiều cao màn hình */
}

.debug-grid {
  display: grid;
  grid-template-columns: auto 1fr; 
  gap: 0.8rem 1rem;
  align-items: center;
  margin-bottom: 1rem;
  text-align: left;

  /* BỔ SUNG: Cho phép cuộn dọc khi nội dung dài hơn */
  overflow-y: auto;
  padding-right: 1rem; /* Thêm khoảng đệm nhỏ tránh nội dung sát viền */

  /* --- Các thuộc tính để ẩn thanh cuộn --- */
  /* Cho Firefox */
  scrollbar-width: none;
  /* Cho Internet Explorer và Edge cũ */
  -ms-overflow-style: none;
}

/* Cho các trình duyệt Webkit (Chrome, Safari, Edge mới) */
.debug-grid::-webkit-scrollbar {
    display: none;
}

/* Thêm định nghĩa để ẩn Debug Menu khi có class 'hidden' */
#debugMenu.hidden {
    display: none;
}
.debug-subtitle {
  grid-column: 1 / -1; /* Tiêu đề chiếm trọn chiều rộng của grid */
  text-align: center;
  color: gold;
  margin-top: 1rem;
  margin-bottom: 0.5rem;
  border-top: 1px solid #446688;
  padding-top: 1rem;
}
/* Chỉnh lại chiều rộng cho ô nhập số Kill */
#debug-kill.debug-input {
    width: 10em; /* Giới hạn chiều rộng (bạn có thể thay đổi số 12) */
    justify-self: start; /* Căn lề trái trong ô layout */
}

/* --- CSS cho khu vực debug kỹ năng active --- */
.debug-skill-grid {
  grid-column: 1 / -1; /* Chiếm trọn chiều rộng của grid cha */
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.debug-skill-wrapper {
  background: rgba(0,0,0,0.2);
  padding: 0.75rem;
  border-radius: 0.5rem;
  border: 1px solid #294e5a;
}

.debug-skill-wrapper h5 {
  margin: 0 0 0.75rem 0;
  color: white;
  font-weight: 600;
  font-size: 1.1rem;
}

.debug-skill-controls {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 0.8rem 1rem;
    align-items: center;
    font-size: 0.9rem;
}
/* CSS cho bộ đếm Xu (Coin) */
#coinCounterDisplay {
  position: fixed;
  top: 10vh; /* Cùng độ cao với Wave */
  left: 40.8%; /* Vị trí bên phải của Wave */
  border: 2px solid gold;
  border-radius: 0.5rem;
  padding: 0.3rem 0.6rem;
  transform: translateX(-50%);
  font-size: 0.8rem;
  color: gold; /* Màu vàng cho hợp với coin */
  font-weight: normal;
  text-shadow: 0 0 2px gold;
  z-index: 10;
  pointer-events: none;
}
/* Style chung cho hiển thị buff */
.buff-display {
  position: fixed;
  top: 10vh;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.6);
  border-radius: 0.5rem;
  padding: 0.4rem 0.4rem;
  font-family: 'Segoe UI', sans-serif;
  font-size: 0.8rem;
  font-weight: normal;
  color: white;
  border: 2px solid;
  z-index: 10;
  pointer-events: none;
}
.buff-display.inactive {
  opacity: 0.4; /* Làm mờ đi */
}
/* Vị trí riêng cho từng buff */
#luckyBuffDisplay { 
  left: 57%; /* Vị trí bên trái của Wave 68% */
  border-color: #22c55e; 
}
#powerBuffDisplay { 
  left: 64.2%; /* Vị trí bên trái của Lucky */
  border-color: #ef4444; 
}
#crazyBuffDisplay { 
  left: 71.3%; /* Vị trí bên trái của Power */
  border-color: #f59e0b; 
}
#expBuffDisplay { 
  left: 78%; /* Vị trí bên trái của Power */
  border-color: #ffeb3b; /* Màu vàng cho buff EXP */
}
#magnetBuffDisplay { 
  top: 15vh; /* Cùng độ cao với Wave */
  left: 57%; /* Vị trí bên phải của ExpUp */
  border-color: #8b5cf6; /* Màu tím */
}

@keyframes pulsing-glow-magnet {
  0% { box-shadow: 0 0 4px #8b5cf6, inset 0 0 4px #8b5cf6; }
  50% { box-shadow: 0 0 14px #a78bfa, inset 0 0 14px #a78bfa; }
  100% { box-shadow: 0 0 4px #8b5cf6, inset 0 0 4px #8b5cf6; }
}

#magnetBuffDisplay.active-glow {
    animation: pulsing-glow-magnet 2s infinite;
}

/* --- BẮT ĐẦU: CSS cho hiệu ứng viền sáng --- */

/* Định nghĩa animation cho buff Lucky (màu xanh lá) */
@keyframes pulsing-glow-lucky {
  0% { box-shadow: 0 0 4px #22c55e, inset 0 0 4px #22c55e; }
  50% { box-shadow: 0 0 14px #34d399, inset 0 0 14px #34d399; }
  100% { box-shadow: 0 0 4px #22c55e, inset 0 0 4px #22c55e; }
}

/* Định nghĩa animation cho buff Power (màu đỏ) */
@keyframes pulsing-glow-power {
  0% { box-shadow: 0 0 4px #ef4444, inset 0 0 4px #ef4444; }
  50% { box-shadow: 0 0 14px #f87171, inset 0 0 14px #f87171; }
  100% { box-shadow: 0 0 4px #ef4444, inset 0 0 4px #ef4444; }
}
/* Định nghĩa animation cho buff Crazy (màu vàng cam) */
@keyframes pulsing-glow-crazy {
  0% { box-shadow: 0 0 4px #f59e0b, inset 0 0 4px #f59e0b; }
  50% { box-shadow: 0 0 14px #fbbf24, inset 0 0 14px #fbbf24; }
  100% { box-shadow: 0 0 4px #f59e0b, inset 0 0 4px #f59e0b; }
}
@keyframes pulsing-glow-exp {
  0% { box-shadow: 0 0 4px #ffeb3b, inset 0 0 4px #ffeb3b; }
  50% { box-shadow: 0 0 14px #fff176, inset 0 0 14px #fff176; }
  100% { box-shadow: 0 0 4px #ffeb3b, inset 0 0 4px #ffeb3b; }
}

/* Áp dụng animation khi có class 'active-glow' */
#expBuffDisplay.active-glow {
    animation: pulsing-glow-exp 2s infinite;
}

/* Áp dụng animation khi có class 'active-glow' */
#crazyBuffDisplay.active-glow {
    animation: pulsing-glow-crazy 2s infinite;
}

/* Áp dụng animation khi có class 'active-glow' */
#luckyBuffDisplay.active-glow {
    /* Tên animation, thời gian 2 giây, lặp lại vô hạn */
    animation: pulsing-glow-lucky 2s infinite;
}

#powerBuffDisplay.active-glow {
    animation: pulsing-glow-power 2s infinite;
}

/* --- KẾT THÚC: CSS cho hiệu ứng viền sáng --- */

/* --- CSS cho Pause Menu (Gọn hơn) --- */
#pauseMenu {
  max-width: 24rem; /* Giảm chiều rộng tối đa */
  padding: 1.5rem; /* Giảm padding tổng thể */
  border-radius: 0.75rem; /* Bo tròn nhẹ hơn */
}

#pauseMenu h2 {
  font-size: 2rem; /* Giảm kích thước tiêu đề */
  margin-bottom: 1rem;
}

.settings-section {
  margin-bottom: 1rem; /* Giảm margin */
  padding-bottom: 1rem; /* Giảm padding */
  border-bottom: 1px solid #446688;
}

.settings-section h3 {
  font-size: 1.2rem; /* Giảm kích thước tiêu đề phụ */
  margin-bottom: 0.75rem;
}

.debug-grid label {
  font-size: 0.9rem; /* Giảm kích thước label */
}

.range-container input {
  width: 70%; /* Điều chỉnh chiều rộng thanh trượt */
}

.range-container .range-value {
  font-size: 0.9rem; /* Giảm kích thước giá trị */
}

.pause-menu-buttons {
  display: grid;
  grid-template-columns: 1fr; /* <-- Sửa thành 1fr để chỉ có 1 cột dọc */
  gap: 0.75rem;
  margin-top: 0.5rem;
  justify-items: center;
}

.pause-menu-buttons button {
  width: 14rem; /* Chiều rộng cố định, bạn có thể thay đổi số này */
  max-width: 90%; /* Đảm bảo không quá to trên màn hình hẹp */
  font-size: 0.9rem; /* Giảm kích thước chữ nút */
  padding: 0.6rem 1rem; /* Giảm padding nút */
}

#resumeBtn {
  grid-column: 1 / -1;
  padding: 0.75rem 1.2rem; /* Tăng padding nút Tiếp tục một chút */
}
#pauseMenu.hidden {
    display: none;
}
#guideOverlay, #infoOverlay {
    z-index: 10001;
}

/* --- CSS cho Cửa hàng (Shop) --- */
#shopOverlay {
  max-width: 40rem;
  min-height: auto;
}

#shopOverlay.hidden {
  display: none;
}

.shop-balance {
  font-size: 1.2rem;
  color: gold;
  margin-bottom: 1rem;
  text-shadow: 0 0 5px gold;
}

.shop-grid {
  display: grid;
  /* THAY ĐỔI: Giới hạn chiều rộng tối thiểu và tối đa của mỗi ô */
  grid-template-columns: repeat(auto-fill, minmax(8rem, 1fr)); 
  gap: 0.75rem;
  margin-bottom: 1.5rem;
  max-height: 50vh;
  overflow-y: auto;
  padding: 0.5rem;
}

/* Ẩn thanh cuộn cho shop grid */
.shop-grid::-webkit-scrollbar { display: none; }
.shop-grid { -ms-overflow-style: none; scrollbar-width: none; }

.shop-item {
  background: #1a2b33;
  border: 1px solid #294e5a;
  border-radius: 0.5rem;
  /* THAY ĐỔI: Giảm padding để thu nhỏ ô vật phẩm */
  padding: 0.5rem; 
  text-align: center;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  transition: all 0.2s ease;
}

.shop-item:hover {
    transform: translateY(-3px);
    border-color: var(--color-primary);
}

.shop-item .icon {
  font-size: 1.8rem;
}

.shop-item .name {
  font-weight: bold;
  margin: 0.4rem 0;
  font-size: 0.85rem;
  min-height: 2.2em;
}

.shop-item button {
  min-width: 8rem; /* Đảm bảo nút không quá nhỏ */
  padding: 0.5rem 1rem;
  /* THAY ĐỔI: Giảm padding để thu nhỏ nút bấm */
  margin: 0 auto; 
  font-size: 0.8rem;
  font-weight: bold;
  width: fit-content;
}
/* BỔ SUNG: CSS để hiển thị tooltip cho thanh EXP/HP */
#score-top[data-tooltip] {
  position: relative;
}
#score-top[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 50%;
  top: 110%; /* Hiển thị ngay bên dưới thanh trạng thái */
  transform: translateX(-50%);
  
  /* Các style khác cho tooltip */
  min-width: 10rem;
  white-space: pre-line;
  padding: .55rem .7rem;
  font-size: .8rem;
  background: rgba(0,0,0,.85);
  color: #e0f7fa;
  border: 1px solid #00ffff;
  border-radius: .5rem;
  pointer-events: none;
  opacity: 0;
  transition: opacity .25s;
  z-index: 10000;
}
#score-top:hover::after {
  opacity: 1;
}

/* kết thúc style */
</style>
</head>
<body>
<div class="ui-logo left-logo">Zombie<br>Survivor</div>
<div class="ui-logo right-logo">tdangw<br>Ver: 1.2</div>
<div id="ui">
  <button id="autoBtn" data-tooltip="⚙️ Auto:
- Tự động tấn công zombie gần nhất
- Có thể tắt bật kích hoạt mọi lúc
- Nâng cấp để tăng tốc độ tấn công
- Tăng cấp để tăng sát thương
- Yêu cầu level 1
- Sát thương: 1
- Tiêu hao: 0 ⚡">⚙️ Auto</button>

  <button id="bladeBtn" data-tooltip="🔪 Kỹ năng Đao:
- Tạo 2~20 thanh đao xoay quanh player
- Tối đa tạo được 20 đao
- Bay vào zombie gần nhất
- Yêu cầu level 1
- Sát thương: 1
- Hiệu lực: 60s ⏱
- Tiêu hao: 5 ⚡">🔪 Đao</button>

  <button id="swordBtn" data-tooltip="⚔️ Kỹ năng Kiếm:
- Tạo mưa kiếm rơi từng đợt
- Số lượng kiếm tăng theo level
- Bay vào zombie gần nhất
- Yêu cầu level 2
- Sát thương: 1
- Hiệu lực: 60s ⏱
- Tiêu hao: 6 ⚡">⚔️ Kiếm</button>

  <button id="fireBtn" data-tooltip="🔥 Kỹ năng Lửa:
- Tạo 2 quả cầu lửa quay quanh
- Tạo được tối đa 10 quả cầu lửa
- Tiêu diệt zombie chạm vào
- Yêu cầu level 3
- Sát thương: 1
- Hiệu lực: 60s ⏱
- Tiêu hao: 8 ⚡">🔥 Lửa</button>

  <button id="iceBtn" data-tooltip="❄️ Kỹ năng Băng:
- Tạo 2 quả cầu băng lớn xoay quanh
- Tạo được tối đa 10 quả cầu băng
- Gây sát thương diện rộng
- Yêu cầu level 3
- Sát thương: 1
- Hiệu lực: 60s ⏱
- Tiêu hao: 12 ⚡">❄️ Băng</button>

  <button id="thunderBtn" data-tooltip="🔵 Kỹ năng thunder:
- Tạo 2 quả cầu lôi xoay quanh
- Tạo được tối đa 6 quả cầu
- Gây sát thương và làm choáng
- Yêu cầu level 5
- Sát thương: 1
- Hiệu lực: 60s ⏱
- Tiêu hao: 18 ⚡">🔵 Lôi</button>

<button id="supportAuraBtn" data-tooltip="✨ Kỹ năng hào quang:
- Tạo một vùng phép thuật dưới chân.
- Tăng 20% tốc độ chạy và tốc độ bắn.
- Giảm 50% sát thương từ mọi nguồn.
- Hồi 1 HP mỗi giây.
- Yêu cầu level 6
- Hiệu lực: 60s ⏱
- Tiêu hao: 15 ⚡">✨ Heal</button>

<button id="fairyBtn" data-tooltip="🦋 Kỹ năng Fairy:
- Triệu hồi Fairy hỗ trợ.
- Hồi máu mỗi 3s. Giúp hồi sinh player.
- Tăng sát thương player.
- Giảm sát thương zombie.
- Yêu cầu level 7
- Hiệu lực: 60s ⏱
- Tiêu hao: 25 ⚡">🦋 Fairy</button>

  <button id="PetBtn" data-tooltip="🐰 Kỹ năng Pet:
- Triệu hồi 1 rabbit cute đi theo player
- Hỗ trợ: nhặt vật phẩm
- Hỗ trợ: tăng sát thương
- Bắn carrot làm choáng zombie.
- Hỗ trợ: Hồi 1 HP mỗi 3s
- Hiệu lực: 60s ⏱
- Tiêu hao: 5 ⚡">🐰 Pet</button>

  <div id="score">
    <div id="score-top" data-tooltip="Exp cấp tiếp theo: 300">Exp: 0000 |❤️: 0010</div>
    <div id="score-bottom">Level: 0001 |⚡: 0000</div>
  </div>
</div>
<canvas id="game" width="960" height="720"></canvas>

<!-- 📋 Menu bắt đầu game -->
<div id="startMenu">
  <h2 class="gameTitle">Zombie Survivor</h2>
<input type="text" id="playerNameInput" placeholder="Nhập tên của bạn" class="custom-input" />
  <button onclick="startGame()">🎮 Bắt đầu</button>
  <button onclick="showGuide()">📘 Hướng dẫn</button>
  <button onclick="showInfo()">ℹ️ Thông tin</button>
</div>
<div id="guideOverlay" class="infoOverlay" style="display: none;">
<h3 style="margin-top: 0; color: #66aaff;">📘 Hướng dẫn chơi</h3>
  <ul style="text-align: left;">
    <li>Tiêu diệt zombie để lên cấp</li>
    <li>Mỗi wave, level sẽ được nâng cấp kỹ năng</li>
    <li>Trùm cuối siêu khó nên tránh xa khi còn yếu</li>
    <li>Nhặt vật phẩm để tăng máu, mana, năng lượng</li>
    <li>Nhấn phím Space để sử dụng kỹ năng đặc biệt</li>
    <li>Bấm X: mở danh sách kỹ năng</li>
    <li>Bấm Z: mở bảng thống kê</li>
    <li>Bấm M: mở bảng bản đồ</li>
    <li>Bấm O: mở Shop. ESC: mở Menu</li>
    <li>Vật phẩm trong game: Energy, Mana, HP, Box</li>
  </ul>
  <div class="spacerguide"></div> <!-- 👈 dòng đệm -->
  <button onclick="hideGuide()">Đóng</button>
</div>
<div id="infoOverlay" class="infoOverlay" style="display: none;">
  <h3 style="margin-top: 0; color: #66aaff;">ℹ️ Thông tin</h3>
  <div class="infoContent">
    <p>Phiên bản: 1.2<br>
       Tác giả: Dang<br>
       Cập nhật: 2025-07-31</p>
    <p style="margin: 0; text-align: left;"><strong style="color: #00cc66;">🆕 New</strong></p>
    <!-- Phần có thể cuộn và canh trái -->
    <div style="max-height: 128px;overflow-y: auto;scrollbar-width: none;
    -ms-overflow-style: none;text-align: left;">
      <ul style="padding-left: 20px;margin-top: 2px;list-style-type: disc;">
        <li>Thêm minimap</li>
        <li>Tăng giới hạn bản đồ</li>
        <li>Tăng giới hạn số lượng Zombie</li>
        <li>Thêm Boss to hơn</li>
        <li>Cải tiến một số kỹ năng</li>
        <li>Thêm hệ thống ngày đêm</li>
        <li>Thêm kỹ năng hỗ trợ</li>
        <li>Thêm Shop và Menu cài đặt</li>
        <li>Thêm vật phẩm mới: Coin, lucky, power, crazy</li>
        <!-- Các mục mới có thể thêm ở đây -->
      </ul>
    </div>
    <!-- Ẩn scrollbar trên Chrome/Safari -->
    <style>
      .infoContent div::-webkit-scrollbar {
        display: none;
      }
    </style>
  </div>
  <div class="spacer"></div>
  <button onclick="hideInfo()">Đóng</button>
</div>

<!-- 💀 Game Over Panel -->
<div id="gameOverPanel" class="gameOverPanel">
  <h2 class="gameOverTitle">Game Over</h2>
  <button onclick="location.reload()" class="restartButton">Chơi lại</button>
</div>

<!-- 🌊 Popup khi bắt đầu mỗi Wave -->
<div id="wavePopup">Wave 1</div>

<!-- ⏳ Đồng hồ đếm thời gian wave -->
<div id="dayCounterDisplay">Ngày: 1</div>
<div id="bigBossRespawnDisplay">BigBoss: wait..</div>
<div id="waveTimerDisplay">01:30:00</div>
<div id="waveNumberDisplay">Wave: 1</div>
<div id="coinCounterDisplay">🪙: 0000</div>
<div id="luckyBuffDisplay" class="buff-display">🍀 LuckyUp: <span>--</span>-</div>
<div id="powerBuffDisplay" class="buff-display">🍁 PowerUp: <span>--</span>-</div>
<div id="crazyBuffDisplay" class="buff-display">🍂 CarzyUp: <span>--</span>-</div>
<div id="expBuffDisplay" class="buff-display">🌿 ExpUp: <span>--</span>-</div>
<div id="magnetBuffDisplay" class="buff-display">🧲 Magnet: <span>---</span></div>

<!-- Mini map -->
<canvas id="miniMap" width="150" height="150"></canvas>
<script>
// --- BẮT ĐẦU: HỆ THỐNG ÂM THANH & NHẠC NỀN HOÀN CHỈNH ---

// Danh sách ID và file nhạc
const normalMusicTracks = ['music-background', 'music-background-2', 'music-background-3'];
const bossMusicId = 'music-boss';
const luckyMusicId = 'sfx-lucky-loop';
const powerMusicId = 'sfx-power-loop';
const crazyMusicId = 'sfx-crazy-loop';
const expMusicId = 'sfx-exp-loop';

// Biến trạng thái
let currentMusicState = '';
let currentNormalTrackId = '';

// BỔ SUNG LẠI HÀM BỊ THIẾU: Cập nhật âm lượng cho tất cả các track nhạc
function updateAllMusicVolume() {
    // Tính toán âm lượng cuối cùng dựa trên thanh trượt Tổng và Nhạc nền
    const finalMusicVol = musicVolume * masterVolume;
    // Áp dụng âm lượng cho tất cả các thẻ audio dùng cho nhạc
    document.querySelectorAll('audio[id^="music-"], audio[id^="sfx-"][loop]').forEach(audio => {
        if (audio) audio.volume = finalMusicVol;
    });
}

// Hàm phát hiệu ứng âm thanh (SFX)
function playSound(id, baseVolume = 1.0) {
    const soundElement = document.getElementById(id);
    if (soundElement && soundElement.src) {
        const audio = new Audio(soundElement.src);
        audio.volume = baseVolume * sfxVolume * masterVolume; // Tính âm lượng cuối cùng
        audio.play().catch(e => {});
    }
}

// Hàm dừng tất cả nhạc nền
function stopAllMusic() {
    document.querySelectorAll('audio[id^="music-"], audio[id^="sfx-"][loop]').forEach(audio => {
        if(audio) { audio.pause(); audio.currentTime = 0; }
    });
}

// Hàm phát nhạc nền ngẫu nhiên
function playRandomNormalMusic() {
    const availableTracks = normalMusicTracks.filter(id => id !== currentNormalTrackId);
    const randomTrackId = availableTracks.length ? availableTracks[Math.floor(Math.random() * availableTracks.length)] : normalMusicTracks[0];
    
    stopAllMusic();
    const trackElement = document.getElementById(randomTrackId);
    if (trackElement) {
        updateAllMusicVolume(); // Gọi hàm để đặt đúng âm lượng
        trackElement.play().catch(e => console.error("Lỗi phát nhạc thường:", e));
    }
    currentNormalTrackId = randomTrackId;
    currentMusicState = 'normal';
}

// Hàm cập nhật nhạc nền chính (ĐÃ SỬA LỖI)
function updateMusic() {
    const now = Date.now();
    const bigBoss = zombies.find(z => z.active && z.isBigBoss);
    
    // Tìm buff có ưu tiên cao nhất (được nhặt sau cùng)
    let latestBuffEndTime = 0;
    let highestPriorityState = null;

    // SỬA LỖI: Sử dụng đúng tên biến expBuffEndTime
    if (now < expBuffEndTime && expBuffEndTime > latestBuffEndTime) {
        latestBuffEndTime = expBuffEndTime;
        highestPriorityState = 'exp';
    }
    if (now < crazyBuffEndTime && crazyBuffEndTime > latestBuffEndTime) {
        latestBuffEndTime = crazyBuffEndTime;
        highestPriorityState = 'crazy';
    }
    if (now < powerBuffEndTime && powerBuffEndTime > latestBuffEndTime) {
        latestBuffEndTime = powerBuffEndTime;
        highestPriorityState = 'power';
    }
    if (now < luckyBuffEndTime && luckyBuffEndTime > latestBuffEndTime) {
        latestBuffEndTime = luckyBuffEndTime;
        highestPriorityState = 'lucky';
    }

    let desiredState = 'normal';

    if (highestPriorityState) {
        desiredState = highestPriorityState;
    } else if (bigBoss) {
        desiredState = 'boss';
    }

    if (desiredState !== currentMusicState) {
        stopAllMusic();
        let trackToPlayId = null;

        if (desiredState === 'exp') trackToPlayId = expMusicId;
        else if (desiredState === 'crazy') trackToPlayId = crazyMusicId;
        else if (desiredState === 'lucky') trackToPlayId = luckyMusicId;
        else if (desiredState === 'power') trackToPlayId = powerMusicId;
        else if (desiredState === 'boss') trackToPlayId = bossMusicId;
        else { playRandomNormalMusic(); return; }
        
        const trackElement = document.getElementById(trackToPlayId);
        if (trackElement) {
            updateAllMusicVolume();
            trackElement.play().catch(e => console.error(`Lỗi phát nhạc cho trạng thái '${desiredState}':`, e));
        }
        currentMusicState = desiredState;
    }
}
// --- KẾT THÚC: HỆ THỐNG ÂM THANH & NHẠC NỀN ---
// 🧱 1. Biến toàn cục – Cấu hình & Khởi tạo
let camera = { x: 0, y: 0 }; // 📷 Vị trí camera
let backgroundStars = [];
let backgroundBirds = [];
let backgroundTrees = [];
let backgroundClouds = [];
let backgroundPlanes = [];
let backgroundMushrooms = [];
let backgroundRocks = [];
let backgroundBalloons = [];
let backgroundSeeds = [];
let dayTime = 0.25; // 0.25 = 6h
let dayDirection = 1; // giữ lại cờ này như cũ
const dayDuration = 600; // 1 vòng ngày đêm = 96 giây thực tế
let lastUpdateTime = Date.now();
let prevIsNight = isNight();
let backgroundBigStars = [];
let globalDeltaTime = 0;
let currentDay = 1; // ✨ biến đếm số ngày trôi qua
// 🦋 Trạng thái kỹ năng Fairy
let fairyActive = false;
let fairyEndTime = 0;
let fairies = []; // Mảng chứa các Fairy
let lastFairyHealTime = 0;
let fairyDamageBonus = 0; // Lưu lại mức sát thương cộng thêm
let fairyDeathDefyAvailable = false; // Cờ cho cơ chế hồi sinh
let lastShieldBlockSoundTime = 0;
let luckyBuffEndTime = 0;
let powerBuffEndTime = 0;
let isPowerBuffActive = false; // Biến cờ để tránh nhân/chia sát thương nhiều lần
let crazyBuffEndTime = 0;
let isCrazyBuffActive = false;
let expBuffEndTime = 0;
let magnetBuffEndTime = 0;
let supplyDrops = []; // Mảng chứa các kiện hàng 🪂
let morningDropTriggered = false; // Cờ để đảm bảo chỉ rơi 1 lần mỗi 9h sáng
let morningDropTriggered12h = false;    // Cho 12h
let morningDropTriggered15h = false;    // Cho 15h
// Dữ liệu quản lý hiệu ứng đóm sáng cho các buff
const buffEffects = {
    power: { color: "#ef4444", active: false, angle: 0 },
    crazy: { color: "#f59e0b", active: false, angle: 0 },
    lucky: { color: "#22c55e", active: false, angle: 0 },
    exp:   { color: "#ffeb3b", active: false, angle: 0 },
    magnet: { color: "#8b5cf6", active: false, angle: 0 } // Thêm Magnet vào hiệu ứng đóm sáng
};

// Biến để lưu trữ lượng chỉ số cộng thêm từ buff, giúp gỡ bỏ chính xác
let powerBuffDamageBonus = 0;
let crazyBuffStats = { speed: 0, bulletSpeed: 0, damage: 0 };

let debugKeyTimer = null; // Biến để lưu timer của phím Debug
// Menu ESC
let masterVolume = 1.0;
let musicVolume = 0.5;
let sfxVolume = 0.8;
// (Thêm vào cùng các biến toàn cục khác)
const shopItems = [
    { id: 'buy_10_mana',   name: '10 Mana',   icon: '💠', cost: 1, type: 'resource', value: 10 },
    { id: 'buy_10_energy', name: '10 Energy', icon: '⚡', cost: 1, type: 'resource', value: 10 },
    { id: 'buy_5_hp',      name: '5 HP',      icon: '❤️', cost: 1, type: 'resource', value: 5 },
    { id: 'buy_12_hp',      name: '12 HP',      icon: '❤️', cost: 2, type: 'resource', value: 12 },
    { id: 'buy_damage',    name: 'Sát thương +0.2', icon: '💥', cost: 3, type: 'permanent_upgrade', value: 0.2 },
    // Bạn có thể thêm các vật phẩm khác vào đây
];
// ✨ DANH SÁCH CÁC LOẠI ZOMBIE ✨
const zombieTypes = [
    // 4 loại cũ
    "Walker", "Brute", "Spitter", "Mutant",
    // 48 loại mới từ file của bạn
    "Cyber", "Hunter", "Shadow", "Arcanist", "Soldier", "Robot",
    "Knight", "Rogue", "Wraith", "Astronaut", "Beast", "Spectre",
    "Ninja", "Samurai", "Alien", "Skeleton", "Mage", "Ghost",
    "Monk", "Cyborg", "Shaman", "Demon", "Angel", "Guardian",
    "Pilot", "Engineer", "Android", "Starfighter", "Commander", "Medic",
    "Barbarian", "Paladin", "Druid", "Necromancer", "Archer", "Sorcerer",
    "Bard", "Cleric", "Vampire", "Werewolf", "Goblin", "Elf",
    "Dwarf", "Orc", "Detective", "Swat", "Firefighter", "Doctor"
];
let lastBigBossTimerUpdate = performance.now();
let bigBossRespawnTimer = 0;
const bigBossRespawnInterval = 100; // Thời gian hồi sinh bigboss - giây

// 🔫 Cấu hình bắn
let autoBurstIndex = 0;
let autoLastBurstTime = 0;
let clickShotMode = 5; // 0: xoắn ốc, 1: zigzag, 2: spiral, 3: xuyên thẳng, 4: mặc định

const autoBurstDelay = 100; // ms delay giữa từng viên trong auto

// 🧟 Thống kê – Kỹ năng & zombie
let zombieKillCount = 0;
let zombieSpawnedCount = 0;
let zombieByLevel = {};
for (let i = 1; i <= 10; i++) zombieByLevel[i] = 0;
zombieByLevel.boss = 0;
zombieByLevel.miniBoss = 0;
let skillStats = {};             // 📊 Thống kê kỹ năng

// 🧍 Trạng thái người chơi
const player = {
  x: 480, y: 360, size: 20, speed: 1,
  hearts: 10, energy: 0, mana: 0,
  coins: 0,
  level: 1, score: 0,
  exp: 0,
  currentLevelExp: 0, // THÊM MỚI: EXP của cấp hiện tại
  requiredExp: 300,   // THÊM MỚI: EXP cần để lên cấp tiếp theo
  hitTimer: 0,
  name: "Player",
  isDying: false,
  // ✨ THÊM CÁC DÒNG SAU VÀO ĐÂY ✨
  isTeleporting: false,      // Cờ báo hiệu đang trong quá trình dịch chuyển
  isGrowingAfterTeleport: false, // Cờ báo hiệu đang lớn dần ra sau khi dịch chuyển
  originalSize: 20,          // Dùng để lưu lại kích thước gốc
};

// 🌟 Trạng thái nâng cấp
const playerUpgrades = {
  fireRate: 1,          // 🔫 Hướng bắn
  damageBoost: 1,       // 💥 Sát thương cơ bản cộng thêm
  hpBoost: 0,           // ❤️ Số lần đã tăng máu
  bulletSpeed: 1,       // 💨 Tốc độ đạn
  lineBulletCount: 1    // 🧨 Số lượng đạn
};
// 🌟 Biến nâng cấp kỹ năng mặc định (🔪 Đao, ⚔️ Kiếm, 🔥 Lửa, ❄️ Băng)
const skillUpgrades = {
  // 🔪 Đao: số lượng đao và sát thương từng đao
  bladeCount: 2,           // bắt đầu 2 đao, tối đa 20
  bladeDamage: 1,          // sát thương từng đao

  // ⚔️ Kiếm: cấp độ mưa kiếm (số lượng + sát thương)
  swordLevel: 1,           // cấp độ mưa kiếm, tối đa 10
  swordDamage: 3,          // sát thương mỗi kiếm

  // 🔥 Lửa: số lượng cầu lửa và sát thương
  fireCount: 2,            // bắt đầu 2 quả cầu, tối đa 10
  fireDamage: 1,           // sát thương mỗi quả

  // ❄️ Băng: số lượng cầu băng và sát thương
  iceCount: 2,             // bắt đầu 2 quả cầu, tối đa 10
  iceDamage: 2,             // sát thương mỗi quả
  // Lôi
  thunderCount: 2,         // bắt đầu 2 quả cầu lôi, tối đa 6
  thunderDamage: 3,        // sát thương mỗi quả cầu lôi
  // 🦋 Nâng cấp kỹ năng Fairy
  fairyCount: 1,      // Số lượng Fairy, tối đa 3
  fairyHealLevel: 0,  // Cấp độ hồi máu
  fairyDamageLevel: 0, // Cấp độ tăng sát thương
  
  auraHealLevel: 0, // Cấp độ hồi máu của Hào quang, bắt đầu từ 0

};
let petActive = false;
let petEndTime = 0;
let petRabbit = null;
let petLastHealTime = 0;
/* ── chống chọn lại món đồ vừa bỏ ── */
let lastGiveUpId   = null;   // id món đồ vừa bị bỏ
let lastGiveUpTime = 0;      // mốc thời gian bỏ
const RESELECT_CD  = 2000;   // 2 000 ms → cấm chọn lại 2 s
let auraCrackLines = []; // Mảng chứa các đường nứt phát sáng dưới đất
let auraLightBeams = []; // Mảng chứa các cột sáng bay lên
let supportAuraActive = false;
let supportAuraEndTime = 0;
let lastAuraHealTime = 0;
// ⚙️ Trạng thái điều khiển & kỹ năng
let lastManualShootTime = 0;
const manualShootCooldown = 500; // delay 1 giây
let lastAutoShootTime = 0;
const autoShootCooldown = 500;
let playerLasers = []; // Mảng chứa các tia laze của người chơi

let keys = {};
let autoShoot = false;
let fireActive = false;
let iceActive = false;
let swordActive = false;
let bladeActive = false;
let frame = 0;
let gameOver = false;
let isPaused = false;
let pendingWave = null;
let uiVisible = true; // Trạng thái hiển thị UI
let swordRainClouds = [];
let nextFireIndex = 0; // Kỹ năng đao xoay

// Kỹ năng active
let satelliteActive = false;
let satelliteEndTime = 0;
let satellites = [];

let ufoActive = false; // Kỹ năng UFO
let ufoEndTime = 0;
let ufoCooldown = 0;
let ufoCount = 1;
let ufos = [];
// ========================= ⚡ Lightning – trạng thái & dữ liệu =========================
let lightningActive = false; // Kỹ năng sét - trạng thái & dữ liệu
let lightningEndTime = 0;
let lightningBolts = [];
let activeLightningStrikes = [];
let nextLightningStrikeTime = 0;
let disguiseActive = false;
let disguiseEndTime = 0;

let clones = []; // 🎭 Global – lưu các bản sao hiện tại
let clonesActive = false;
let clonesEndTime = 0;
let activeCloneLasers = []; // Mảng chứa các tia lazer của clone

let blackHoles = []; // Danh sách hố đen
let extraShockwaves = []; // 🌊 các vòng nổ phụ lan ra

let bloodOrbActive = false;
let bloodOrbEndTime = 0;
let bloodOrbs = []; // [{ angle, radius, x, y }]
let bloodOrbCount = 1; // về sau nâng cấp +1 quả cầu
let bloodOrbLastDrain = 0;
let particles = [];
let healEffects = []; // Tạo "Kho" Chứa Hiệu ứng

// 🚪 Trạng thái Cổng Không Gian
let spaceGate = null; // Biến chứa đối tượng cổng
let spaceGateActive = false;
let spaceGateEndTime = 0;
let lastTeleportTime = 0; // Lưu thời điểm dịch chuyển cuối
const GATE_COOLDOWN = 2000; // 1000ms = 1 giây chờ
// Quản lý trạng thái animation khi dịch chuyển
let playerTeleportState = {
    phase: null, // các giai đoạn: 'shrinking', 'growing'
    progress: 0, // tiến trình của hiệu ứng (từ 1.0 xuống 0.0 và ngược lại)
    originalPlayerSize: 0,
    originalGateRadius: 0,
};

// 🌊 Quản lý wave
let wave = 1;
let waveTime = 180; // Thời gian mỗi wave
let waveTimer = waveTime;
let lastWaveTime = null;
let gameStarted = false;

// ⏱ Thời gian kỹ năng
let fireEndTime = 0;
let iceEndTime = 0;
let swordEndTime = 0;
let bladeEndTime = 0;
let levelUpGlowTime = 0;
let nextBladeToAttack = 0; // Theo dõi thứ tự của đao sắp tấn công
let lastBladeLaunchTime = 0; // Mốc thời gian của lần phóng đao cuối

// 📱 Điều khiển cảm ứng
let touchStartX = null, touchStartY = null;
let touchMoveX = null, touchMoveY = null;

// 🎮 Danh sách các đối tượng trong game
let enemyBullets = []; // Zombie bắn trả
let zombies = [];
let bullets = [];
let swords = [];
let downwardSwords = [];
let fireballs = [];
let iceballs = [];
let thunderActive = false;
let thunderEndTime = 0;
let thunderBalls = [];
let items = [];
let explosions = [];
let missiles = []; // 🚀 Danh sách tên lửa đang bay
let expandingExplosions = []; // ☢️ Các vòng nổ lan rộng (dùng cho bom hạt nhân)
let nuclearBombs = []; // Mảng lưu trữ riêng bom hạt nhân
let bombsB52 = []; // 💣 Danh sách bom B52
let activePlanes = [];   // 🛬 Danh sách máy bay đang hoạt động

// 🔧 Vẽ Canvas
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// 🌀 Object Pooling
const bulletPool = [];
const explosionPool = [];
const zombiePool = [];
const swordPool = [];
const fireballPool = [];
const iceballPool = [];

//📲 2. Sự kiện điều khiển bàn phím, chuột, cảm ứng
// ⌨️ Bàn phím di chuyển
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

// 🖱 Click chuột để bắn
canvas.addEventListener("click", () => {
  const now = Date.now();
  if (now - lastManualShootTime < manualShootCooldown) return;
  // Không đặt lại lastManualShootTime ở đây để laze có thể tự kiểm tra

  if (zombies.length === 0) return;

  // THÊM MỚI: Nếu đang ở chế độ laze, gọi hàm bắn laze và kết thúc
  if (clickShotMode === 4) {
      firePlayerLaser();
      return;
  }

  // Logic bắn đạn thường (giữ nguyên)
  lastManualShootTime = now; // Đặt lại cooldown cho đạn thường
  const target = zombies.reduce((a, b) =>
    distance(a, player) < distance(b, player) ? a : b
  );

  const angle = Math.atan2(target.y - player.y, target.x - player.x);
  const bullet = getBullet();
  bullet.x = player.x;
  bullet.y = player.y;
  bullet.speed = playerUpgrades.bulletSpeed;
  bullet.active = true;
  bullet.color = "cyan";
  bullet.piercing = true;
  bullet.rotation = 0;

  // ======= Kiểu bắn tùy theo clickShotMode =======
  if (clickShotMode === 0) {
    // 🔄 Xoắn ốc quanh player
    bullet.curveMode = true;
    bullet.angle = angle;
    bullet.curveRadius = 0;
    bullet.curveSpeed = 0.1 + Math.random() * 0.05;

  } else if (clickShotMode === 1) {
    // ↔️ Zigzag
    bullet.zigzagMode = true;
    bullet.baseAngle = angle;
    bullet.oscillatePhase = Math.random() * Math.PI * 2;
    bullet.oscillateSpeed = 0.2;
    bullet.oscillateAmplitude = 20;
    bullet.travel = 0;
    bullet.startX = player.x;
    bullet.startY = player.y;

  } else if (clickShotMode === 2) {
    // 🎯 Xoắn ốc bay thẳng
    bullet.spiralForwardMode = true;
    bullet.baseAngle = angle;
    bullet.travel = 0;
    bullet.spiralRadius = 15;
    bullet.spiralSpeed = 0.3;
    bullet.spiralPhase = Math.random() * Math.PI * 2;
    bullet.startX = player.x;
    bullet.startY = player.y;

  } else if (clickShotMode === 3) {
    // 🎯 Kiểu 3 – Xuyên thẳng
    bullet.dx = Math.cos(angle);
    bullet.dy = Math.sin(angle);
    bullet.piercing = true;

  } else if (clickShotMode === 5) { // THAY ĐỔI: Chuyển kiểu mặc định sang số 5
    // 🔵 Kiểu 5 – Giống auto shoot
    bullet.dx = Math.cos(angle);
    bullet.dy = Math.sin(angle);
    bullet.piercing = false; // ❗ không xuyên
  }
  // ================================================

  bullets.push(bullet);
});
// Gán sự kiện middle click (chuột giữa) để chuyển kiểu bắn
canvas.addEventListener("mousedown", (e) => {
  if (e.button === 1) {
    // THAY ĐỔI: Tăng tổng số kiểu đạn lên 6
    clickShotMode = (clickShotMode + 1) % 6;
    
    // THAY ĐỔI: Cập nhật lại danh sách tên các kiểu đạn
    const modeNames = [
      "🔄 Xoắn ốc", 
      "↔️ Zigzag", 
      "🎯 Xoắn bay thẳng", 
      "🎯 Xuyên thẳng", 
      "💥 Laze", // Thêm Laze vào vị trí số 4
      "🔵 Mặc định" // Chuyển Mặc định xuống vị trí số 5
    ];
    showWarning(`Kiểu đạn chuột trái: ${modeNames[clickShotMode]}`);
    e.preventDefault();
  }
});

// Sử dụng phím Space để bắn
document.addEventListener("keydown", e => {
  if (e.code === 'Space') shoot();
});

// 📱 Điều khiển cảm ứng
canvas.addEventListener("touchstart", e => {
  const touch = e.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
});
canvas.addEventListener("touchmove", e => {
  const touch = e.touches[0];
  touchMoveX = touch.clientX;
  touchMoveY = touch.clientY;
  e.preventDefault(); // ngăn cuộn trang
});
canvas.addEventListener("touchend", () => {
  touchStartX = null;
  touchStartY = null;
  touchMoveX = null;
  touchMoveY = null;
});
// Hàm tiện ích để phát âm thanh theo ID, có thể tùy chỉnh âm lượng
function playSound(id, volume = 1.0) { // Thêm tham số volume với giá trị mặc định là 1.0 (100%)
    const sound = document.getElementById(id);
    if (sound) {
        sound.volume = volume; // Đặt âm lượng trước khi phát
        sound.currentTime = 0;
        sound.play();
    }
}
// Hàm tiện ích để lấy một số nguyên ngẫu nhiên trong một khoảng
function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
//💥 3. Hàm hỗ trợ tiện ích
function distance(a, b) {
return Math.hypot(a.x - b.x, a.y - b.y);}

function distanceSq(a, b) {
    return (a.x - b.x)**2 + (a.y - b.y)**2;
}
function createFairyHitParticle(targetZombie) {
    particles.push({
        type: 'fairy_status_effect', // Loại hạt mới
        target: targetZombie,       // "Dính" vào mục tiêu này
        life: 180,                   // Tồn tại trong 1.5 giây (60fps * 1.5)
        maxLife: 180,
        angle: Math.random() * Math.PI * 2, // Góc xoay ban đầu
        orbitRadius: targetZombie.radius + 5 + Math.random() * 5, // Khoảng cách xoay
        size: 0.5 + Math.random() * 1,                 // Kích thước hạt
        color: 'rgba(100, 255, 150, 0.8)'   // Màu xanh lá cây bạc hà

    });
}
/**
 * Tạo hiệu ứng "cổng dịch chuyển" để báo hiệu zombie sắp xuất hiện.
 * @param {number} x - Tọa độ X.
 * @param {number} y - Tọa độ Y.
 */
function createSpawnEffect(x, y) {
    playSound('sfx-nuke-fall', 0.5); // Tạm dùng âm thanh bom rơi để cảnh báo
    // Tạo 30 hạt bay ra từ tâm theo hình tròn
    for (let i = 0; i < 30; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 2;
        particles.push({
            x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 2 + 1,
            color: 'rgba(139, 0, 139, 0.8)', // Màu tím đậm
            alpha: 1,
            fastFade: true
        });
    }
}
/**
 * Tạo một vụ nổ bằng các hạt (particle) tại một vị trí.
 * @param {number} x Tọa độ X của vụ nổ.
 * @param {number} y Tọa độ Y của vụ nổ.
 * @param {number} count Số lượng hạt.
 * @param {string} baseColor Màu cơ bản của vụ nổ (ví dụ: 'orange', 'cyan').
 */
function createParticleExplosion(x, y, count, colorScheme = 'fire') {
    let colors;
    let maxDist = 60; // Bán kính mặc định

    // Chọn bộ màu và bán kính dựa trên yêu cầu
    if (colorScheme === 'fire') {
        colors = [
            'rgba(255, 255, 255, 0.9)', // Trắng
            'rgba(255, 220, 0, 0.8)',   // Vàng
            'rgba(255, 150, 0, 0.8)',   // Cam
            'rgba(255, 50, 0, 0.7)'     // Đỏ
        ];
        maxDist = 60; // Bán kính nổ của tên lửa
    } else if (colorScheme === 'smoke') {
        colors = [
            'rgba(200, 200, 200, 0.7)', // Xám sáng
            'rgba(150, 150, 150, 0.6)', // Xám vừa
            'rgba(100, 100, 100, 0.5)'  // Xám tối
        ];
        maxDist = 80; // Bán kính của bom khói
    }

    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 2;

        const color = colors[Math.floor(Math.random() * colors.length)];

        particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 1 + 2,
            color: color,
            alpha: 1,
            fastFade: true,
            originX: x,
            originY: y,
            maxDistance: maxDist
        });
    }
}

/**
 * Tạo một đối tượng hiệu ứng dying và thêm vào mảng healEffects.
 */
function spawnDyingEffect(z) {
    healEffects.push({
        x: z.x,
        y: z.y - z.radius,
        life: 60,
        maxLife: 60,
        text: '☠️',
        delay: 0  // No delay for death effect
    });
}
/**
 * Tạo một đối tượng hiệu ứng và thêm vào mảng healEffects.
 */
function spawnHealEffect(z) {
    healEffects.push({
        x: z.x,
        y: z.y - z.radius,
        life: 60,
        maxLife: 60,
        text: '💙', // Thêm vào để xác định icon
        delay: 20  // Thêm độ trễ 20 frame
    });
}

/**
 * Tạo một đối tượng hiệu ứng debuff và thêm vào mảng healEffects.
 */
function spawnDebuffParticle(z) {
    healEffects.push({
        x: z.x,
        y: z.y - z.radius,
        life: 60,
        maxLife: 60,
        text: '💔',
        delay: 20 // Thêm độ trễ 20 frame
    });
}

/**
 * Cập nhật và vẽ tất cả các hiệu ứng (đã sửa lỗi và thêm delay).
 */
function updateAndDrawHealEffects() {
    ctx.font = "1rem sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    for (let i = healEffects.length - 1; i >= 0; i--) {
        const effect = healEffects[i];

        // Luôn giảm life mỗi frame để hiệu ứng biết khi nào cần biến mất
        effect.life--;

        // Nếu còn delay, chỉ đứng yên tại chỗ
        if (effect.delay > 0) {
            effect.delay--;
        } else {
            // Hết delay thì mới bắt đầu bay lên
            effect.y -= 0.5;
        }

        // ✨ THAY ĐỔI: Sử dụng màu từ hiệu ứng, nếu không có thì mặc định là màu trắng
        ctx.fillStyle = effect.color || "white";
        ctx.globalAlpha = effect.life / effect.maxLife;
        
        // Vẽ đúng icon (text) của hiệu ứng
        ctx.fillText(effect.text, effect.x, effect.y);

        // Xóa hiệu ứng khi life <= 0
        if (effect.life <= 0) {
            healEffects.splice(i, 1);
        }
    }
    
    ctx.globalAlpha = 1; // Reset độ mờ
}

// 🎁 Hàm quản lý rơi vật phẩm khi zombie bị tiêu diệt
function dropItem(x, y, isBoss = false, isBigBoss = false, isMiniBoss = false, isElite = false) {
  
    let finalDropCount = 0;
    const isLuckyActive = Date.now() < luckyBuffEndTime;

    if (isBigBoss) {
        // BigBoss rơi ngẫu nhiên từ 5 đến 10 vật phẩm
        finalDropCount = getRandomInt(5, 10);
    } else if (isBoss) {
        // Boss thường rơi ngẫu nhiên từ 3 đến 5 vật phẩm
        finalDropCount = getRandomInt(3, 5);
    } else if (isMiniBoss) {
        // MiniBoss rơi ngẫu nhiên từ 2 đến 3 vật phẩm
        finalDropCount = getRandomInt(2, 3);
    } else if (isElite) {
        // Elite zombie rơi ngẫu nhiên từ 1 đến 2 vật phẩm
        finalDropCount = getRandomInt(1, 2);
    } else {
        // Zombie thường giữ logic cũ: có tỉ lệ rơi 1 vật phẩm
        let dropChance = 0.3; // 30% mặc định
        if (isLuckyActive) {
            dropChance = 0.8; // Tăng lên 80% khi có buff
        }
        if (Math.random() < dropChance) {
            finalDropCount = 1;
        }
    }

    // Nếu có buff Lucky, nhân đôi số lượng vật phẩm rơi ra
    if (isLuckyActive) {
        finalDropCount *= 2;
    }

    // Nếu không có vật phẩm nào rơi, kết thúc hàm
    if (finalDropCount === 0) {
        return;
    }

    // Vòng lặp tạo ra các vật phẩm dựa trên số lượng cuối cùng
    for (let i = 0; i < finalDropCount; i++) {
        const offsetX = (Math.random() - 0.5) * 30;
        const offsetY = (Math.random() - 0.5) * 30;
        const safeX = Math.min(worldWidth - wallThickness - 20, Math.max(wallThickness + 20, x + offsetX));
        const safeY = Math.min(worldHeight - wallThickness - 20, Math.max(wallThickness + 20, y + offsetY));
        
    // --- BẮT ĐẦU CẬP NHẬT TỈ LỆ RƠI MỚI ---
    const itemRand = Math.random();
    let type = null;
    // Tỉ lệ rơi vật phẩm mới:
    // Mana, Energy: 30%
    // Coin, HP: 10%
    // Lucky, Power, Crazy, Exp: 3%
    // Box, Magnet, Secret, ExpBonus: 2%
if (itemRand < 0.005)      type = 'box';       // 0.5% (đã giảm)
else if (itemRand < 0.01)  type = 'magnet';    // 0.5%
else if (itemRand < 0.015) type = 'secret';    // 0.5%
else if (itemRand < 0.025) type = 'expBonus';  // 1%
else if (itemRand < 0.035) type = 'hp';        // 1%
else if (itemRand < 0.055) type = 'coin';      // 2%
else if (itemRand < 0.065) type = 'lucky';     // 1%
else if (itemRand < 0.075) type = 'power';     // 1%
else if (itemRand < 0.085) type = 'crazy';     // 1%
else if (itemRand < 0.095) type = 'exp';       // 1%
else if (itemRand < 0.10)  type = 'potion';    // 0.5% (vật phẩm mới)
else if (itemRand < 0.55)  type = 'mana';      // 45% (0.10 -> 0.55)
else                       type = 'energy';    // 45% (0.55 -> 1.00)

    if (type) {
        items.push({ x: safeX, y: safeY, type, active: true });
    }
  }
}

// 📦 Khi người chơi nhặt hộp vật phẩm đặc biệt
function openItemBox() {
  const rewardCount = Math.floor(Math.random() * 3) + 1; // Nhận 1–3 loại ngẫu nhiên
  const rewards = [
    { type: 'energy', label: '⚡ Energy', icon: '⚡' },
    { type: 'mana', label: '💠 Mana', icon: '💠' },
    { type: 'hp', label: '❤️ HP', icon: '❤️' }
  ];

  const shuffled = rewards.sort(() => Math.random() - 0.5);
  const selected = shuffled.slice(0, rewardCount);
  const summary = [];

  selected.forEach(r => {
    const amount = Math.floor(Math.random() * 5) + 3;
    switch (r.type) {
      case 'energy': player.energy += amount; break;
      case 'mana': player.mana += amount; break;
      case 'hp': player.hearts += amount; break;
    }
    summary.push(`${r.icon} +${amount}`);
  });

  // 📢 Gộp thành một dòng thông báo duy nhất
  showWarning(`📦 Hộp quà: ${summary.join(', ')}`);
}
// Hàm xử lý khi nhặt vật phẩm Secret (phiên bản đã cập nhật tỉ lệ)
function activateSecretItem(item) {
    if (!item) return;

    const rand = Math.random(); // Tạo một số ngẫu nhiên từ 0 đến 1

    // --- BẮT ĐẦU LOGIC MỚI ---

    // 50% cơ hội nhận được một buff ngẫu nhiên
    if (rand < 0.50) {
        const buffs = ['lucky', 'power', 'crazy', 'exp'];
        const randomBuff = buffs[Math.floor(Math.random() * buffs.length)];
        
        showWarning(`❓: Nhận được buff ${randomBuff.toUpperCase()}!`);
        switch (randomBuff) {
            case 'lucky': luckyBuffEndTime = Date.now() + 45000; break;
            case 'power': powerBuffEndTime = Date.now() + 45000; break;
            case 'crazy': crazyBuffEndTime = Date.now() + 45000; break;
            case 'exp':   expBuffEndTime = Date.now() + 45000; break;
        }
    } 
    // 30% cơ hội tiếp theo (từ 0.50 đến 0.80) nhận được Coin hoặc EXP
    else if (rand < 0.80) {
        // Bên trong 30% này, chia 50/50 cho Coin hoặc EXP
        if (Math.random() < 0.5) {
            // Nhận được Coin
            const coinBonus = Math.round((wave + player.level) * (Math.random() * 3 + 2));
            player.coins += coinBonus;
            showWarning(`❓: Nhận được ${coinBonus} 🪙!`);
        } else {
            // Nhận được EXP
            activateExpBonusItem(); // Tái sử dụng hàm có sẵn để nhận EXP
        }
    } 
    // 20% cơ hội còn lại (từ 0.80 đến 1.0) là ra Boss
    else {
        showWarning("Oh! No");
        createSpawnEffect(item.x, item.y);
        setTimeout(() => {
            showWarning("❓: Một kẻ địch mạnh đã xuất hiện!");
            spawnBoss(item.x, item.y);
        }, 500); // Đợi 0.5 giây để tạo hiệu ứng
    }
    // --- KẾT THÚC LOGIC MỚI ---
}

// Hàm xử lý khi nhặt vật phẩm ExpBonus
function activateExpBonusItem() {
    // Lượng EXP thưởng = (wave + level) * (một số ngẫu nhiên từ 5 đến 10)
    const bonus = Math.round((wave + player.level) * (Math.random() * 5 + 5));
    player.exp += bonus;
    player.currentLevelExp += bonus;
    createExpGainEffect({x: player.x, y: player.y, radius: 20}, bonus);
    showWarning(`🌟 Thưởng: +${bonus} EXP!`);
}
// 🔁 Bullet Pooling
function getBullet() {
  return bulletPool.length ? bulletPool.pop() : { x: 0, y: 0, dx: 0, dy: 0, active: true };
}
function releaseBullet(bullet) {
    bullet.active = false;
    
    // ✨ BẮT ĐẦU PHẦN RESET TOÀN BỘ THUỘC TÍNH ĐẶC BIỆT ✨
    delete bullet.isFairyBullet; // Xóa cờ của đạn Fairy
    delete bullet.isPetBullet; // ✨ Thêm dòng này
    delete bullet.icon;        // ✨ Thêm dòng này
    delete bullet.stunDuration;// ✨ Thêm dòng này
    delete bullet.customDmg;     // Xóa sát thương riêng của Clone
    delete bullet.color;         // Xóa màu tùy chỉnh
    delete bullet.effect;        // Xóa hiệu ứng của đạn Fairy
    bullet.piercing = false;     // Reset thuộc tính xuyên thấu về mặc định
    
    // Reset các kiểu bay đặc biệt
    bullet.curveMode = false;
    bullet.zigzagMode = false;
    bullet.spiralForwardMode = false;
    // ✨ KẾT THÚC PHẦN RESET ✨

    bulletPool.push(bullet);
}

// 💥 Explosion Pooling
function getExplosion(x, y) {
  const e = explosionPool.length ? explosionPool.pop() : { x: 0, y: 0, radius: 0, life: 0, active: true };
  e.x = x;
  e.y = y;
  e.radius = 0;
  e.life = 20;
  e.active = true;
  return e;
}
function releaseExplosion(e) {
  e.active = false;
  explosionPool.push(e);
}

// 💥 Bắn đạn từ zombie về phía player - shootEnemyBullet pooling
function shootEnemyBullet(z, speed = 0.6, chance = 1) { // Nhận cả đối tượng zombie 'z'
    if (Math.random() > chance) return;

    const angle = Math.atan2(player.y - z.y, player.x - z.x);
    const b = getEnemyBullet();
    b.x = z.x;
    b.y = z.y;
    b.dx = Math.cos(angle);
    b.dy = Math.sin(angle);
    b.speed = speed;
    b.damage = calculateZombieDamage(z); // ✨ Tính và lưu sát thương vào đạn
    b.hit = false;
    b.active = true;

    enemyBullets.push(b);
}

// object pooling cho enemyBullets
const enemyBulletPool = [];

function getEnemyBullet() {
  return enemyBulletPool.length
    ? enemyBulletPool.pop()
    : { x: 0, y: 0, dx: 0, dy: 0, speed: 1, hit: false, active: true };
}

function releaseEnemyBullet(b) {
  b.hit = false;
  b.active = false;
  enemyBulletPool.push(b);
}

// 🧟 Zombie Pooling
function getZombie() {
    let z = zombiePool.length ? zombiePool.pop() : {
        x: 0, y: 0, radius: 15, canHit: true, speed: 1,
        color: "hotpink", isBoss: false, isBigBoss: false,
        hp: 1, active: true, type: "normal", level: 1
    };

    // Reset lại toàn bộ khi lấy từ pool
    z.active = true;
    z._killed = false;
    z.isBoss = false;
    z.isBigBoss = false;
    z.type = "normal";
    z.color = "hotpink";
    z.radius = 15;
    z.hp = 1;
    z.level = 1;
    z.baseSpeed = 0.1 + Math.random() * 0.1;
    z.speed = z.baseSpeed;
    z.canHit = true;
    return z;
}

function releaseZombie(z) {
  z.active = false;
  z.state = undefined;   
  zombiePool.push(z);
}
// 💥 Hàm tiêu diệt zombie, dùng chung cho mọi kỹ năng
function killZombie(z) {
  if (z._killed || !z.active) return;
  z._killed = true;
  playSound('sfx-zombie-die', 0.3);
  spawnDyingEffect(z);

  releaseZombie(z);
  
  // Luôn cộng 1 vào 'score' để đếm kill và tính high score
  player.score++;
  zombieKillCount = player.score;

  // --- BẮT ĐẦU: LOGIC TÍNH EXP MỚI ---
  let baseExp = 0;
  
  // 1. Tính EXP cơ bản theo loại zombie
  if (z.isBigBoss)      baseExp = 1000;
  else if (z.isBoss)    baseExp = 100;
  else if (z.type === "miniBoss") baseExp = 10;
  else if (z.isElite)   baseExp = 5;
  else                  baseExp = 1;

  // 2. Cộng thêm EXP dựa trên cấp độ của zombie
  if (!z.isBigBoss && !z.isBoss) {
      baseExp += (z.level - 1);
  }

  // 3. THAY ĐỔI: Cộng thêm EXP thưởng bằng đúng số wave (trừ 1)
  // Công thức mới: Tăng 1 EXP thưởng cho mỗi wave đã qua.
  const waveBonus = wave - 1;
  let expGained = baseExp + waveBonus;

  // 4. Áp dụng buff x1.5 EXP nếu có
  if (Date.now() < expBuffEndTime) {
      expGained = Math.round(expGained * 1.5);
  }
  
  // 5. Cộng EXP vào cho người chơi
  player.exp += expGained;
  player.currentLevelExp += expGained;
  createExpGainEffect(z, expGained);

  // --- KẾT THÚC: LOGIC TÍNH EXP MỚI ---

  // Phần thống kê và rơi vật phẩm giữ nguyên
  if (z.level && z.level >= 1 && z.level <= 10) {
    zombieByLevel[z.level] = (zombieByLevel[z.level] || 0) + 1;
  }
  if (z.type === "miniBoss") {
    zombieByLevel.miniBoss = (zombieByLevel.miniBoss || 0) + 1;
  }
  if (z.isBoss && !z.isBigBoss) {
    zombieByLevel.boss = (zombieByLevel.boss || 0) + 1;
  }
  if (z.isBigBoss) {
    zombieByLevel.bigBoss = (zombieByLevel.bigBoss || 0) + 1;
  }
  
  dropItem(z.x, z.y, z.isBoss, z.isBigBoss, z.type === "miniBoss", z.isElite);
}
/**
 * Tính toán lượng EXP yêu cầu để đạt được cấp độ tiếp theo.
 * @param {number} level - Cấp độ hiện tại của người chơi.
 * @returns {number} Số EXP cần thiết để lên cấp.
 */
function calculateRequiredExp(level) {
    // --- BẠN CÓ THỂ TÙY CHỈNH CÁC THAM SỐ NÀY ---

    // Lượng EXP cơ bản cần cho level 1.
    const baseExp = 300;

    // Hệ số gia tăng. Con số này càng lớn, các cấp độ sau càng khó.
    // 1.5 là một khởi đầu tốt, bạn có thể thử 1.6, 1.7... để làm game khó hơn.
    const exponent = 1.5;

    // Công thức tính: BaseEXP * (Level ^ Exponent)
    // Math.floor dùng để làm tròn xuống, cho ra một con số đẹp.
    return Math.floor(baseExp * Math.pow(level, exponent));
}
/**
 * Tính toán sát thương của zombie dựa trên loại, wave và level người chơi.
 * @param {object} z - Đối tượng zombie.
 * @returns {number} Sát thương cuối cùng (tối thiểu là 1).
 */
function calculateZombieDamage(z) {
    let baseDamage = 1;

    if (z.isBigBoss) baseDamage = 5;
    else if (z.isBoss) baseDamage = 3;
    else if (z.type === 'miniBoss') baseDamage = 2;

// ✅ Giảm sát thương cộng thêm ở wave & level thấp
    const damageFromWave = Math.max(0, wave - 1);
    const damageFromPlayerLevel = Math.max(0, player.level - 1);

    let totalDamage = baseDamage + damageFromWave + damageFromPlayerLevel;
    
    // Kiểm tra xem zombie có đang bị suy yếu không
    if (z.isWeakened && Date.now() < z.weakenEndTime) {
        // Nếu có, giảm 50% sát thương
        totalDamage *= 0.5;
    } else if (z.isWeakened) {
        // Nếu hết thời gian, xóa cờ
        z.isWeakened = false;
    }
    // ✨ KẾT THÚC KHỐI MÃ MỚI ✨

    return Math.max(1, Math.floor(totalDamage));
}
// Hàm xử lý sát thương vào zombie, tự động kiểm tra chết và hiệu ứng
function dealDamageToZombie(z, dmg = 1) {
  // --- BẮT ĐẦU SỬA LỖI ---
  // Làm tròn sát thương nhận vào và đảm bảo sát thương tối thiểu là 1
  const finalDamage = Math.max(1, Math.round(dmg));
  // --- KẾT THÚC SỬA LỖI ---

  z.hp -= finalDamage; // Trừ máu của zombie bằng sát thương đã làm tròn
  
  createDamageImpactEffect(z, finalDamage); // Hiển thị số sát thương đã làm tròn

  if (!z._killed && z.hp <= 0) {
    killZombie(z);
  }
}

// 🔪 Sword Pooling
function getSword() {
  return swordPool.length ? swordPool.pop() : {
    angle: 0,
    radius: 60,
    state: 'charging',
    chargeFrame: 90,
    x: 0,
    y: 0,
    target: null,
    fireDelay: 0,
    delay: 60
  };
}

function releaseSword(s) {
  swordPool.push(s);
}

// 🔥 Fireball Pooling
function getFireball() {
  return fireballPool.length ? fireballPool.pop() : {
    angle: 0,
    radius: 40,
    x: 0,
    y: 0
  };
}

function releaseFireball(f) {
  fireballPool.push(f);
}

// ❄️ Iceball Pooling
function getIceball() {
  return iceballPool.length ? iceballPool.pop() : {
    angle: 0,
    radius: 60,
    x: 0,
    y: 0
  };
}

function releaseIceball(i) {
  iceballPool.push(i);
}
// 🧊 Hiển thị cảnh báo tạm thời
function showWarning(message, customStyle = {}) {
  // 🔸 Tạo khay nếu chưa có
  const container = document.getElementById('notificationContainer')
        || (() => {
             const c = document.createElement('div');
             c.id = 'notificationContainer';
             document.body.appendChild(c);
             return c;
           })();

  // 🔸 Tạo popup
  const popup = document.createElement('div');
  popup.className  = 'warningPopup';
  popup.textContent = message;
  Object.assign(popup.style, customStyle);   // nếu cần đổi màu, v.v.

  container.appendChild(popup);

  /* Giới hạn tối đa N popup đồng thời */
  const MAX = 2;
  while (container.childElementCount > MAX) {
    container.firstElementChild.remove();
  }

  /* Tự xoá sau 1,5 s */
  setTimeout(() => popup.remove(), 1500);
}
/* ── Buffer gộp popup vật phẩm ─────────────────────────────── */
const lootBuffer  = {};     // { "⚡":3, "💠":2, "❤️":1 }
let   lootTimer   = null;   // id setTimeout

function queueLootPopup(icon, delay = 500) {
  lootBuffer[icon] = (lootBuffer[icon] || 0) + 1;

  clearTimeout(lootTimer);
  lootTimer = setTimeout(() => {
    const summary = Object.entries(lootBuffer)
                  .map(([ico,c]) => `${ico} x${c}`)
                  .join(', ');
    showWarning(`🐰 Pet nhặt: ${summary}`);
    Object.keys(lootBuffer).forEach(k => delete lootBuffer[k]);
  }, delay);
}
// Hàm bắn laze cho người chơi
function firePlayerLaser() {
    const now = Date.now();
    if (now - lastManualShootTime < manualShootCooldown) return; // Tuân thủ cooldown
    lastManualShootTime = now;

    if (zombies.length === 0) return;

    // 1. Tìm mục tiêu gần nhất
    const target = zombies.reduce((a, b) =>
        distance(a, player) < distance(b, player) ? a : b
    );
    const angle = Math.atan2(target.y - player.y, target.x - player.x);

    // 2. Tạo đối tượng laze để vẽ
    playerLasers.push({
        startX: player.x,
        startY: player.y,
        angle: angle,
        life: 20 // Thời gian tia laze tồn tại trên màn hình (20 frame)
    });

    // 3. Xử lý sát thương ngay khi bắn
    const laserPathTargets = [];
    const dx = Math.cos(angle);
    const dy = Math.sin(angle);

    // Tìm tất cả zombie trên đường bắn
    zombies.forEach(z => {
        if (z.active) {
            const proj = (z.x - player.x) * dx + (z.y - player.y) * dy;
            const perp = Math.abs((z.x - player.x) * dy - (z.y - player.y) * dx);
            if (proj > 0 && proj < 2000 && perp < 10) { // Tầm bắn 2000, độ rộng 10
                laserPathTargets.push(z);
            }
        }
    });

    if (laserPathTargets.length > 0) {
        // Sắp xếp để tìm mục tiêu gần nhất (mục tiêu đầu tiên)
        laserPathTargets.sort((a, b) => distance(player, a) - distance(player, b));
        const firstTarget = laserPathTargets[0];

        // Gây sát thương
        laserPathTargets.forEach(z => {
            let finalDamage;
            if (z === firstTarget) {
                // Mục tiêu đầu tiên nhận 100% sát thương
                finalDamage = playerUpgrades.damageBoost;
            } else {
                // Các mục tiêu phía sau nhận 50% sát thương
                finalDamage = Math.max(1, Math.round(playerUpgrades.damageBoost * 0.5));
            }
            dealDamageToZombie(z, finalDamage);
        });
    }
}
//🔫 4. Bắn đạn & auto shoot
function shoot() {
  const now = Date.now();
  if (now - lastManualShootTime < manualShootCooldown) return;
  lastManualShootTime = now;

  const directionCount = playerUpgrades.fireRate;
  const bulletsPerDirection = 1;
  const angleOffset = Math.random() * Math.PI * 2;
  const speed = playerUpgrades.bulletSpeed;

  for (let i = 0; i < directionCount; i++) {
    const angle = angleOffset + (2 * Math.PI / directionCount) * i;

    for (let j = 0; j < bulletsPerDirection; j++) {
      const b = getBullet();
      b.x = player.x;
      b.y = player.y;
      b.dx = Math.cos(angle);
      b.dy = Math.sin(angle);
      b.speed = speed;
      b.active = true;
      bullets.push(b);
    }
  }
}

function autoShootBurst() {
const now = Date.now();
let currentCooldown = autoShootCooldown; // Lấy cooldown gốc (1000ms)
if (supportAuraActive) {
    currentCooldown *= 0.8; // Giảm 20% thời gian chờ -> bắn nhanh hơn 20%
}
if (now - lastAutoShootTime >= currentCooldown) {
    lastAutoShootTime = now;
    autoBurstIndex = 0;
  }

  const bulletsPerDirection = playerUpgrades.lineBulletCount;
  if (autoBurstIndex >= bulletsPerDirection) return;
  if (now - autoLastBurstTime < autoBurstDelay) return;
  if (zombies.length === 0) return;

  const target = zombies.reduce((a, b) =>
    distance(a, player) < distance(b, player) ? a : b
  );
  const angle = Math.atan2(target.y - player.y, target.x - player.x);

  const b = getBullet();
  b.x = player.x;
  b.y = player.y;
  b.dx = Math.cos(angle);
  b.dy = Math.sin(angle);
  b.speed = playerUpgrades.bulletSpeed;
  b.active = true;
  bullets.push(b);
playSound('sfx-shoot', 0.01); // Thêm 0.2 để chỉ phát ở 20% âm lượng
  autoBurstIndex++;
  autoLastBurstTime = now;
}

//🔪 5. Kích hoạt kỹ năng (Kích hoạt kỹ năng & gán nút)
function activateSwordSkill() {
  if (swordActive) return;

  if (player.level < 1) return showWarning("🔪 Yêu cầu Lv1");
  if (player.energy < 3) return showWarning("🔪 Không đủ 3⚡");

  swordActive = true;
  swordEndTime = Date.now() + 60000;
  player.energy -= 3;
  document.getElementById("bladeBtn").classList.add("active");
  showWarning("🔪 Kích hoạt kỹ năng Đao xoay");
  // ✨ KHỞI TẠO BỘ ĐIỀU KHIỂN TẤN CÔNG
  lastBladeLaunchTime = Date.now();
  nextBladeToAttack = 0;

  swords = [];
  const count = skillUpgrades.bladeCount;
  for (let i = 0; i < count; i++) {
    const homeAngle = (2 * Math.PI / count) * i;
    swords.push({
      state: 'orbiting',
      angle: homeAngle,
      homeAngle: homeAngle,
      orbitRadius: 60,
      hitZombies: new Set(),
      pierceCount: 0,
      bladeIndex: i
    });
  }
}
// ⚔️ Kỹ năng mưa kiếm
function activateDownwardSwords() {
  if (bladeActive) return;

  if (player.level < 2) return showWarning("⚔️ Yêu cầu Lv2");
  if (player.energy < 6) return showWarning("⚔️ Không đủ 6⚡");

  bladeActive = true;
  bladeEndTime = Date.now() + 60000;
  player.energy -= 6;
  document.getElementById("swordBtn").classList.add("active");
  showWarning("⚔️ Kích hoạt kỹ năng Mưa kiếm");
  swordRainClouds = [];
  // Số lượng mây sẽ bằng cấp độ kỹ năng
  const cloudCount = skillUpgrades.swordLevel;
  
  for (let i = 0; i < cloudCount; i++) {
      // Dàn đều các đám mây theo chiều ngang màn hình
      const xPosition = (canvas.width / (cloudCount + 1)) * (i + 1);

      swordRainClouds.push({
          relativeX: xPosition,
          relativeY: 100 + (Math.random() - 0.5) * 20,
          driftSpeed: (Math.random() - 0.5) * 0.2,
          nextDropTime: Date.now() + Math.random() * 1000
      });
  }
}
// Kích hoạt kỹ năng PET – Thỏ màu hồng
function activatePet() {
  petActive       = true;                      // nay chắc chắn chưa hoạt động
  petEndTime      = Date.now() + 60000;        // 60 s
  petLastHealTime = Date.now();

  petRabbit = {                                // speed tính động mỗi frame
    x      : player.x + 40,
    y      : player.y,
    radius : 14,
    attackTimer: 0
  };

  const btn        = document.getElementById("PetBtn");
  btn.innerText    = lastPetText;
  btn.classList.add("active");

  showWarning("🐰 Pet thỏ đã ra trận!");
}
// 🖱 Gán sự kiện nút
// 🔪 Kỹ năng Đao
document.getElementById("bladeBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 1) return showWarning("🔪 Yêu cầu Lv1");
  if (player.energy < 5) return showWarning("🔪 Không đủ 3⚡");
  activateSwordSkill();
};
// ⚔️ Kỹ năng Kiếm
document.getElementById("swordBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 2) return showWarning("⚔️ Yêu cầu Lv2");
  if (player.energy < 6) return showWarning("⚔️ Không đủ 6⚡");
  activateDownwardSwords();
};
// 🔥 Kỹ năng Lửa
document.getElementById("fireBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 3) return showWarning("🔥 Yêu cầu Lv3");
  if (player.energy < 8) return showWarning("🔥 Không đủ 8⚡");
  if (!fireActive) {
    fireActive = true;
    fireballs.length = 0;
    const fireCount = skillUpgrades.fireCount;
    for (let i = 0; i < fireCount; i++) {
      const angle = (2 * Math.PI / fireCount) * i;
      const f = getFireball();
      f.angle = angle;
      f.radius = 40;
      f.x = player.x + Math.cos(angle) * 40;
      f.y = player.y + Math.sin(angle) * 40;
      fireballs.push(f);
    }
    fireEndTime = Date.now() + 60000;
    player.energy -= 8;
    document.getElementById("fireBtn").classList.add("active");
    showWarning("🔥 Kích hoạt kỹ năng Lửa");

  }
};
// ❄️ Kỹ năng Băng
document.getElementById("iceBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 3)   return showWarning("❄️ Yêu cầu Lv3");
  if (player.energy < 12) return showWarning("❄️ Không đủ 12⚡");
  if (!iceActive) {
    iceActive  = true;
    iceballs.length = 0;                    // xoá vòng cũ
    const iceCount = skillUpgrades.iceCount;
    for (let i = 0; i < iceCount; i++) {
      const angle = (2 * Math.PI / iceCount) * i;
      const b     = getIceball();
      b.angle  = angle;
      b.radius = 50;
      b.x = player.x + Math.cos(angle) * 60;
      b.y = player.y + Math.sin(angle) * 60;
      iceballs.push(b);
    }
    iceEndTime      = Date.now() + 60000;   // 60 s hiệu lực
    player.energy  -= 12;                   // trừ năng lượng đúng 1 lần
    document.getElementById("iceBtn").classList.add("active");
    showWarning("❄️ Kích hoạt kỹ năng Băng");
  }
};
// === Kỹ năng LÔI ===
document.getElementById("thunderBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 5) return showWarning("🔵 Yêu cầu Lv5");
  if (player.energy < 18) return showWarning("🔵 Không đủ 18⚡");
  if (!thunderActive) {
    thunderActive = true;
    thunderBalls.length = 0;
    const thunderCount = skillUpgrades.thunderCount;
    for (let i = 0; i < thunderCount; i++) {
      const angle = (2 * Math.PI / thunderCount) * i;
      thunderBalls.push({
        angle,
        radius: 50,
        x: player.x + Math.cos(angle) * 70,
        y: player.y + Math.sin(angle) * 70,
        stunCooldown: 0,
        nextZapTime: Date.now() + Math.random() * 1500
      });
    }
    thunderEndTime = Date.now() + 60000;
    player.energy -= 18;
    document.getElementById("thunderBtn").classList.add("active");
    showWarning("❄️ Kích hoạt kỹ năng Lôi");
  }
};
// Auto bắn
document.getElementById("autoBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  autoShoot = !autoShoot;
  const btn = document.getElementById("autoBtn");
  if (autoShoot) {
    btn.classList.add("active");
    showWarning("🔫 Kích hoạt auto");
  } else {
    btn.classList.remove("active");
    showWarning("🔫 Tắt auto!");
  }
};
// 🐰 Kỹ năng Pet
document.getElementById("PetBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (petActive) return;                       // đang có thỏ → bỏ
  if (player.energy < 5) {
    showWarning("🐰 Không đủ 5 ⚡");
    return;
  }
  activatePet();                               // kích hoạt thành công
  player.energy -= 5;                          // trừ ⚡ duy nhất 1 lần
};
// ✨ Kỹ năng Hào quang
document.getElementById("supportAuraBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
    if (player.level < 6) return showWarning("✨ Yêu cầu Lv6");
    if (player.energy < 15) return showWarning("✨ Không đủ 15⚡");
    
    if (!supportAuraActive) {
        supportAuraActive = true;
        supportAuraEndTime = Date.now() + 60000;
        player.energy -= 15;
        showWarning("✨ Kích hoạt Hào quang!");
        document.getElementById("supportAuraBtn").classList.add("active");

        // Tạo hiệu ứng các đường nứt
        auraCrackLines = [];
        const crackCount = 30;
        const radius = 45;

        for (let i = 0; i < crackCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distFromCenter = Math.random() * radius;
            const length = 5 + Math.random() * 10;
            
            const x1 = Math.cos(angle) * distFromCenter;
            const y1 = Math.sin(angle) * distFromCenter;
            const x2 = x1 + Math.cos(angle) * length;
            const y2 = y1 + Math.sin(angle) * length;

            auraCrackLines.push({ x1, y1, x2, y2 });
        }
    }
};
// 🦋 Kích hoạt kỹ năng Fairy activateFairySkill
document.getElementById("fairyBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 7) return showWarning("🦋 Yêu cầu Lv7");
  if (player.energy < 25) return showWarning("🦋 Không đủ 25⚡");
  if (fairyActive) return; // Không kích hoạt nếu đang trong thời gian hồi

  fairyActive = true;
  fairyEndTime = Date.now() + 60000;
  player.energy -= 25;
  fairyDeathDefyAvailable = true; // Kích hoạt khả năng hồi sinh

  // Tạo các Fairy dựa trên cấp độ nâng cấp
  fairies = [];
  const count = skillUpgrades.fairyCount;
  for (let i = 0; i < count; i++) {
    fairies.push({
      angle: (2 * Math.PI / count) * i,
      orbitRadius: 50 + (i * 10), // Các Fairy bay ở quỹ đạo khác nhau
      bobOffset: Math.random() * Math.PI * 2, // Hiệu ứng nhấp nhô riêng
      nextAttackTime: Date.now() + Math.random() * 2000
    });
  }

  showWarning("🦋 Triệu hồi Fairy!");
};

//🧟 6. Sinh zombie và boss
// 🎨 Màu tương ứng cho zombie cấp 1 → 10
const zombieColorsByLevel = [
  "#00cc66", // Level 1 – Xanh lá sáng (nhẹ nhàng)
  "#3399ff", // Level 2 – Xanh dương (nhạt hơn boss)
  "#ffcc00", // Level 3 – Vàng sáng
  "#ff9900", // Level 4 – Cam
  "#ff3333", // Level 5 – Đỏ sáng
  "#cc00cc", // Level 6 – Tím
  "#9933ff", // Level 7 – Tím xanh điện
  "#ff66cc", // Level 8 – Hồng neon
  "#00ffff", // Level 9 – Xanh cyan
  "#ffffff"  // Level 10 – Trắng sáng chói (gần max)
];

// 📊 Bảng xác suất cấp độ zombie theo từng wave
/**
 * Tính toán cấp độ (sức mạnh) của zombie, cho phép cả 10 loại xuất hiện với tỉ lệ thay đổi theo wave.
 * @param {number} wave - Số wave hiện tại.
 * @returns {number} Cấp độ của zombie (dưới dạng index từ 0 đến 9).
 */
function getZombieLevelByWave(wave) {
    // Wave 1 vẫn luôn là wave khởi động với zombie yếu nhất.
    if (wave === 1) {
        return 0;
    }

    const MAX_ZOMBIE_LEVEL = 9; // Có 10 cấp độ, từ index 0 đến 9.

    // 1. Xác định "trọng tâm độ khó" cho wave hiện tại.
    // Con số này sẽ tăng dần khi wave tăng, quyết định loại zombie nào sẽ phổ biến nhất.
    const centerLevel = (wave - 2) * 0.4;

    // 2. Xác định "độ đa dạng". Con số này càng lớn, các loại zombie xa trọng tâm càng có cơ hội xuất hiện.
    const spread = 2.0 + (wave / 20);

    const weights = [];
    let totalWeight = 0;

    // 3. Vòng lặp qua tất cả 10 cấp độ zombie (0 đến 9) để tính trọng số (tỉ lệ xuất hiện).
    for (let i = 0; i <= MAX_ZOMBIE_LEVEL; i++) {
        // Công thức này tính toán trọng số dựa trên mô hình đường cong Chuẩn (Gaussian curve).
        // Zombie có cấp độ càng gần "trọng tâm độ khó" thì trọng số càng cao, tỉ lệ xuất hiện càng lớn.
        // Ngay cả ở wave cao, zombie cấp thấp vẫn có một trọng số rất nhỏ (nhưng khác 0).
        const distance = i - centerLevel;
        const weight = Math.exp(-(distance * distance) / (2 * spread * spread));
        
        weights.push({ level: i, weight: weight });
        totalWeight += weight;
    }

    // 4. Chọn ngẫu nhiên một cấp độ dựa trên các trọng số đã tính.
    const rand = Math.random() * totalWeight;
    let weightSum = 0;
    for (const item of weights) {
        weightSum += item.weight;
        if (rand < weightSum) {
            return item.level;
        }
    }

    return MAX_ZOMBIE_LEVEL; // Dự phòng nếu có lỗi xảy ra.
}
// Khởi tạo Zombie
function spawnZombie() {
  const z = getZombie();
    // ✨ GÁN CHỦNG LOÀI NGẪU NHIÊN ✨
  z.style = zombieTypes[Math.floor(Math.random() * zombieTypes.length)];
  const level = getZombieLevelByWave(wave); // cấp từ 0–9
// HP zombie tăng theo level player + random 1~10
// --- BẮT ĐẦU PHẦN TÍNH HP CẢI TIẾN ---

    // Kiểm tra xem có phải là wave đầu tiên không.
    // Wave 1 sẽ có cách tính HP đặc biệt để giúp người chơi dễ khởi đầu.
    if (wave === 1) {
        
        // Gán HP cho zombie là một số nguyên ngẫu nhiên từ 1 đến 4.
        // Math.random() * 4 -> tạo số thập phân ngẫu nhiên từ 0 đến 3.99...
        // Math.floor(...)   -> làm tròn xuống (0, 1, 2, hoặc 3)
        // ... + 1           -> kết quả cuối cùng là 1, 2, 3, hoặc 4.
        z.hp = Math.floor(Math.random() * 4) + 1;

    } else {
        
        // Nếu không phải wave 1 (tức là từ wave 2 trở đi), áp dụng công thức tính HP phức tạp hơn.
        // Cấu hình các chỉ số cơ bản để tính toán HP.
        const HP_CONFIG = {
            BASE_HP: 1,                  // HP tối thiểu của một zombie.
            HP_PER_ZOMBIE_LEVEL: 5,      // Lượng HP được cộng thêm cho mỗi cấp của zombie.
            HP_PER_WAVE: 2.5,            // Lượng HP được cộng thêm cho mỗi wave (độ khó tăng dần).
            RANDOM_VARIANCE: 0.20,       // Tỉ lệ ngẫu nhiên (+/- 20%) để HP của zombie đa dạng hơn.
            ELITE_CHANCE: 0.05,          // 5% tỉ lệ xuất hiện zombie Tinh Anh.
            ELITE_HP_MULTIPLIER: 5       // Zombie Tinh Anh sẽ có lượng HP nhân lên 5 lần.
        };

        // Tính toán HP cơ bản trước khi thêm yếu tố ngẫu nhiên.
        // Công thức = HP gốc + HP thưởng theo cấp zombie + HP thưởng theo wave.
        // (wave - 1) được dùng để đảm bảo việc cộng HP theo wave chỉ bắt đầu từ wave 2.
        let calculatedHp = HP_CONFIG.BASE_HP +
                           (level * HP_CONFIG.HP_PER_ZOMBIE_LEVEL) +
                           ((wave - 1) * HP_CONFIG.HP_PER_WAVE);

        // Thêm yếu tố ngẫu nhiên vào HP đã tính.
        const variance = calculatedHp * HP_CONFIG.RANDOM_VARIANCE; // Tính toán lượng HP có thể thay đổi (+/- 20%).
        calculatedHp += Math.random() * variance * 2 - variance;   // Cộng/trừ ngẫu nhiên trong khoảng đó.

        // Kiểm tra xem zombie có phải là loại Tinh Anh (Elite) hay không.
        if (Math.random() < HP_CONFIG.ELITE_CHANCE) { // Nếu số ngẫu nhiên nhỏ hơn 0.05 (5%)
            calculatedHp *= HP_CONFIG.ELITE_HP_MULTIPLIER; // Nhân HP lên 5 lần.
            z.isElite = true; // Đánh dấu đây là zombie Tinh Anh.
        } else {
            z.isElite = false; // Đánh dấu đây là zombie thường.
        }

        // Gán HP cuối cùng cho zombie, làm tròn và đảm bảo không bao giờ nhỏ hơn 1.
        z.hp = Math.max(1, Math.round(calculatedHp));
    }

    // --- KẾT THÚC PHẦN TÍNH HP ---

    // Lưu lại lượng HP ban đầu của zombie để dùng cho các logic khác nếu cần.
    z.baseHp = z.hp;
    z.level = level + 1; // cấp thật từ 1–10
    z.behaviorCheckCounter = 0; // Khởi tạo bộ đếm chu kỳ hành vi
    z.showStatusIcon = Math.random() < 0.3; // Gán ngẫu nhiên có hiển thị icon hay không lần đầu tiên
    z.lastDayBuffed = currentDay;
    z.isBuffed = false;
    z.nightBuffApplied = false;
    z.lastRegenTime = Date.now();

// 👣 Di chuyển ngẫu nhiên ban đầu
  z.state = "wandering";
  z.nextStateCheck = Date.now() + 3000; // kiểm tra mỗi 3s khi đang chasing - kiểm tra mỗi giây
  z.wanderTime = Date.now() + 2000 + Math.random() * 2000; // từ 2 đến 4 giây
  z.wanderAngle = Math.random() * Math.PI * 2;
// 🎲 Chọn kiểu wander: 80% di chuyển, 20% đứng im
  z.wanderBehavior = Math.random() < 0.2 ? "pause" : "move";
  z.baseSpeed = 0.2 + Math.random() * 0.8; // tốc độ khi chasing - tốc độ khi đuổi theo
  z.speed = 0.15 + Math.random() * 0.5;   // tốc độ khi wandering - tốc độ khi lang thang
  z.color = zombieColorsByLevel[level];
  z.type = "normal";
  z.radius = 15;
  z.isBoss = false;

// 🎯 Random mini boss (xuất hiện 2%) - Tỷ lệ xuất hiện mini boss
if (Math.random() < 0.02) {
  z.type = "miniBoss";
  // HP mini boss tăng theo wave và level player
  z.hp = 50 + wave + Math.floor(player.level / 2) + Math.floor(Math.random() * 20 + 1); 
  z.color = bossColors[Math.floor(Math.random() * bossColors.length)]; // Màu mini boss
  z.radius = 18;
  z.level = 99; // Đánh dấu riêng để không tính cấp thường
}

// 📍 Tạo zombie ngẫu nhiên bên trong bản đồ
z.x = Math.random() * worldWidth;
z.y = Math.random() * worldHeight;
// 📍 Đặt zombie
  zombies.push(z);
  zombieSpawnedCount++;
}

// Màu boss
const bossColors = [
  "#ff3333", // Đỏ tươi
  "#ff8800", // Cam rực
  "#ffaa00", // Vàng cam
  "#00ccff", // Xanh dương sáng
  "#9933ff", // Tím đậm
  "#00ff99", // Xanh ngọc
  "#ff66cc", // Hồng neon
  "#ffffff", // Trắng lạnh
  "#888888", // Xám tro (boss máy móc)
  "#00ffff"  // Xanh cyan ánh kim
];

function spawnBoss(spawnX, spawnY) { // Thêm 2 tham số vị trí
  const z = getZombie();

  // NẾU CÓ VỊ TRÍ CỤ THỂ -> TẠO BOSS TẠI ĐÓ
  if (spawnX !== undefined && spawnY !== undefined) {
      z.x = spawnX;
      z.y = spawnY;
  } else {   // 📍 ➊ Chọn vị trí ngẫu nhiên trong world
  // (worldWidth / worldHeight đã dùng cho zombie thường)
  do {
    z.x = Math.random() * worldWidth;
    z.y = Math.random() * worldHeight;
    // 📏 ➋ Bảo đảm không “úp sọt” player
  } while (distance(z, player) < 250); // ≥ 250 px mới cho xuất hiện
  }
  z.radius = 30;
  z.canHit = true;
  z.baseSpeed = 0.015 + Math.random() * 0.2; // Lưu tốc độ gốc | Tốc độ boss
  z.speed = z.baseSpeed; // Tốc độ zombie
  z.isBoss = true;
  // HP boss tăng theo wave và level player + random 1~100
  z.hp = 500 + wave * 2 + Math.floor(player.level / 2) + Math.floor(Math.random() * 100 + 1);
  z.baseHp = z.hp; // 🔑 Ghi nhớ HP gốc để reset ban ngày
  z.type = "boss";
  z.level = 100; // level Boss
  z.color = bossColors[Math.floor(Math.random() * bossColors.length)]; // Màu boss
  z.active = true;
  z.state = "chasing";
  zombies.push(z);
  zombieSpawnedCount++;
  z.lastDayBuffed = currentDay;
  z.isBuffed = false;
  z.nightBuffApplied = false;
  z.lastRegenTime = Date.now();
}
// Hàm sinh Big Boss 👹 – boss mạnh nhất
function spawnBigBoss() {
    const z = getZombie();
    z.active = true; // reset lại chắc chắn
    z.state = "chasing";
    z._killed = false;

    do {
        z.x = Math.random() * worldWidth;
        z.y = Math.random() * worldHeight;
    } while (distance(z, player) < 250); // tránh sinh gần player

    z.radius = 120; // Kích thước bigboss
    z.baseSpeed = 0.01 + Math.random() * 0.2;
    z.speed = z.baseSpeed;
    z.isBoss = true;
    z.isBigBoss = true; // 🔑 Đánh dấu riêng bigBoss
    z.hp = 10000 + wave * 500 + Math.floor(Math.random() * 1000 + 250);
    z.baseHp = z.hp;
    z.type = "bigBoss";
    z.level = 999;
    z.color = "purple"; // Đổi màu để dễ phân biệt
    z.active = true;
z.lazerTimer = 0;
z.isLazerAttacking = false;
z.lazerDuration = 0;
    zombies.push(z);
    zombieSpawnedCount++;
    z.lastDayBuffed = currentDay;
    z.isBuffed = false;
    z.nightBuffApplied = false;
    z.lastRegenTime = Date.now();
}

//🧠 7. Cập nhật UI – chỉ DOM
// 🧟 Hàm cập nhật Wave riêng biệt (dùng khi wave thay đổi)
function updateWaveUI() {
  document.getElementById("score-bottom").innerText = 
  `Level: ${player.level.toString().padStart(4, '0')} |⚡: ${player.energy.toString().padStart(4, '0')}`;
  setTimeout(() => {
  document.getElementById("waveNumberDisplay").innerText = `Wave: ${wave}`;
}, 1000); // ⏱️ hiển thị sau 1 giây
  document.getElementById("ui-mana").innerText = `💠 Mana: ${player.mana}`;
}
// DOM chỉ cập nhật khi giá trị thay đổi
let lastScore = -1, lastLevel = -1, lastEnergy = -1, lastHearts = -1, lastHighScore = -1; let lastMana = -1;
let lastBladeText = "", lastSwordText = "", lastFireText = "", lastIceText = "", lastFpsText = "", lastPetText = "";
let lastDay = -1, lastCoins = -1, lastExp = -1;
// Hàm cập nhật toàn bộ Giao diện Người dùng (UI), chỉ thực hiện khi có giá trị thay đổi để tối ưu hiệu suất
function updateUI() {
    // --- CẬP NHẬT CÁC THÔNG TIN PHỤ ---

    // Cập nhật hiển thị ngày, chỉ khi ngày thay đổi
    if (currentDay !== lastDay) {
        document.getElementById('dayCounterDisplay').innerText = `Ngày: ${currentDay}`;
        lastDay = currentDay;
    }

    // Cập nhật Kỷ lục (High Score) bằng player.score (số kill)
    const highScore = parseInt(localStorage.getItem('highScore') || '0');
    if (player.score > highScore) {
        localStorage.setItem('highScore', player.score);
    }
    // Chỉ cập nhật DOM khi giá trị high score thực sự thay đổi
    if (highScore !== lastHighScore) {
        document.getElementById("highScoreDisplay").innerText = `🏆 Kỷ lục: ${highScore}`;
        lastHighScore = highScore;
    }
    
    // --- CẬP NHẬT THANH TRẠNG THÁI CHÍNH ---

    // Cập nhật hiển thị tiến trình EXP và HP
    const scoreTopDiv = document.getElementById("score-top");
    const required = player.requiredExp;
    const current = player.currentLevelExp;
    const remaining = required - current;

    // Tạo chuỗi text mới cho EXP và HP
    const newExpText = `Exp: ${current.toString().padStart(4, '0')} |❤️: ${player.hearts.toString().padStart(4, '0')}`;
    // Chỉ cập nhật DOM nếu text thay đổi để tránh reflow không cần thiết
    if (scoreTopDiv.innerText !== newExpText) {
        scoreTopDiv.innerText = newExpText;
    }
    
    // Cập nhật tooltip với lượng EXP còn lại
    const newTooltip = `Exp cấp tiếp theo: ${remaining}`;
    if (scoreTopDiv.dataset.tooltip !== newTooltip) {
        scoreTopDiv.dataset.tooltip = newTooltip;
    }

    // Cập nhật hiển thị số xu
    if (player.coins !== lastCoins) {
        const formattedCoins = player.coins.toString().padStart(4, '0');
        document.getElementById('coinCounterDisplay').innerText = `🪙: ${formattedCoins}`;
        lastCoins = player.coins;
    }

    // Cập nhật hiển thị Level và Energy
    if (player.level !== lastLevel || player.energy !== lastEnergy) {
        lastLevel = player.level;
        lastEnergy = player.energy;
        updateWaveUI(); // Gọi hàm con để cập nhật text cho Level và Energy
    }

    // Cập nhật hiển thị Mana
    if (player.mana !== lastMana) {
        lastMana = player.mana;
        document.getElementById("ui-mana").innerText = `💠 Mana: ${player.mana}`;
    }

    // --- CẬP NHẬT HIỂN THỊ CÁC BUFF TẠM THỜI ---
    
    // Cập nhật hiển thị cho buff Lucky
    const luckyDisplay = document.getElementById('luckyBuffDisplay');
    if (Date.now() < luckyBuffEndTime) {
        luckyDisplay.classList.remove('inactive');
        luckyDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((luckyBuffEndTime - Date.now()) / 1000);
        luckyDisplay.innerHTML = `🍀 LuckyUp: <span>${timeLeft}</span>s`; // Sửa tên
    } else {
        luckyDisplay.classList.add('inactive');
        luckyDisplay.classList.remove('active-glow');
        luckyDisplay.innerHTML = `🍀 LuckyUp: <span>---</span>`; // Sửa tên
    }

    // Cập nhật hiển thị cho buff Power
    const powerDisplay = document.getElementById('powerBuffDisplay');
    if (Date.now() < powerBuffEndTime) {
        powerDisplay.classList.remove('inactive');
        powerDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((powerBuffEndTime - Date.now()) / 1000);
        powerDisplay.innerHTML = `🍁 PowerUp: <span>${timeLeft}</span>s`; // Sửa tên
    } else {
        powerDisplay.classList.add('inactive');
        powerDisplay.classList.remove('active-glow');
        powerDisplay.innerHTML = `🍁 PowerUp: <span>---</span>`; // Sửa tên
    }
    
    // Cập nhật hiển thị cho buff Crazy
    const crazyDisplay = document.getElementById('crazyBuffDisplay');
    if (Date.now() < crazyBuffEndTime) {
        crazyDisplay.classList.remove('inactive');
        crazyDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((crazyBuffEndTime - Date.now()) / 1000);
        crazyDisplay.innerHTML = `🍂 CrazyUp: <span>${timeLeft}</span>s`; // Sửa tên
    } else {
        crazyDisplay.classList.add('inactive');
        crazyDisplay.classList.remove('active-glow');
        crazyDisplay.innerHTML = `🍂 CrazyUp: <span>---</span>`; // Sửa tên
    }

    // Cập nhật hiển thị cho buff ExpUp (MỚI)
    const expDisplay = document.getElementById('expBuffDisplay');
    if (Date.now() < expBuffEndTime) {
        expDisplay.classList.remove('inactive');
        expDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((expBuffEndTime - Date.now()) / 1000);
        expDisplay.innerHTML = `🌿 ExpUp: <span>${timeLeft}</span>s`;
    } else {
        expDisplay.classList.add('inactive');
        expDisplay.classList.remove('active-glow');
        expDisplay.innerHTML = `🌿 ExpUp: <span>---</span>`;
    }
    const magnetDisplay = document.getElementById('magnetBuffDisplay');
    if (Date.now() < magnetBuffEndTime) {
        magnetDisplay.classList.remove('inactive');
        magnetDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((magnetBuffEndTime - Date.now()) / 1000);
        magnetDisplay.innerHTML = `🧲 Magnet: <span>${timeLeft}</span>s`;
    } else {
        magnetDisplay.classList.add('inactive');
        magnetDisplay.classList.remove('active-glow');
        magnetDisplay.innerHTML = `🧲 Magnet: <span>---</span>`;
    }
    
}

// 🧿 Tìm zombie còn sống gần player nhất 
function findActiveZombie() {
  return zombies.find(z => z.active);
}

/* ───────────────────────────────────────
   🐰 CẬP NHẬT PET – GỌI MỖI FRAME
   ─────────────────────────────────────── */
function updatePet() {
  const now = Date.now();
  if (!petActive || !petRabbit) return;

  /* hằng số */
  const DIST_ITEM    = 360;
  const DIST_FOLLOW  = 480;
  const TOLERANCE    = 40;
  const PICK_DIST    = 16;
  const GIVE_UP_MS   = 3000;
  const MIN_PROGRESS = 20;    // phải tiến ≥20 px sau 3 s

  /* tốc độ pet */
  petRabbit.speed = (player.speed ?? 1) + 0.4;

  /* 0. quay về nếu xa player quá */
  if (distance(petRabbit, player) > DIST_FOLLOW) {
    moveTowards(petRabbit, player, petRabbit.speed * 1.6);
    petRabbit.target = null;
    return;
  }

  /* 1. chọn mục tiêu mới */
  if (!petRabbit.target || !petRabbit.target.active) {
    petRabbit.target = items
      .filter(it => {
        if (!it.active) return false;
        if (distance(petRabbit, it) > DIST_ITEM) return false;
        /* cấm chọn lại item vừa bỏ trong 2 s */
        if (it.id === lastGiveUpId &&
            Date.now() - lastGiveUpTime < RESELECT_CD) return false;
        return true;
      })
      .sort((a, b) => distance(petRabbit, a) - distance(petRabbit, b))[0] || null;

    if (petRabbit.target) {
      petRabbit.chaseStart    = Date.now();
      petRabbit.startDistance = distance(petRabbit, petRabbit.target);
    }
  }

  /* 2. đuổi & nhặt */
  if (petRabbit.target) {
    const dNow     = distance(petRabbit, petRabbit.target);
    const elapsed  = Date.now() - petRabbit.chaseStart;
    const progress = petRabbit.startDistance - dNow;

    /* bỏ nếu >3 s mà tiến <20 px */
    if (elapsed > GIVE_UP_MS && progress < MIN_PROGRESS) {
      giveUp();
      return;
    }

    /* bỏ nếu mục tiêu lại quá xa player */
    if (distance(player, petRabbit.target) > DIST_FOLLOW) {
      giveUp();
      return;
    }

    moveTowards(petRabbit, petRabbit.target, petRabbit.speed);

    if (dNow < PICK_DIST) collectLoot();
  }
    /* 3. bám player khi không có mục tiêu */
    else if (distance(petRabbit, player) > TOLERANCE) {
        moveTowards(petRabbit, player, petRabbit.speed * 1.2);
    }

    // ✨ BẮT ĐẦU LOGIC TẤN CÔNG ĐẾM NGƯỢC MỚI ✨
    // 1. Đếm ngược thời gian hồi chiêu
    if (petRabbit.attackTimer > 0) {
        petRabbit.attackTimer -= 1000 * globalDeltaTime; // Trừ đi thời gian của frame vừa qua
    }

    // 2. Nếu đã hết thời gian hồi, tìm mục tiêu và tấn công
    if (petRabbit.attackTimer <= 0) {
        const target = zombies
            .filter(z => z.active)
            .sort((a, b) => distance(petRabbit, a) - distance(petRabbit, b))[0];

        if (target) {
            // 3. Đặt lại thời gian hồi chiêu SAU KHI đã bắn
            petRabbit.attackTimer = 1000; // <-- Hồi chiêu 1 giây (1000ms)

            const b = getBullet();
            b.x = petRabbit.x;
            b.y = petRabbit.y;
            
            const angle = Math.atan2(target.y - petRabbit.y, target.x - petRabbit.x);
            b.dx = Math.cos(angle);
            b.dy = Math.sin(angle);
            
            b.isPetBullet = true;
            b.icon = '🥕';
            b.speed = 2;
            b.stunDuration = 1000;
            b.customDmg = 1 + (wave - 1) + (player.level - 1);
            
            bullets.push(b);
        }
    }
    // ✨ KẾT THÚC LOGIC TẤN CÔNG ✨

    // Hồi máu và hết giờ (giữ nguyên)
    if (now - petLastHealTime >= 3000) {
        petLastHealTime = now;
        player.hearts++;
        createHealImpactEffect(player, 1);
    }
    if (now >= petEndTime) {
        petActive = false;
        petRabbit = null;
        showWarning("🐰 Pet đã rời đi.");
    }
}

/* ───────── helpers ───────── */
function moveTowards(obj, target, spd) {
  const ang = Math.atan2(target.y - obj.y, target.x - obj.x);
  obj.x += Math.cos(ang) * spd;
  obj.y += Math.sin(ang) * spd;
}
// Pet nhặt vật phẩm
function collectLoot() {
  playSound('sfx-pickup', 0.5); // Phát âm thanh nhặt vật phẩm
  const t = petRabbit.target; // 't' chính là đối tượng vật phẩm mà Pet nhặt được
  switch (t.type) {
    case "lucky": luckyBuffEndTime = Date.now() + 45000; queueLootPopup("🍀"); playSound('sfx-powerup', 0.8); break;
    case "power": powerBuffEndTime = Date.now() + 45000; queueLootPopup("🍁"); playSound('sfx-powerup', 0.8); break;
    case "crazy": crazyBuffEndTime = Date.now() + 45000; queueLootPopup("🍂"); playSound('sfx-powerup', 0.8); break;
    case "exp": expBuffEndTime = Date.now() + 45000; queueLootPopup("🌿"); playSound('sfx-powerup', 0.8); break;
    case "magnet":
        // THÊM LOGIC MỚI: Chỉ kích hoạt buff nếu nó chưa hoạt động
        if (Date.now() > magnetBuffEndTime) {
            magnetBuffEndTime = Date.now() + 30000;
            queueLootPopup("🧲");
            playSound('sfx-powerup', 0.8);
        }
        // Nếu buff đang hoạt động, Pet nhặt thêm cũng không có tác dụng
        break;
    case "potion":
    const baseHeal = getRandomInt(10, 20);
    const bonusHeal = Math.round((player.level + wave) * 1.5);
    const totalHeal = baseHeal + bonusHeal;
    player.hearts += totalHeal;
    createHealImpactEffect(player, totalHeal);
    queueLootPopup("💊");
    playSound('sfx-powerup', 0.8);
    break;
    case "secret":   activateSecretItem(t); queueLootPopup("❓"); playSound('sfx-powerup', 0.8); break;
    case "expBonus": activateExpBonusItem(); queueLootPopup("🌟"); playSound('sfx-powerup', 0.8); break;
    case "coin":   player.coins++;  queueLootPopup("🪙"); playSound('sfx-pickup-coin', 0.5); break;
    case "energy": player.energy++; queueLootPopup("⚡"); break;
    case "mana":   player.mana++;   queueLootPopup("💠"); break;
    case "hp":     player.hearts++; queueLootPopup("❤️"); break;
    case "box":    openItemBox(); break;
  }
  t.active = false;
  petRabbit.target = null;
}

function giveUp() {
  lastGiveUpId   = petRabbit.target.id;   // ghi nhớ id
  lastGiveUpTime = Date.now();
  petRabbit.target = null;
  showWarning("🐰 đừng đi xa, quay về!");
}
// Cập nhật kỹ năng đao xoay
function updateBlades() {
    if (!swordActive) return;

    const now = Date.now();
    const MAX_SEEK_RADIUS = 450;
    const BLADE_FLY_SPEED = 4;
    const BLADE_LAUNCH_INTERVAL = 100;

    if (now - lastBladeLaunchTime > BLADE_LAUNCH_INTERVAL) {
        const bladeToLaunch = swords[nextBladeToAttack];
        if (bladeToLaunch && bladeToLaunch.state === 'orbiting') {
            const target = zombies.find(z => z.active && distance(player, z) < MAX_SEEK_RADIUS);
            if (target) {
                bladeToLaunch.state = 'seeking';
                bladeToLaunch.hitZombies.clear();
                bladeToLaunch.pierceCount = 0;
            }
        }
        nextBladeToAttack = (nextBladeToAttack + 1) % swords.length;
        lastBladeLaunchTime = now;
    }

    const formationAngle = (now / 1500);
    swords.forEach(s => {
        switch (s.state) {
            case 'orbiting':
                s.angle = s.homeAngle + formationAngle;
                s.x = player.x + Math.cos(s.angle) * s.orbitRadius;
                s.y = player.y + Math.sin(s.angle) * s.orbitRadius;
                
                zombies.forEach(z => {
                    if (z.active && distance(s, z) < 20 && (!z.bladeOrbitCooldown || now > z.bladeOrbitCooldown)) {
                        // SỬA LỖI: Làm tròn sát thương khi đao đang xoay quanh
                        const orbitingDamage = Math.max(1, Math.round(skillUpgrades.bladeDamage));
                        dealDamageToZombie(z, orbitingDamage);
                        z.bladeOrbitCooldown = now + 100;
                    }
                });
                break;

            case 'seeking':
                let nearestTarget = null;
                let minDistance = Infinity;
                zombies.forEach(z => {
                    if (z.active && !s.hitZombies.has(z)) {
                        const d = distance(s, z);
                        if (d < minDistance) { minDistance = d; nearestTarget = z; }
                    }
                });
                if (nearestTarget) {
                    const angle = Math.atan2(nearestTarget.y - s.y, nearestTarget.x - s.x);
                    s.x += Math.cos(angle) * BLADE_FLY_SPEED;
                    s.y += Math.sin(angle) * BLADE_FLY_SPEED;
                }
                zombies.forEach(z => {
                    if (z.active && !s.hitZombies.has(z) && distance(s, z) < 20) {
                        const originalDamage = skillUpgrades.bladeDamage + playerUpgrades.damageBoost;
                        let finalDamage;

                        if (s.pierceCount === 0) {
                            // SỬA LỖI: Làm tròn sát thương cho mục tiêu đầu tiên
                            finalDamage = Math.max(1, Math.round(originalDamage));
                        } else {
                            // Dòng này đã làm tròn sẵn cho các mục tiêu phía sau
                            finalDamage = Math.max(1, Math.round(originalDamage * 0.5));
                        }

                        dealDamageToZombie(z, finalDamage);
                        
                        s.hitZombies.add(z);
                        s.pierceCount++;
                        const impactExplosion = getExplosion(z.x, z.y);
                        impactExplosion.life = 10;
                        explosions.push(impactExplosion);
                    }
                });
                if (s.pierceCount >= 5 || distance(s, player) > MAX_SEEK_RADIUS || !nearestTarget) {
                    s.state = 'returning';
                }
                break;

            case 'returning':
                const angleToPlayer = Math.atan2(player.y - s.y, player.x - s.x);
                s.x += Math.cos(angleToPlayer) * 10;
                s.y += Math.sin(angleToPlayer) * 10;
                if (distance(s, player) < s.orbitRadius) {
                    s.state = 'orbiting';
                }
                break;
        }
    });
}
// --- BẮT ĐẦU: CÁC HÀM XỬ LÝ SỰ KIỆN TIẾP TẾ ---

/** Tạo ra 3-5 kiện hàng 🪂 và cho chúng rơi từ trên trời xuống.
 * Bắt đầu sự kiện thả hàng tiếp tế (phiên bản cải tiến).
 */
function triggerSupplyDrop() {
    playSound('sfx-nuke-fall', 0.4);
    showWarning("Hàng tiếp tế đang đến!");

    const dropCount = getRandomInt(3, 7); // Số lượng kiện hàng tiếp tế ngẫu nhiên từ 3 đến 7

    for (let i = 0; i < dropCount; i++) {
        const drop = {
            id: Date.now() + i, // Tạo một ID duy nhất
            x: camera.x + Math.random() * canvas.width, // Rơi ngẫu nhiên trong chiều rộng màn hình
            y: camera.y - 50, // Bắt đầu rơi từ phía trên màn hình
            speedY: 1 + Math.random() * 0.5,
            
            // THÊM MỚI: Xác định vị trí "chạm đất" là gần cuối màn hình hiện tại
            finalY: camera.y + canvas.height - (50 + Math.random() * 50)
        };
        
        supplyDrops.push(drop);

        // --- Bắt đầu logic tự quản lý vòng đời (giữ nguyên) ---
        
        const dropInterval = setInterval(() => {
            const currentDrop = supplyDrops.find(d => d.id === drop.id);
            if (!currentDrop) {
                clearInterval(dropInterval);
                return;
            }

            currentDrop.y += currentDrop.speedY;

            // SỬA LỖI: Kiểm tra va chạm với 'finalY' thay vì 'worldHeight'
            if (currentDrop.y > currentDrop.finalY) {
                playSound('sfx-supply-drop-item', 0.5);

                const resourceCount = getRandomInt(2, 10);
                const resourceTypes = ['coin', 'hp', 'mana', 'energy'];
                for (let j = 0; j < resourceCount; j++) {
                    const type = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                    const offsetX = (Math.random() - 0.5) * 60;
                    const offsetY = (Math.random() - 0.5) * 60;
                    items.push({ x: currentDrop.x + offsetX, y: currentDrop.y + offsetY, type, active: true });
                }
                
                supplyDrops = supplyDrops.filter(d => d.id !== currentDrop.id);
                clearInterval(dropInterval);
            }
        }, 1000 / 60);
    }
}

/**
 * Vẽ các kiện hàng tiếp tế (🪂) ra màn hình.
 */
function drawSupplyDrops() {
    ctx.font = "2rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    supplyDrops.forEach(drop => {
        ctx.fillText("🪂", drop.x, drop.y);
    });
}
// --- KẾT THÚC: CÁC HÀM XỬ LÝ SỰ KIỆN TIẾP TẾ ---
//🔄 8. Cập nhật logic game (Main loop logic)
function update() {
  const now = Date.now();
  if (!gameStarted || gameOver || isPaused) return; // không cập nhật khi chưa bắt đầu, game over hoặc tạm dừng
  if (player.isDying) {
      updateParticles(); // Chỉ cập nhật hiệu ứng hạt
      return; // Dừng các xử lý khác
  }
    buffEffects.power.active = now < powerBuffEndTime;
    buffEffects.crazy.active = now < crazyBuffEndTime;
    buffEffects.lucky.active = now < luckyBuffEndTime;
    buffEffects.exp.active   = now < expBuffEndTime;
    buffEffects.magnet.active  = now < magnetBuffEndTime;
    // Cập nhật góc quay cho các đóm sáng đang hoạt động
    for (const buff in buffEffects) {
        if (buffEffects[buff].active) {
            buffEffects[buff].angle += 0.01;
        }
    }

  // Cập nhật hiệu ứng laze của người chơi
  playerLasers = playerLasers.filter(laser => {
      laser.life--;
      return laser.life > 0;
  });
// Cập nhật wave logic
// ⏱ Đếm thời gian còn lại của wave
if (lastWaveTime) {
  const elapsed = (Date.now() - lastWaveTime) / 1000; // giây đã trôi qua
  const remaining = Math.max(0, waveTime - elapsed);  // thời gian còn lại
  const min = Math.floor(remaining / 60);
  const sec = Math.floor(remaining % 60);
  const ms = Math.floor((remaining - Math.floor(remaining)) * 100); // lấy 2 chữ số sau dấu .
  document.getElementById("waveTimerDisplay").innerText =
  `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}:${ms.toString().padStart(2, '0')}`;

if (remaining <= 0) {
  wave++;
  pendingWave = wave;         // 🌊 lưu wave để hiển thị sau
  showUpgradePopup();         // 🎁 hiển thị nâng cấp trước
  // Khi lên wave 5, reset thời gian BigBoss đếm từ 0
    if (wave === 5) {
        bigBossRespawnTimer = 0;
        lastBigBossTimerUpdate = performance.now();
    }
  lastWaveTime = Date.now();  // ⏱️ reset timer
  updateWaveUI();
}
}
// Thời gian bigboss hồi sinh
const existingBigBoss = zombies.find(z => z.active && z.isBigBoss);
const bigBossRemain = Math.max(0, Math.ceil(bigBossRespawnInterval - bigBossRespawnTimer));

const box = document.getElementById("bigBossRespawnDisplay");
box.style.display = "block"; // Luôn hiển thị

if (wave < 5) {
    box.innerText = "BigBoss: wait..";
} else {
    box.innerText = existingBigBoss 
  ? "BigBoss: living" 
  : `BigBoss: -${bigBossRemain.toString().padStart(3, '0')}s-`;
}
// Xử lý kỹ năng Đao 🔪 tự tạo liên tục trong 30s
if (swordActive) {
  if (Date.now() >= swordEndTime) {
    swordActive = false;
    swords.length = 0;
    document.getElementById("bladeBtn").classList.remove("active");
    document.getElementById("bladeBtn").innerText = "🔪 Đao";
  } else {
    const remain = Math.ceil((swordEndTime - Date.now()) / 1000);
// 🎯 Cập nhật bladeBtn nếu khác giá trị trước đó
const bladeRemain = Math.ceil((swordEndTime - Date.now()) / 1000);
const bladeText = `🔪 ${bladeRemain}s`;
if (bladeText !== lastBladeText) {
  lastBladeText = bladeText;
  document.getElementById("bladeBtn").innerText = bladeText;
}

// 🔪 Tạo đao mới nếu chưa có
if (swords.length === 0) {
  const count = skillUpgrades.bladeCount; // 🔪 Số đao từ nâng cấp
  nextFireIndex = 0;
for (let i = 0; i < count; i++) {
  const angle = (2 * Math.PI / count) * i;
  const s = getSword(); // hoặc tạo sword mới
  s.angle = angle;
  s.radius = 60;
  s.state = 'charging';
  s.chargeFrame = 90;
  s.fireDelay = 20 + i * 10; // từng đao delay khác nhau
  s.fireOrder = i; //  đánh số đao
  swords.push(s);
}
}
}
}
  updateBlades();
// === XỬ LÝ KỸ NĂNG KIẾM (PHIÊN BẢN TẤN CÔNG CÓ MỤC TIÊU) ===
if (bladeActive) {
    const now = Date.now();
    
    // ---- 1. KIỂM TRA HẾT HẠN ----
    if (now >= bladeEndTime) {
        bladeActive = false;
        downwardSwords = [];
        swordRainClouds = [];
        document.getElementById("swordBtn").classList.remove("active");
        document.getElementById("swordBtn").innerText = "⚔️ Kiếm";
    } else {
        // ---- 2. CẬP NHẬT TRẠNG THÁI NÚT ----
        const remain = Math.ceil((bladeEndTime - now) / 1000);
        const swordText = `⚔️ ${remain}s`;
        if (swordText !== lastSwordText) {
            lastSwordText = swordText;
            document.getElementById("swordBtn").innerText = swordText;
        }

        // ---- 3. CẬP NHẬT ĐÁM MÂY VÀ THẢ KIẾM ----
        // Tần suất rơi kiếm sẽ nhanh hơn khi cấp độ kỹ năng tăng
        const SWORD_DROP_INTERVAL = Math.max(100, 1200 - (skillUpgrades.swordLevel * 100));

        swordRainClouds.forEach(cloud => {
            // Mây trôi nhẹ nhàng
            cloud.relativeX += cloud.driftSpeed;
            if (cloud.relativeX < 50 || cloud.relativeX > canvas.width - 50) {
                cloud.driftSpeed *= -1;
            }

            // Đến lúc thì thả kiếm
            if (now > cloud.nextDropTime) {
                downwardSwords.push({
                    x: camera.x + cloud.relativeX,
                    y: camera.y + cloud.relativeY + 20,
                    speed: 4 + skillUpgrades.swordLevel * 0.2, // Tốc độ rơi tăng theo cấp
                    vx: (Math.random() - 0.5) * 2 // Rơi xiên ngẫu nhiên
                });
                // Đặt lại thời gian cho lần rơi tiếp theo
                cloud.nextDropTime = now + SWORD_DROP_INTERVAL + Math.random() * 200;
            }
        });
        
        // ---- 4. CẬP NHẬT KIẾM ĐANG RƠI ----
        for (let i = downwardSwords.length - 1; i >= 0; i--) {
            const s = downwardSwords[i];
            s.y += s.speed;
            s.x += s.vx; // Thêm di chuyển ngang

            if (s.y > camera.y + canvas.height + 30) {
                downwardSwords.splice(i, 1);
                continue;
            }
            zombies.forEach((z) => {
                if (z.active && distance(s, z) < 20) {
                    if (!z.swordCooldown || Date.now() > z.swordCooldown) {
                        dealDamageToZombie(z, skillUpgrades.swordDamage + playerUpgrades.damageBoost);
                        z.swordCooldown = Date.now() + 100;
                    }
                }
            });
        }
    }
}

if (gameOver) return;
// 🔁 Giảm thời gian miễn sát thương
if (player.hitTimer > 0) {
  player.hitTimer--;
}

// Player move
let moveX = 0;
let moveY = 0;

if (keys.w) moveY -= 1;
if (keys.s) moveY += 1;
if (keys.a) moveX -= 1;
if (keys.d) moveX += 1;

if (moveX !== 0 || moveY !== 0) {
  const length = Math.hypot(moveX, moveY);
  moveX /= length;
  moveY /= length;
  // Tốc độ player
let finalSpeed = player.speed;
if (disguiseActive) {
    finalSpeed *= 1.5; // Tăng 50% tốc chạy khi biến hình
}
if (supportAuraActive) {
    finalSpeed *= 1.2; // Tăng 20% tốc độ chạy
}
player.x += moveX * finalSpeed;
player.y += moveY * finalSpeed;
  // Giới hạn player trong bản đồ
player.x = Math.max(wallThickness + player.size, Math.min(worldWidth - wallThickness - player.size, player.x));
player.y = Math.max(wallThickness + player.size, Math.min(worldHeight - wallThickness - player.size, player.y));
// 🎥 Cập nhật camera sao cho player luôn ở giữa màn hình
camera.x = player.x - canvas.width / 2;
camera.y = player.y - canvas.height / 2;

// Giới hạn camera trong bản đồ
camera.x = Math.max(0, Math.min(worldWidth - canvas.width, camera.x));
camera.y = Math.max(0, Math.min(worldHeight - canvas.height, camera.y));
}

// === Xử lý điều khiển cảm ứng ===
if (touchStartX !== null && touchMoveX !== null) {
  let dx = touchMoveX - touchStartX;
  let dy = touchMoveY - touchStartY;
  const len = Math.hypot(dx, dy);
  if (len > 10) { // chỉ di chuyển nếu vuốt đủ lớn
    dx /= len;
    dy /= len;
    player.x += dx * player.speed;
    player.y += dy * player.speed;
  }
}

if (autoShoot && player.level >= 1) autoShootBurst();

// === Kỹ năng LỬA ===
  if (fireActive) {
    const remaining = Math.ceil((fireEndTime - Date.now()) / 1000);
    const fireBtn = document.getElementById("fireBtn");
    if (remaining > 0) {
const fireText = `🔥 ${remaining}s`;
if (fireText !== lastFireText) {
  lastFireText = fireText;
  fireBtn.innerText = fireText;
}
    } else {
fireActive = false;
fireballs.forEach(f => releaseFireball(f));
fireballs.length = 0;
fireBtn.innerText = "🔥 Lửa";
fireBtn.classList.remove("active");
    }}

// === Kỹ năng BĂNG ===
  if (iceActive) {
    const remaining = Math.ceil((iceEndTime - Date.now()) / 1000);
    const iceBtn = document.getElementById("iceBtn");
    if (remaining > 0) {
const iceText = `❄️ ${remaining}s`;
if (iceText !== lastIceText) {
  lastIceText = iceText;
  iceBtn.innerText = iceText;
}
} 
else
{
iceActive = false;
iceballs.forEach(i => releaseIceball(i));
iceballs.length = 0;
iceBtn.innerText = "❄️ Băng";
iceBtn.classList.remove("active");
}}
// === Kỹ năng PET ===
if (petActive) {
  const remaining = Math.ceil((petEndTime - Date.now()) / 1000);  
  const petBtn    = document.getElementById("PetBtn");

  if (remaining > 0) {
    const petText = `🐰 ${remaining}s`;
    if (petText !== lastPetText) {        // tránh gán DOM thừa
      lastPetText      = petText;
      petBtn.innerText = petText;
    }
  } else {
    // Hết giờ
    petBtn.innerText = "🐰 Pet";
    petBtn.classList.remove("active");
  }
}

updateBullets(); // gọi hàm đã viết sử dụng object pooling
// VÒNG LẶP XỬ LÝ ZOMBIE CHÍNH
zombies.forEach(z => {
// --- BẮT ĐẦU: XỬ LÝ HIỆU ỨNG TRẠNG THÁI (ĐỐT CHÁY, LÀM CHẬM) ---
    const now = Date.now();
    let shouldBeSlowed = false; // Tạo một cờ báo hiệu làm chậm

    // Xử lý hiệu ứng Đốt Cháy (Burn)
    if (z.burnEndTime && now < z.burnEndTime) {
        if (!z.lastBurnTick || now - z.lastBurnTick > 1000) { // Gây sát thương mỗi giây
            z.lastBurnTick = now;
            const burnDamage = Math.max(1, Math.round((skillUpgrades.fireDamage + playerUpgrades.damageBoost) * 0.25));
            dealDamageToZombie(z, burnDamage);
        }
    } else if (z.burnEndTime) {
        z.burnEndTime = null; // Hủy hiệu ứng khi hết hạn
    }

    // Kiểm tra và đặt cờ cho hiệu ứng Làm Chậm (Slow)
    if (z.slowEndTime && now < z.slowEndTime) {
        shouldBeSlowed = true;
    } else if (z.slowEndTime) {
        z.slowEndTime = null; // Hủy hiệu ứng khi hết hạn
    }
    // --- KẾT THÚC: XỬ LÝ HIỆU ỨNG TRẠNG THÁI ---
    // ⚡ Nếu bị stun bởi lôi thì không di chuyển, không tấn công
  if (z.stunnedByThunder && Date.now() < z.stunnedThunderUntil) {
    return;
  } else if (z.stunnedByThunder && Date.now() >= z.stunnedThunderUntil) {
    z.stunnedByThunder = false;
  }
// --- Buff #1 & #2: Tăng HP vĩnh viễn ---
// Khi đêm xuống, nhận buff 1 lần
if (isNight()) {
        if (!z.nightBuffApplied) {
            const nightHpBonus = Math.floor(Math.random() * 9) + 2;
            z.hp += nightHpBonus;
            z.baseHp += nightHpBonus;
            z.nightBuffApplied = true;
        }
    } else {
        z.nightBuffApplied = false;
    }

    if (currentDay > z.lastDayBuffed) {
        const survivalHpBonus = Math.round(z.baseHp * 0.1);
        z.hp += survivalHpBonus;
        z.baseHp += survivalHpBonus;
        z.lastDayBuffed = currentDay;
        z.isBuffed = true;
    }

// --- LOGIC HỒI MÁU (BAN ĐÊM) VÀ GIẢM MÁU (BAN NGÀY) ---
    if (Date.now() - z.lastRegenTime > 30000) {
        if (isNight()) {
            // Ban đêm, zombie vẫn hồi máu ở mọi wave
            z.hp += 1;
            z.baseHp += 1;
            z.lastRegenTime = Date.now();
        } else {
            // Ban ngày, chỉ trừ máu zombie nếu wave lớn hơn 2
            if (wave > 2) {
                z.hp -= 1;
                z.baseHp -= 1;
                z.lastRegenTime = Date.now();
                if (z.hp <= 0 && !z._killed) {
                    killZombie(z);
                }
            }
        }
    }
    // --- 👣 Cập nhật hướng di chuyển theo trạng thái ---
    if (z.state === "wandering") {
        if (Date.now() >= z.wanderTime) {
            z.state = "chasing";
            z.speed = z.baseSpeed;
            z.nextStateCheck = Date.now() + 3000;
        } else {
            if (z.wanderBehavior === "move") {
          let finalWanderSpeed = z.speed;
          if (shouldBeSlowed) {
              finalWanderSpeed *= 0.5; // Giảm 50% tốc độ di chuyển lang thang
          }
          z.x += Math.cos(z.wanderAngle) * finalWanderSpeed;
          z.y += Math.sin(z.wanderAngle) * finalWanderSpeed;
            }
        }
    } else if (z.state === "chasing") {
if (Date.now() >= z.nextStateCheck) {
if (!z.isBoss) {
          // --- BẮT ĐẦU LOGIC CẢI TIẾN ---
          
          // Tăng bộ đếm chu kỳ hành vi mỗi khi zombie kiểm tra lại.
          // (z.behaviorCheckCounter || 0) để tránh lỗi nếu zombie cũ không có thuộc tính này.
          z.behaviorCheckCounter = (z.behaviorCheckCounter || 0) + 1;

          // Chỉ gán lại ngẫu nhiên việc hiển thị icon sau mỗi 3 chu kỳ (khoảng 9 giây).
          if (z.behaviorCheckCounter >= 3) {
            z.showStatusIcon = Math.random() < 0.3; // Gán lại ngẫu nhiên
            z.behaviorCheckCounter = 0; // Reset bộ đếm về 0
          }
          // --- KẾT THÚC LOGIC CẢI TIẾN ---
          
          const continueChaseChance = 0.6; // 60% xác suất tiếp tục đuổi theo player 

          if (Math.random() < continueChaseChance) {
            // Nếu trúng 60%, zombie sẽ tiếp tục đuổi theo.
            // Chúng ta chỉ cần reset lại thời gian cho lần kiểm tra tiếp theo sau 3 giây nữa.
            z.nextStateCheck = Date.now() + 3000;
          } else {
            // Nếu không trúng (40% còn lại), zombie sẽ chuyển sang trạng thái "wandering" như cũ.
            const pauseChance = isNight() ? 0.1 : 0.2;
            z.state = "wandering";
            z.wanderTime = Date.now() + 1500 + Math.random() * 8500;
            z.wanderAngle = Math.random() * Math.PI * 2;
            z.speed = 0.15 + Math.random() * 0.05;
            z.wanderBehavior = Math.random() < pauseChance ? "pause" : "move";
            return;
          }
          // --- KẾT THÚC LOGIC MỚI ---
        }
      }
        const angle = Math.atan2(player.y - z.y, player.x - z.x);
        let finalSpeed = z.speed;
        if (!isNight()) {
            finalSpeed *= 0.7;
        }
        if (shouldBeSlowed) {
          finalSpeed *= 0.5; // Nếu bị làm chậm, giảm 50% tốc độ cuối cùng
      }
        z.x += Math.cos(angle) * finalSpeed;
        z.y += Math.sin(angle) * finalSpeed;
    }

    // --- Zombie bắn trả ---
    if (z.isBoss || z.type === "miniBoss") {
        if (!z.lastShoot) z.lastShoot = 0;
        const now = Date.now();
        if (now - z.lastShoot >= 8000) {
            z.lastShoot = now;
            shootEnemyBullet(z, 2, 0.8);
        }
    }
    if (!z.isBoss && z.type !== "miniBoss") {
        if (!z.lastShoot) z.lastShoot = 0;
        const now = Date.now();
        if (now - z.lastShoot >= 60000) {
            z.lastShoot = now;
            shootEnemyBullet(z, 1 + Math.random() * 0.5, 0.001); // Tốc độ mới: ngẫu nhiên từ 1.0 đến 2.0

        }
    }

    // --- 🧟 Xử lý va chạm với player ---
    if (distance(z, player) < z.radius + player.size) {
if (player.shieldActive) {
                const shieldRadius = 48;
                const repelDistance = shieldRadius + z.radius;
                const dist = distance(z, player);
                if (dist < repelDistance) {
                    // --- BẮT ĐẦU THÊM MỚI ---
                    const now = Date.now();
                    // Thêm cooldown 100ms để âm thanh không bị spam dồn dập
                    if (now - lastShieldBlockSoundTime > 100) {
                        playSound('sfx-shield-block', 0.3); // 30% âm lượng
                        lastShieldBlockSoundTime = now;
                    }
                    // --- KẾT THÚC THÊM MỚI ---

                    const dx = z.x - player.x;
                    const dy = z.y - player.y;
                    const angle = Math.atan2(dy, dx);
                    const pushBack = (repelDistance - dist) + 20;
                    z.x += Math.cos(angle) * pushBack;
                    z.y += Math.sin(angle) * pushBack;
                    return;
                }
            }
        const dist = distance(z, player);
        if (dist < z.radius + player.size) {
            if (z.canHit) {
              // Cập nhật sát thương khi va chạm
            let damage = calculateZombieDamage(z); // Tính sát thương
            // Nếu Hào quang đang bật, giảm 50% sát thương
                if (supportAuraActive) {
                    damage *= 0.5;
                }
            player.hearts -= damage;                 // Trừ máu theo sát thương đã tính
            createDamageImpactEffect(player, damage);
            z.canHit = false;
            setTimeout(() => { z.canHit = true; }, 500);
            if (player.hearts <= 0) {
                handlePlayerDeath(); 
            }
            }
            const dx = z.x - player.x;
            const dy = z.y - player.y;
            const angle = Math.atan2(dy, dx);
            const pushBack = (z.radius + player.size - dist) + 1;
            z.x += Math.cos(angle) * pushBack;
            z.y += Math.sin(angle) * pushBack;
        }
    }

    // --- 🚫 Giới hạn zombie không vượt khỏi bản đồ ---
    z.x = Math.max(wallThickness + z.radius, Math.min(worldWidth - wallThickness - z.radius, z.x));
    z.y = Math.max(wallThickness + z.radius, Math.min(worldHeight - wallThickness - z.radius, z.y));
});
// BigBoss logic - Tạo bigboss và hồi sinh mỗi 60s
// 🎯 BigBoss chỉ bắt đầu đếm từ wave 5 trở lên
if (wave >= 5) {
    // Kiểm tra xem hiện tại có BigBoss tồn tại không
    const existingBigBoss = zombies.find(z => z.active && z.isBigBoss);

    if (!existingBigBoss) {
        // Nếu vừa mới vào wave 5, reset timer
        if (wave === 5 && bigBossRespawnTimer === 0) {
            bigBossRespawnTimer = 0;
            lastBigBossTimerUpdate = performance.now();
        }

        // Đếm thời gian thực để hồi sinh
        const now = performance.now();
        const elapsed = (now - lastBigBossTimerUpdate) / 1000;
        bigBossRespawnTimer += elapsed;
        lastBigBossTimerUpdate = now;

        if (bigBossRespawnTimer >= bigBossRespawnInterval) {
            spawnBigBoss();
            bigBossRespawnTimer = 0;
        }
    } else {
        // Nếu BigBoss còn sống, reset timer đếm lại từ đầu
        lastBigBossTimerUpdate = performance.now();
        bigBossRespawnTimer = 0;
    }
}
// 🔥 Kỹ năng Lửa Cập nhật fireballs - kỹ năng lửa quay quanh player và gây sát thương
  fireballs.forEach(f => {
    if (!f.nextSparkTime) f.nextSparkTime = 0; // Khởi tạo thời gian bắn tia lửa
    const now = Date.now();
    
    f.angle += 0.05;
    f.x = player.x + Math.cos(f.angle) * f.radius;
    f.y = player.y + Math.sin(f.angle) * f.radius;

    // Bắn tia lửa mỗi 1.5 giây
    if (now > f.nextSparkTime) {
      f.nextSparkTime = now + 1500;
      const target = zombies
        .filter(z => z.active && distance(f, z) < 200)
        .sort((a, b) => distance(f, a) - distance(f, b))[0];

      if (target) {
        // SỬA LỖI: Chỉ tạo ra đốm lửa và gán sát thương cho nó, không gây sát thương ngay.
        const sparkDamage = Math.max(1, Math.round((skillUpgrades.fireDamage + playerUpgrades.damageBoost) * 0.5));
        particles.push({
            type: 'fire_spark',
            x: f.x,
            y: f.y,
            target: target,
            speed: 2,
            damage: sparkDamage // Gán sẵn sát thương cho đốm lửa
        });
      }
    }

    // Xử lý va chạm trực tiếp (logic này giữ nguyên, hoàn toàn chính xác)
    zombies.forEach(z => {
      if (z.active && distance(f, z) < 25) {
        if (!z.fireCooldown || now > z.fireCooldown) {
          dealDamageToZombie(z, skillUpgrades.fireDamage + playerUpgrades.damageBoost);
          z.fireCooldown = now + 100;
          z.onFireUntil = now + 400;
          z.burnEndTime = now + 3000;
          z.state = "wandering";
          z.wanderTime = now + 3000 + Math.random() * 2000;
          z.wanderAngle = Math.random() * Math.PI * 2;
        }
      }
    });
  });
// ❄️ Kỹ năng Băng Cập nhật iceballs - kỹ năng băng quay quanh player và gây sát thương
  iceballs.forEach(f => {
    if (!f.nextShardTime) f.nextShardTime = 0; // Khởi tạo thời gian bắn mảnh băng
    const now = Date.now();
    
    f.angle += 0.03;
    f.x = player.x + Math.cos(f.angle) * f.radius;
    f.y = player.y + Math.sin(f.angle) * f.radius;
    
    // Bắn mảnh băng mỗi 2 giây
    if (now > f.nextShardTime) {
      f.nextShardTime = now + 2000;
      const target = zombies
        .filter(z => z.active && distance(f, z) < 250)
        .sort((a, b) => distance(f, a) - distance(f, b))[0];
      
      if (target) {
        // SỬA LỖI: Chỉ tạo ra mảnh băng và gán sát thương, không gây sát thương/hiệu ứng ngay.
        const shardDamage = Math.max(1, Math.round((skillUpgrades.iceDamage + playerUpgrades.damageBoost) * 0.5));
        particles.push({
            type: 'ice_shard',
            x: f.x,
            y: f.y,
            target: target,
            speed: 2,
            damage: shardDamage // Gán sẵn sát thương cho mảnh băng
        });
      }
    }
    
    // Xử lý va chạm trực tiếp (logic này giữ nguyên, hoàn toàn chính xác)
    zombies.forEach(z => {
      if (z.active && distance(f, z) < 25) {
        if (!z.iceCooldown || now > z.iceCooldown) {
          dealDamageToZombie(z, skillUpgrades.iceDamage + playerUpgrades.damageBoost);
          z.iceCooldown = now + 100;
          z.onIceUntil = now + 400;
          z.slowEndTime = now + 3000;
          z.state = "wandering";
          z.wanderTime = now + 3000 + Math.random() * 2000;
          z.wanderAngle = Math.random() * Math.PI * 2;
        }
      }
    });
  });
// 🎯 Xử lý nhặt vật phẩm khi người chơi tiến lại gần // Nhặt item ⚡
items.forEach(it => {
  if (!it.active) return;
  if (distance(it, player) < 20) { // Nếu người chơi chạm vào vật phẩm
    playSound('sfx-pickup', 0.5); // Phát âm thanh nhặt vật phẩm
    switch (it.type) {
      case 'lucky': // <-- THÊM CASE MỚI NÀY
        luckyBuffEndTime = Date.now() + 45000; // 45 giây hiệu lực
        playSound('sfx-powerup', 0.8);
        break;
      case 'power': // <-- THÊM CASE MỚI NÀY
        powerBuffEndTime = Date.now() + 45000; // 45 giây hiệu lực
        playSound('sfx-powerup', 0.8);
        break;
      case 'crazy':
        crazyBuffEndTime = Date.now() + 45000; // 45 giây hiệu lực
        playSound('sfx-powerup', 0.8);
        break;
      case 'exp': // <-- THÊM MỚI
        expBuffEndTime = Date.now() + 45000;
        playSound('sfx-powerup', 0.8);
        break;
      case 'magnet':
        // THÊM LOGIC MỚI: Chỉ kích hoạt buff nếu nó chưa hoạt động
        if (Date.now() > magnetBuffEndTime) {
            magnetBuffEndTime = Date.now() + 30000;
            playSound('sfx-powerup', 0.8);
        }
        // Nếu buff đang hoạt động, việc nhặt thêm sẽ không có tác dụng
        break;
      case 'secret':
        activateSecretItem(it); // Gọi hàm xử lý riêng
        playSound('sfx-powerup', 0.8);
        break;
      case 'expBonus':
        activateExpBonusItem(); // Gọi hàm xử lý riêng
        playSound('sfx-powerup', 0.8);
        break;
      case 'coin': // <-- THÊM CASE MỚI NÀY
      playSound('sfx-pickup-coin', 0.5);
        player.coins += 1;
        showWarning('🪙 +1 Coin');
        break;
      case 'energy':
        player.energy += 1;
        showWarning('⚡ +1 Energy');
        break;
      case 'mana':
        player.mana += 1;
        showWarning('💠 +1 Mana');
        break;
      case 'hp':
        player.hearts += 1;
         createHealImpactEffect(player, 1);
        break;
      case 'potion': // <-- THÊM MỚI
        const baseHeal = Math.floor(Math.random() * (20 - 10 + 1)) + 10;
        const bonusHeal = Math.round((player.level + wave) * 1.5);
        const totalHeal = baseHeal + bonusHeal;

        player.hearts += totalHeal;
        createHealImpactEffect(player, totalHeal);
        showWarning(`💊 +${totalHeal} HP`);
        break;
      case 'box':
        openItemBox(); // Mở hộp vật phẩm đặc biệt
        break;
    }
    it.active = false; // Vật phẩm biến mất sau khi nhặt
  }
});

items = items.filter(it => it.active);
const requiredExp = calculateRequiredExp(player.level); // Yêu cầu EXP để lên cấp tăng cấp
    // Sử dụng vòng lặp while để xử lý trường hợp lên nhiều cấp cùng lúc
    while (player.currentLevelExp >= player.requiredExp) {
        const leftoverExp = player.currentLevelExp - player.requiredExp;
        
        playSound('sfx-level-up');
        player.level++;
        player.hearts += 1 + (UPGRADE_TIERS.hpBoost[playerUpgrades.hpBoost] || 0);
        player.energy += 10;
        player.mana += 10;
        playerUpgrades.damageBoost += 0.5;
        showWarning("+0.5 💥");

        const popup = document.getElementById("levelUpPopup");
        popup.style.animation = "none";
        void popup.offsetWidth;
        popup.style.display = "block";
        setTimeout(() => {
            popup.style.display = "none";
        }, 1200);
        levelUpGlowTime = 60;
        showSkillLevelUpPopup();
        
        if (player.level % 1 === 0) {
            spawnBoss();
        }

        player.currentLevelExp = leftoverExp;
        player.requiredExp = calculateRequiredExp(player.level);
    }
    // --- KẾT THÚC: HỆ THỐNG LÊN CẤP MỚI ---

  updateExplosions(); // dùng object pooling thay splice
  // 🌊 Cập nhật các vòng nổ phụ
extraShockwaves = extraShockwaves.filter(sw => {
  sw.radius += 8; // tăng bán kính mỗi frame
  sw.alpha -= 0.012; // giảm độ mờ dần
  return sw.alpha > 0;
});

if (levelUpGlowTime > 0) levelUpGlowTime--;
// 🎯 Cập nhật bullets – dùng object pooling thay vì splice
function updateBullets() {
  for (let i = 0; i < bullets.length; i++) {
    const b = bullets[i];
    if (!b.active) continue;

// 🏃 Di chuyển đạn theo hướng và tốc độ lưu riêng
if (b.curveMode) {
  // 🔄 Xoắn ốc quanh player
  b.curveRadius += 0.6;
  b.angle += b.curveSpeed * 0.5;
  b.x = player.x + Math.cos(b.angle) * b.curveRadius;
  b.y = player.y + Math.sin(b.angle) * b.curveRadius;

} else if (b.zigzagMode) {
  // ↔️ Zigzag
  b.travel += b.speed;
  const offset = Math.sin(b.travel * b.oscillateSpeed + b.oscillatePhase) * b.oscillateAmplitude;
  const angle = b.baseAngle;
  b.x = b.startX + Math.cos(angle) * b.travel - Math.sin(angle) * offset;
  b.y = b.startY + Math.sin(angle) * b.travel + Math.cos(angle) * offset;

} else if (b.spiralForwardMode) {
  // 🎯 Xoắn ốc bay thẳng
  b.travel += b.speed;
  const angle = b.baseAngle;
  const centerX = b.startX + Math.cos(angle) * b.travel;
  const centerY = b.startY + Math.sin(angle) * b.travel;
  const offsetAngle = b.spiralPhase + b.travel * b.spiralSpeed;
  const offsetX = Math.cos(offsetAngle) * b.spiralRadius;
  const offsetY = Math.sin(offsetAngle) * b.spiralRadius;
  b.x = centerX + offsetX;
  b.y = centerY + offsetY;

} else {
  // 🟡 Mặc định: đạn bay thẳng
  b.x += b.dx * b.speed;
  b.y += b.dy * b.speed;
}

    for (let j = 0; j < zombies.length; j++) {
        const z = zombies[j];
        if (!z.active) continue;

        if (distance(b, z) < 20) {
            
            // TRƯỜNG HỢP 1: Đạn của Tiên Nữ
            if (b.isFairyBullet) {
                if (b.effect === 'sleep') {
                    z.isSleeping = true;
                    z.sleepUntil = Date.now() + 3000;
                } else if (b.effect === 'wandering') {
                    z.state = 'wandering';
                    z.wanderTime = Date.now() + 3000;
                }
                z.isWeakened = true;
                z.weakenEndTime = Date.now() + 5000;
                for (let i = 0; i < 4; i++) {
                    createFairyHitParticle(z);
                }
                releaseBullet(b);
                break;
            }
            // TRƯỜNG HỢP 2: Đạn của Pet
            else if (b.isPetBullet) {
                dealDamageToZombie(z, b.customDmg);
                z.stunnedByThunder = true;
                z.stunnedThunderUntil = Date.now() + b.stunDuration;
                releaseBullet(b);
                break;
            }
            // TRƯỜNG HỢP 3: Đạn của Player và Clone
            else {
                // ✨ ĐOẠN MÃ LỖI ĐÃ ĐƯỢC DI CHUYỂN VÀO ĐÂY
                const dmg = (b.customDmg !== undefined)
                            ? b.customDmg
                            : (playerUpgrades.damageBoost || 1);
                
                dealDamageToZombie(z, dmg);

                if (!b.piercing) {
                    releaseBullet(b);
                    break;
                }
            }
// ✨ NEW: chỉ dùng customDmg nếu đạn đó đã gán sẵn baseDamage,
// còn lại thì mới rơi về damageBoost chung của người chơi.
const dmg = (b.customDmg !== undefined)
            ? b.customDmg                        // Clone & mọi skill gán sẵn baseDamage
            : (playerUpgrades.damageBoost || 1); // Đạn thường của người chơi
dealDamageToZombie(z, dmg);
if (!b.piercing) {
    releaseBullet(b);
    break;
}
}
}
}
  bullets = bullets.filter(b => b.active);
}

function updateEnemyBullets() {
  for (let i = 0; i < enemyBullets.length; i++) {
    const b = enemyBullets[i];
    if (!b.active) continue;
    b.x += b.dx * b.speed;
    b.y += b.dy * b.speed;
    // Nếu trúng người chơi
    if (distance(b, player) < 15) {
      // Cập nhật logic chặn đạn
        if (player.shieldActive) {
          playSound('sfx-shield-block', 0.3); // Phát âm thanh chặn đạn
            // ✨ BẮT ĐẦU LOGIC MỚI ✨
            // 1. Tính toán vị trí va chạm trên viền khiên
            const angle = Math.atan2(b.y - player.y, b.x - player.x);
            const shieldRadius = 48; // Bán kính của khiên
            const impactX = player.x + Math.cos(angle) * shieldRadius;
            const impactY = player.y + Math.sin(angle) * shieldRadius;

            // 2. Gọi hàm tạo hiệu ứng mới tại điểm va chạm
            createShieldImpactEffect(impactX, impactY);
            
            // 3. Hủy viên đạn và bỏ qua logic trừ máu
            releaseEnemyBullet(b);
            continue;
            // ✨ KẾT THÚC LOGIC MỚI ✨
        }

    if (player.hitTimer === 0) {
        let damage = b.damage || 1; // Lấy sát thương từ đạn, nếu không có thì mặc định là 1
                    // Nếu Hào quang đang bật, giảm 50% sát thương
            if (supportAuraActive) {
                damage *= 0.5;
            }
        player.hearts -= damage;
        player.hitTimer = 30;
        createDamageImpactEffect(player, damage);
            if (player.hearts <= 0) {
                handlePlayerDeath();
}
}
b.hit = true;
}
// Nếu ra khỏi màn hình
    const outOfBounds =
      b.x < -50 || b.x > worldWidth + 50 ||
      b.y < -50 || b.y > worldHeight + 50;
if (b.hit || outOfBounds) {
      releaseEnemyBullet(b);
}
}
// Chỉ giữ lại các đạn còn active
  enemyBullets = enemyBullets.filter(b => b.active);
}
// 💥 Cập nhật hiệu ứng nổ – thay thế splice bằng release
function updateExplosions() {
  explosions.forEach(e => {
    if (!e.active) return;
    e.radius += 2;
    e.life--;
    if (e.life <= 0) {
      releaseExplosion(e);
    }
  });
}
// 💥 Xử lý các vòng nổ lan (dùng cho bom hạt nhân)
expandingExplosions = expandingExplosions.filter(exp => {
  const prevRadius = exp.radius;
  exp.radius += exp.maxRadius / exp.duration;
  exp.duration--;
// 💀 Gây sát thương khi vòng vừa chạm tới zombie
  zombies.forEach(z => {
    const dist = distance(exp, z);
    if (z.active && dist >= prevRadius && dist < exp.radius && !exp.hitSet.has(z)) {
    dealDamageToZombie(z, exp.damage);
    exp.hitSet.add(z);
    }
  }
);
    return exp.duration > 0;
});
// Kỹ năng vệ tinh lazer
if (satelliteActive) {
  // --- 1. KIỂM TRA HẾT HẠN KỸ NĂNG ---
  if (Date.now() >= satelliteEndTime) {
    satelliteActive = false;
    satellites = [];
    return;
  }

  // --- 2. CẬP NHẬT VỊ TRÍ VỆ TINH (LOGIC QUAY QUANH) ---
  satellites.forEach(sat => {
    sat.angle += sat.orbitSpeed;
    sat.x = player.x + Math.cos(sat.angle) * sat.orbitRadius;
    sat.y = player.y + Math.sin(sat.angle) * sat.orbitRadius;
    if (!sat.laserCooldown) sat.laserCooldown = Date.now();
  });

  // --- 3. LOGIC TẤN CÔNG ---
  satellites.forEach((sat) => {
    // Bắn laze mới nếu đã hết thời gian hồi chiêu
    if (Date.now() >= sat.laserCooldown) {
      const target = zombies
        .filter(z => z.active && distance(sat, z) < 500)
        .sort((a, b) => distance(sat, a) - distance(sat, b))[0];

      if (target) {
        playSound('sfx-laser', 0.5);
        sat.laserCooldown = Date.now() + 2000;
        const angle = Math.atan2(target.y - sat.y, target.x - sat.x);
        // Khi bắn, tạo một tia laze mới với danh sách mục tiêu đã trúng hoàn toàn mới
        sat.laserBeam = {
          angle: angle,
          life: 60, // Tia laze tồn tại trong 60 frame
          hitZombiesThisShot: new Set() // QUAN TRỌNG: Tạo mới Set cho mỗi lần bắn
        };
      }
    }

    // Xử lý sát thương cho tia laze đang hoạt động
    if (sat.laserBeam && sat.laserBeam.life > 0) {
      sat.laserBeam.life--;
      
      const x1 = sat.x, y1 = sat.y;
      const angle = sat.laserBeam.angle;
      const dx = Math.cos(angle), dy = Math.sin(angle);
      const skill = activeSkills.find(s => s.name === "Vệ tinh laze");
      const baseDamage = skill?.baseDamage ?? 5;

      // Tìm tất cả zombie nằm trên đường bắn của tia laze HIỆN TẠI
      const hitTargets = [];
      zombies.forEach(z => {
          if (z.active) {
              const proj = (z.x - x1) * dx + (z.y - y1) * dy;
              const perp = Math.abs((z.x - x1) * dy - (z.y - y1) * dx);
              if (proj > 0 && proj < 500 && perp < 20) {
                  hitTargets.push(z);
              }
          }
      });

      // Nếu có mục tiêu bị trúng
      if (hitTargets.length > 0) {
        // --- BẮT ĐẦU PHẦN SỬA LỖI LOGIC SÁT THƯƠNG ---

        // 1. Sắp xếp các mục tiêu theo khoảng cách, từ gần nhất đến xa nhất.
        hitTargets.sort((a, b) => distance(sat, a) - distance(sat, b));
        
        // 2. Mục tiêu đầu tiên trong danh sách đã sắp xếp chính là mục tiêu gần nhất.
        const firstTarget = hitTargets[0];

        // 3. Vòng lặp gây sát thương cho tất cả các mục tiêu trong đường bắn.
        hitTargets.forEach(z => {
            // Chỉ gây sát thương một lần cho mỗi mục tiêu trong một tia laze này.
            if (!sat.laserBeam.hitZombiesThisShot.has(z)) {
                let finalDamage;
                
                // 4. Nếu là mục tiêu đầu tiên (gần nhất), gây 100% sát thương.
                if (z === firstTarget) {
                    finalDamage = baseDamage;
                } else {
                    // 5. Nếu là các mục tiêu phía sau, gây 50% sát thương (làm tròn, tối thiểu 1).
                    finalDamage = Math.max(1, Math.round(baseDamage * 0.5));
                }

                dealDamageToZombie(z, finalDamage);
                
                // Đánh dấu là đã gây sát thương cho zombie này trong lượt bắn này.
                sat.laserBeam.hitZombiesThisShot.add(z);
            }
        });
        
        // --- KẾT THÚC PHẦN SỬA LỖI ---
      }

      if (sat.laserBeam.life <= 0) sat.laserBeam = null;
    }
  });
}

// 🌩️ Kỹ năng Sét - vẽ tia sét
if (lightningActive) {
    const now = Date.now();
    const bobY = Math.sin(frame * 0.05) * 4;

// Cập nhật vị trí các đám mây theo hình vòng cung
const boltCount = lightningBolts.length;
const arcRadius = 80; // Khoảng cách từ mây đến người chơi
const angleSpread = Math.PI * 0.7; // Độ rộng của vòng cung (khoảng 126 độ)

lightningBolts.forEach((bolt, i) => {
    let angle;
    if (boltCount === 1) {
        angle = -Math.PI / 2; // Nếu chỉ có 1 mây, đặt ngay trên đầu
    } else {
        // Tính toán góc cho mỗi đám mây để tạo thành vòng cung
        const startAngle = -Math.PI / 2 - angleSpread / 2;
        const angleStep = angleSpread / (boltCount - 1);
        angle = startAngle + i * angleStep;
    }

    // Gán vị trí mới dựa trên góc và bán kính
    bolt.x = player.x + Math.cos(angle) * arcRadius;
    bolt.y = player.y + Math.sin(angle) * arcRadius + bobY; // bobY để giữ hiệu ứng nhấp nhô

        // --- (MỚI) Logic sét đánh tự vệ từ đám mây ---
        if (now > bolt.nextZapTime) {
            // 1. Tìm một zombie gần đám mây trong phạm vi 200
            const target = zombies.find(z => z.active && distance(bolt, z) <= 240); // phạm vi tia sét phụ

            if (target) {
                // 2. Gây sát thương (ví dụ: một nửa sát thương chính)
                dealDamageToZombie(target, bolt.damage / 2);

                // 3. Tạo hiệu ứng tia sét trắng nhỏ
                activeLightningStrikes.push({
                    path: getZigZag(bolt, target, 4), // Ít gấp khúc hơn
                    life: 60, // Thời gian tia sét
                    type: 'chain' // Dùng lại kiểu 'sét lan' để có màu trắng
                });

                // 4. Đặt lại thời gian cho lần phóng sét tiếp theo của đám mây này
                bolt.nextZapTime = now + 1000 + Math.random() * 500; // 1 - 1.5 giây
            }
        }
    });

    // --- Logic giáng sét chính từ trên trời (giữ nguyên) ---
    if (now > nextLightningStrikeTime) {
        const visibleZombies = zombies.filter(z => 
            z.active &&
            z.x > camera.x && z.x < camera.x + canvas.width &&
            z.y > camera.y && z.y < camera.y + canvas.height
        );
        
        if (visibleZombies.length > 0) {
            const target = visibleZombies[Math.floor(Math.random() * visibleZombies.length)];
            const startPoint = { x: target.x, y: camera.y - 20 };
            const endPoint = { x: target.x, y: target.y };

            activeLightningStrikes.push({
                path: getZigZag(startPoint, endPoint, 8),
                life: 60 // thời gian tia sét - khoảng 1s
            });

            dealDamageToZombie(target, lightningBolts[0].damage);
            explosions.push(getExplosion(target.x, target.y));
        }
        
        const baseInterval = 800 / lightningBolts.length;
        const randomOffset = (Math.random() - 0.5) * 400; 
        const finalInterval = baseInterval + randomOffset;
        nextLightningStrikeTime = now + Math.max(100, finalInterval); 
    }

    // Cập nhật và xóa các tia sét đã hết hạn (giữ nguyên)
    activeLightningStrikes = activeLightningStrikes.filter(strike => {
        strike.life--;
        return strike.life > 0;
    });
}
blackHoles = blackHoles.filter(hole => {
    if (Date.now() >= hole.endTime) return false;
    hole.tick++;

    zombies.forEach(z => {
        if (!z.active) return;
        const d = distance(hole, z);

        // ✨ THAY ĐỔI: Sử dụng "pullRadius" để kiểm tra phạm vi
        if (d < hole.pullRadius) {
            // ✨ THAY ĐỔI: Sử dụng "pullRadius" để tính lực hút
            const pullForce = (1 - d / hole.pullRadius) * hole.pullSpeed * 2;

            const angle = Math.atan2(hole.y - z.y, hole.x - z.x);
            z.x += Math.cos(angle) * pullForce;
            z.y += Math.sin(angle) * pullForce;

            if (hole.tick % 30 === 0) {
                dealDamageToZombie(z, hole.damage);
            }
        }
    });
    // 🧲 Hút đạn zombie vào hố đen (giữ nguyên)
    enemyBullets.forEach(b => {
        if (!b.active) return;
        // (Tùy chọn) Bạn cũng có thể đổi "hole.radius" ở đây thành "hole.pullRadius"
        // nếu muốn đạn cũng bị hút từ xa.
        if (distance(hole, b) < hole.pullRadius) { 
            const angle = Math.atan2(hole.y - b.y, hole.x - b.x);
            b.x += Math.cos(angle) * hole.pullSpeed;
            b.y += Math.sin(angle) * hole.pullSpeed;
            if (distance(hole, b) < 20) {
                releaseEnemyBullet(b);
            }
        }
    });
    hole.x += hole.dx;
    hole.y += hole.dy;
    hole.x = Math.max(wallThickness, Math.min(worldWidth - wallThickness, hole.x));
    hole.y = Math.max(wallThickness, Math.min(worldHeight - wallThickness, hole.y));
// Spawn hạt
    if (hole.tick % 3 === 0) {
        createVortexParticle(hole.x, hole.y, hole.pullRadius);
    }
    return true;
});
// 🎯 Clone tự tìm zombie gần và bắn
if (clonesActive) {
    // 1. Kiểm tra hết hạn kỹ năng
    if (Date.now() >= clonesEndTime) {
        clonesActive = false;
        clones = [];
    } else {
        // 2. Logic tìm mục tiêu mới: Tìm zombie gần PLAYER
        const nearbyZombies = zombies
            .filter(z => z.active && distance(player, z) < 600)
            .sort((a, b) => distance(player, a) - distance(player, b));

        // 3. Cập nhật từng clone
        clones.forEach((clone, i) => {
            const target = nearbyZombies[i]; // Clone 0 nhắm mục tiêu gần nhất, Clone 1 nhắm mục tiêu gần thứ hai

            if (target) {
                const angle = Math.atan2(target.y - clone.y, target.x - clone.x);
                const dist = distance(clone, target);

                // Di chuyển nếu ở quá xa mục tiêu
                if (dist > 250) {
                    clone.x += Math.cos(angle) * clone.moveSpeed;
                    clone.y += Math.sin(angle) * clone.moveSpeed;
                }

                // Bắn đạn mỗi giây
                if (Date.now() - clone.lastShot >= 1000) {
                    clone.lastShot = Date.now();
                    clone.shotCount++; // Tăng bộ đếm đạn
                    // --- LOGIC BẮN LAZER MỚI ---
                    if (clone.shotCount >= 3) {
                        clone.shotCount = 0; // Reset bộ đếm
                        playSound('sfx-laser', 0.5);
                        // Tạo hiệu ứng lazer
                        activeCloneLasers.push({
                            cloneId: clone.id, // (THAY ĐỔI) Lưu ID của clone đã bắn
                            endX: target.x, endY: target.y,
                            life: 60 // Lazer clone tồn tại trong 1 giây
                        });

                        // Gây sát thương lazer (ví dụ: gấp 3 sát thương thường)
                        dealDamageToZombie(target, clone.baseDamage * 3);
                        
                    } else {
                        // Bắn đạn thường
                        const b = getBullet();
                        b.x = clone.x;
                        b.y = clone.y;
                        b.dx = Math.cos(angle);
                        b.dy = Math.sin(angle);
                        b.speed = 3;
                        b.active = true;
                        b.customDmg = clone.baseDamage;
                        b.color = "#ff66ff";
                        bullets.push(b);
                    }
                }
            } else {
                // Logic lượn lờ quanh player khi không có mục tiêu (giữ nguyên)
                const distFromPlayer = distance(clone, player);
                if (distFromPlayer > 150) { // Giảm khoảng cách lượn lờ
                    const angleBack = Math.atan2(player.y - clone.y, player.x - clone.x);
                    clone.x += Math.cos(angleBack) * clone.moveSpeed;
                    clone.y += Math.sin(angleBack) * clone.moveSpeed;
                }
            }

            // Giới hạn clone trong bản đồ và giữ khoảng cách (giữ nguyên)
            clone.x = Math.max(wallThickness, Math.min(worldWidth - wallThickness, clone.x));
            clone.y = Math.max(wallThickness, Math.min(worldHeight - wallThickness, clone.y));
        });
    }
}
// Cập nhật và xóa các tia lazer đã hết hạn
activeCloneLasers = activeCloneLasers.filter(laser => {
    laser.life--;
    return laser.life > 0;
});
// === Kỹ năng "🩸 Quả Cầu Hấp Huyết"
if (bloodOrbActive) {
    if (Date.now() > bloodOrbEndTime) {
        bloodOrbActive = false;
        bloodOrbs = [];
        return; // Kết thúc kỹ năng ngay khi hết thời gian
    }

    bloodOrbs.forEach(o => {
        o.angle += 0.01; // Tốc độ xoay quanh player
        o.x = player.x + Math.cos(o.angle) * o.radius;
        o.y = player.y + Math.sin(o.angle) * o.radius;

        // Tìm zombie gần nhất trong bán kính 300
        let nearest = null;
        let nearestDist = Infinity;
        zombies.forEach(z => {
            if (!z.active) return;
            const d = distance(o, z);
            if (d < 300 && d < nearestDist) {
                nearest = z;
                nearestDist = d;
            }
        });

        if (nearest !== o.target) {
            o.target = nearest;
            o.lockTime = Date.now();
        }

        if (!o.target) return;

        // Chỉ hút máu sau khi lock mục tiêu 0.4 giây
        if (Date.now() - o.lockTime > 400 && Date.now() - bloodOrbLastDrain > 300) {
            bloodOrbLastDrain = Date.now();
            const skill = activeSkills.find(s => s.name === "Quả cầu hấp huyết");
            dealDamageToZombie(o.target, skill?.baseDamage || 1);
            player.hearts++;
            createHealImpactEffect(player, 1);
            // Trong update Blood Orb mỗi lần hút máu:
for (let i = 0; i < 2; i++) {
    createBloodOrbParticle(o);
}
// Trong hút máu Blood Orb:
for (let i = 0; i < 2; i++) {
    createBloodOrbParticleOnBeam(o);
}
}
});
}
// Kỹ năng Lôi
if (thunderActive) {
  const now = Date.now();
  const remaining = Math.ceil((thunderEndTime - now) / 1000);
  const thunderBtn = document.getElementById("thunderBtn");

  if (remaining > 0) {
    thunderBtn.innerText = `🔵 ${remaining}s`;
  } else {
    thunderActive = false;
    thunderBalls.length = 0;
    thunderBtn.innerText = "🔵 Lôi";
    thunderBtn.classList.remove("active");
  }

thunderBalls.forEach(ball => {
    // Logic xoay quanh và va chạm (giữ nguyên)
    ball.angle += 0.02;
    ball.x = player.x + Math.cos(ball.angle) * ball.radius;
    ball.y = player.y + Math.sin(ball.angle) * ball.radius;

    zombies.forEach(z => {
      if (z.active && distance(ball, z) < 40) {
        if (!z.thunderCooldown || now > z.thunderCooldown) {
          dealDamageToZombie(z, skillUpgrades.thunderDamage + playerUpgrades.damageBoost);
          z.stunnedByThunder = true;
          z.stunnedThunderUntil = Date.now() + 800;
          z.thunderCooldown = now + 100;
          const pushBack = 16;
          const angle = Math.atan2(z.y - player.y, z.x - player.x);
          z.x += Math.cos(angle) * pushBack;
          z.y += Math.sin(angle) * pushBack;
        }
      }
    });

    // Logic tấn công bằng tia sét
    if (now > ball.nextZapTime) {
        const target = zombies
            .filter(z => z.active && distance(ball, z) < 250)
            .sort((a,b) => distance(ball, a) - distance(ball, b))[0];

        if (target) {
            dealDamageToZombie(target, (skillUpgrades.thunderDamage + playerUpgrades.damageBoost) / 2);
            
            // BỔ SUNG: Gán hiệu ứng choáng khi tia sét đánh trúng
            target.stunnedByThunder = true;
            target.stunnedThunderUntil = Date.now() + 800; // Thời gian choáng 0.8 giây

            activeLightningStrikes.push({
                path: getZigZag(ball, target, 4),
                life: 30,
                type: 'chain'
            });
            ball.nextZapTime = now + 2000;
        }
    }
  });
  // ✨ ĐOẠN MÃ BỊ THIẾU NẰM Ở ĐÂY
  // Cập nhật và xóa các tia sét đã hết hạn
  activeLightningStrikes = activeLightningStrikes.filter(strike => {
      strike.life--; // Giảm thời gian tồn tại
      return strike.life > 0; // Chỉ giữ lại những tia sét còn "sống"
  });
}
// Cập nhật trạng thái và hồi máu cho Hào quang
if (supportAuraActive) {
    if (Date.now() > supportAuraEndTime) {
        supportAuraActive = false;
        auraCrackLines = [];
        auraLightBeams = [];
        document.getElementById("supportAuraBtn").classList.remove("active");
    } else {
        // Hồi HP mỗi 3 giây
        if (Date.now() - lastAuraHealTime > 3000) {
            lastAuraHealTime = Date.now();
            
            // ✨ BẮT ĐẦU LOGIC HỒI MÁU MỚI ✨
            const baseHeal = 1;
            const bonusHeal = skillUpgrades.auraHealLevel;
            const maxHeal = 5; // Giới hạn hồi máu tối đa

            // Tính toán tổng số máu được hồi và đảm bảo không vượt quá giới hạn
            const totalHeal = Math.min(baseHeal + bonusHeal, maxHeal);
            
            player.hearts += totalHeal;
            
            // Hiển thị popup với số máu đã hồi
            createHealImpactEffect(player, totalHeal);
            // ✨ KẾT THÚC LOGIC HỒI MÁU MỚI ✨
        }
        // --- LOGIC TẠO HIỆU ỨNG MỚI ---
        const auraRadiusX = 50;

        // 1. Tạo các hạt vàng bay lên
        if (frame % 15 === 0) {
            const pX = (player.x - auraRadiusX) + Math.random() * (auraRadiusX * 2);
            const pY = player.y + player.size - 5;
            
            particles.push({
                x: pX, y: pY,
                type: 'aura_particle', // Đánh dấu đây là hạt bay lên
                vx: (Math.random() - 0.5) * 0.1, // <--- Hướng bay ngang ngẫu nhiên
                vy: -0.5 - Math.random() * 0.5,   // <--- Hướng bay lên trên
                size: 0.5 + Math.random() * 0.5,  // <--- Kích thước của hạt
                color: 'rgba(255, 215, 0, 0.8)', // <--- Màu sắc của hạt
                alpha: 1,
                alphaDecay: 0.005 // (MỚI) Tốc độ mờ dần riêng
            });
        }
        
        // 2. Tạo các cột sáng
        if (frame % 20 === 0) {
            const beamX = (player.x - auraRadiusX) + Math.random() * (auraRadiusX * 2);
            auraLightBeams.push({
                x: beamX,
                width: 0.5 + Math.random() * 1,
                alpha: 0,
                life: 60,
                initialLife: 60,
            });
        }

        // Cập nhật nút bấm
        const remain = Math.ceil((supportAuraEndTime - Date.now()) / 1000);
        document.getElementById("supportAuraBtn").innerText = `✨ ${remain}s`;
    }
} else if (document.getElementById("supportAuraBtn").innerText !== "✨ Heal") {
    document.getElementById("supportAuraBtn").innerText = "✨ Heal";
}

auraLightBeams = auraLightBeams.filter(beam => {
    beam.life--;
    // Hiệu ứng alpha mờ vào rồi mờ ra
    beam.alpha = Math.sin((1 - beam.life / beam.initialLife) * Math.PI);
    return beam.life > 0;
});
// ================== CẬP NHẬT CỔNG KHÔNG GIAN ==================
// GIAI ĐOẠN 1: THU NHỎ KHI ĐANG DỊCH CHUYỂN
if (player.isTeleporting) {
    player.size *= 0.92; // Thu nhỏ người chơi
    if (spaceGate) {
        spaceGate.radius *= 0.92; // Thu nhỏ cổng
    }

    // Khi đã đủ nhỏ thì thực hiện dịch chuyển
    if (player.size < 1) {
        player.isTeleporting = false; // Dừng thu nhỏ
        player.isGrowingAfterTeleport = true; // Bắt đầu phóng to

        const targetLocation = findSafeTeleportLocation();
        player.x = targetLocation.x;
        player.y = targetLocation.y;
        
        // ✨ THÊM LẠI DÒNG NÀY ĐỂ BẮT ĐẦU ĐẾM DELAY 1.5 GIÂY
        lastTeleportTime = Date.now();
        
        // Cập nhật camera ngay lập tức
        camera.x = player.x - canvas.width / 2;
        camera.y = player.y - canvas.height / 2;
        camera.x = Math.max(0, Math.min(worldWidth - canvas.width, camera.x));
        camera.y = Math.max(0, Math.min(worldHeight - canvas.height, camera.y));

        // Tạo cổng mới tại điểm đến (nếu kỹ năng còn thời gian)
        if (Date.now() < spaceGateEndTime) {
            createNewGate(player.x, player.y);
        } else {
            spaceGateActive = false;
            spaceGate = null;
        }
    }
}
// GIAI ĐOẠN 2: PHÓNG TO SAU KHI DỊCH CHUYỂN
else if (player.isGrowingAfterTeleport) {
    // Lớn dần về kích thước gốc một cách mượt mà
    player.size += (player.originalSize - player.size) * 0.1;

    // Khi đã gần bằng kích thước gốc thì kết thúc
    if (player.originalSize - player.size < 0.1) {
        player.size = player.originalSize; // Hoàn tác về kích thước chuẩn
        player.isGrowingAfterTeleport = false; // Kết thúc

        // Đẩy nhẹ người chơi ra để tránh vào lại cổng ngay
        const pushAngle = Math.random() * Math.PI * 2;
        player.x += Math.cos(pushAngle) * 40;
        player.y += Math.sin(pushAngle) * 40;
    }
}
// TRẠNG THÁI CỔNG BÌNH THƯỜNG (khi không dịch chuyển)
else if (spaceGateActive && spaceGate) {
    const now = Date.now();
    
    // Hủy cổng khi hết giờ
    if (now > spaceGateEndTime) {
        spaceGateActive = false;
        spaceGate = null;
    } else {
        // --- CÁC CẬP NHẬT XẢY RA MỖI FRAME ---
        if (spaceGate.alpha < 1) spaceGate.alpha += 0.05;
        spaceGate.rotation += 0.04;

        // --- CÁC CẬP NHẬT TỐI ƯU (CHỈ CHẠY MỖI 3 FRAME) ---
        if (frame % 3 === 0) {
            // 1. Tạo hạt màu vàng trang trí
            createGateOrbitParticle(spaceGate);

            // 2. Xử lý hút và sát thương (zombie và đạn)
            // ✨ Giữ nguyên chỉ số PULL_RADIUS = 80 của bạn
            const PULL_RADIUS = 80, KILL_RADIUS = 25, PULL_SPEED = 1.8;
            const PULL_RADIUS_SQ = PULL_RADIUS * PULL_RADIUS;
            const KILL_RADIUS_SQ = KILL_RADIUS * KILL_RADIUS;
            const BULLET_PULL_SPEED = PULL_SPEED * 2.5;

            // Vòng lặp xử lý ZOMBIE
            zombies.forEach(z => {
                if (!z.active) return;
                const dSq = distanceSq(spaceGate, z);

                if (dSq < PULL_RADIUS_SQ) {
                    const angle = Math.atan2(spaceGate.y - z.y, spaceGate.x - z.x);
                    z.x += Math.cos(angle) * PULL_SPEED;
                    z.y += Math.sin(angle) * PULL_SPEED;
                    if (!z.gateDamageCooldown || now > z.gateDamageCooldown) {
                        dealDamageToZombie(z, spaceGate.damage);
                        z.gateDamageCooldown = now + 500;
                    }
                }
                
                if (dSq < KILL_RADIUS_SQ) {
                    killZombie(z);
                    explosions.push(getExplosion(z.x, z.y));
                }
            });
            
            // Vòng lặp xử lý ĐẠN
            enemyBullets.forEach(b => {
                if (!b.active) return;
                const dSq = distanceSq(spaceGate, b);

                if (dSq < PULL_RADIUS_SQ) {
                    const angle = Math.atan2(spaceGate.y - b.y, spaceGate.x - b.x);
                    b.x += Math.cos(angle) * BULLET_PULL_SPEED;
                    b.y += Math.sin(angle) * BULLET_PULL_SPEED;
                    
                    if (dSq < KILL_RADIUS_SQ) { 
                        releaseEnemyBullet(b);
                        explosions.push(getExplosion(b.x, b.y));
                    }
                }
            });
        }

        // Kích hoạt dịch chuyển khi người chơi bước vào (giữ nguyên)
        const canUseGate = now > lastTeleportTime + GATE_COOLDOWN;
        if (canUseGate && distance(player, spaceGate) < spaceGate.radius) {
            player.originalSize = player.size; 
            player.isTeleporting = true;
        }
    }
}

// --- Logic Kỹ năng Fairy ---
if (fairyActive) {
    const now = Date.now();
    const fairyBtn = document.getElementById("fairyBtn");

    // 1. Kiểm tra hết hạn và cập nhật nút
    if (now > fairyEndTime) {
        fairyActive = false;
        fairies = [];
        // Trừ đi lượng sát thương đã cộng vào
        playerUpgrades.damageBoost -= fairyDamageBonus;
        fairyDamageBonus = 0;
        fairyBtn.classList.remove("active");
        fairyBtn.innerText = "🦋 Fairy";
    } else {
        fairyBtn.classList.add("active");
        const remain = Math.ceil((fairyEndTime - now) / 1000);
        fairyBtn.innerText = `🦋 ${remain}s`;

        // 2. Tính toán hiệu ứng buff dựa trên ngày/đêm
        let healAmount = 0;
        let damageAmount = 0;

        if (isNight()) {
            healAmount = 2 + (skillUpgrades.fairyHealLevel * 2);
            damageAmount = 1 + (skillUpgrades.fairyDamageLevel * 0.5); // Ban đêm tăng ít hơn
        } else {
            healAmount = 1 + (skillUpgrades.fairyHealLevel * 1); // Ban ngày tăng ít hơn
            damageAmount = 2 + skillUpgrades.fairyDamageLevel;
        }

        // Giới hạn hồi máu tối đa
        healAmount = Math.min(healAmount, isNight() ? 10 : 5);

        // 3. Áp dụng buff sát thương
        // Trừ bonus cũ, cộng bonus mới để luôn cập nhật đúng
        playerUpgrades.damageBoost -= fairyDamageBonus;
        fairyDamageBonus = damageAmount * skillUpgrades.fairyCount; // Mỗi Fairy cộng 1 lần
        playerUpgrades.damageBoost += fairyDamageBonus;

        // 4. Áp dụng hồi máu mỗi giây
        if (now - lastFairyHealTime > 3000) {
            // ✨ 1. Tính toán tổng số máu được hồi và lưu vào biến 'totalHeal'
            const totalHeal = healAmount * skillUpgrades.fairyCount;
            
            // 2. Hồi máu cho người chơi
            player.hearts += totalHeal;
            lastFairyHealTime = now;
            
            // 3. Gọi hiệu ứng popup (nếu có máu được hồi)
            if (totalHeal > 0) {
                 createHealImpactEffect(player, totalHeal);
            }
        }
        // 5. Di chuyển các Fairy và tạo hiệu ứng hạt
        fairies.forEach((fairy, index) => {
            fairy.angle += 0.02;
            fairy.x = player.x + Math.cos(fairy.angle) * fairy.orbitRadius;
            const bob = Math.sin(frame * 0.05 + fairy.bobOffset) * 5;
            fairy.y = player.y + Math.sin(fairy.angle) * fairy.orbitRadius + bob;

            if (frame % 5 === 0) { // Giảm tần suất tạo hạt
                createFairyParticle(fairy.x, fairy.y);
            }
                        // ✨ BẮT ĐẦU LOGIC TẤN CÔNG MỚI
            if (now > fairy.nextAttackTime) {
                fairy.nextAttackTime = now + 1000; // Thời gian fairy tấn công

                let nearestZombie = null;
                let minDistance = 600;
                zombies.forEach(z => {
                    if (z.active && !z.isSleeping) { // Thêm điều kiện không tấn công zombie đang ngủ
                        const d = distance(fairy, z);
                        if (d < minDistance) {
                            minDistance = d;
                            nearestZombie = z;
                        }
                    }
                });

                // ✨ NẾU TÌM THẤY MỤC TIÊU THÌ MỚI TẤN CÔNG VÀ BẮT ĐẦU HỒI CHIÊU ✨
                if (nearestZombie) {
                    // Đặt lại thời gian hồi chiêu NGAY SAU KHI TẤN CÔNG
                    fairy.nextAttackTime = now + 1000;

                    // Lấy một viên đạn từ kho và bắn
                    const b = getBullet();
                    b.x = fairy.x; // Vị trí bắt đầu là từ Fairy
                    b.y = fairy.y;
                    
                    // 2. Tính toán hướng bay tới mục tiêu
                    const angle = Math.atan2(nearestZombie.y - fairy.y, nearestZombie.x - fairy.x);
                    b.dx = Math.cos(angle);
                    b.dy = Math.sin(angle);
                    
                    // 3. Gán các thuộc tính đặc biệt cho đạn của Fairy
                    b.speed = 2;
                    b.isFairyBullet = true; // Đánh dấu đây là đạn của Fairy
                    b.piercing = false;      // Đạn sẽ biến mất khi trúng mục tiêu
                    b.effect = isNight() ? 'sleep' : 'wandering'; // Gán hiệu ứng
                    
                    // 4. Thêm viên đạn vào hệ thống chung của game
                    bullets.push(b);
                }
            }
            // ✨ KẾT THÚC LOGIC TẤN CÔNG MỚI
        });
        
    }
}
    // --- Cập nhật hiệu ứng Power & Crazy ---
    
    // Xử lý Power Buff
const wasPowerBuffActive = isPowerBuffActive;
    isPowerBuffActive = now < powerBuffEndTime;

    // Nếu buff đã được kích hoạt và chưa có bonus
    if (isPowerBuffActive && !wasPowerBuffActive) {
        // Buff vừa được kích hoạt: Tính bonus theo công thức (dmg * 1.5) + 2
        powerBuffDamageBonus = (playerUpgrades.damageBoost * 1.5) + 2;
        playerUpgrades.damageBoost += powerBuffDamageBonus;
        updateStatsOverlay();
    } else if (!isPowerBuffActive && wasPowerBuffActive) {
        // Buff vừa hết hạn: Trừ đi đúng lượng bonus đã cộng vào
        playerUpgrades.damageBoost -= powerBuffDamageBonus;
        powerBuffDamageBonus = 0;
        updateStatsOverlay();
    }

    // --- XỬ LÝ CRAZY BUFF (ĐÃ SỬA LỖI) ---
    const wasCrazyBuffActive = isCrazyBuffActive;
    isCrazyBuffActive = now < crazyBuffEndTime;

    if (isCrazyBuffActive && !wasCrazyBuffActive) {
        // Buff vừa được kích hoạt
        // 1. Tính bonus sát thương theo công thức (dmg * 0.5) + 1
        const crazyDamageBonus = (playerUpgrades.damageBoost * 0.5) + 1;
        // 2. Lưu lại tất cả các bonus sẽ được cộng vào
        crazyBuffStats = { speed: 1, bulletSpeed: 1, damage: crazyDamageBonus, lineBulletCount: 1, fireRate: 10 };
        
        // 3. Cộng các bonus vào chỉ số của người chơi
        player.speed += crazyBuffStats.speed;
        playerUpgrades.bulletSpeed += crazyBuffStats.bulletSpeed;
        playerUpgrades.damageBoost += crazyBuffStats.damage;
        playerUpgrades.lineBulletCount += crazyBuffStats.lineBulletCount;
        playerUpgrades.fireRate += crazyBuffStats.fireRate;
        updateStatsOverlay();
    } else if (!isCrazyBuffActive && wasCrazyBuffActive) {
        // Buff vừa hết hạn: Trừ đi đúng các bonus đã cộng
        player.speed -= crazyBuffStats.speed;
        playerUpgrades.bulletSpeed -= crazyBuffStats.bulletSpeed;
        playerUpgrades.damageBoost -= crazyBuffStats.damage;
        playerUpgrades.lineBulletCount -= crazyBuffStats.lineBulletCount;
        playerUpgrades.fireRate -= crazyBuffStats.fireRate;
        // Reset lại đối tượng bonus
        crazyBuffStats = { speed: 0, bulletSpeed: 0, damage: 0, lineBulletCount: 0, fireRate: 0 };
        updateStatsOverlay();
    }
// Logic hút vật phẩm của Nam châm
    if (Date.now() < magnetBuffEndTime) {
        const magnetRadius = 200; // Bán kính hút vật phẩm
        // Danh sách các loại buff sẽ KHÔNG bị hút
        const buffTypes = ['lucky', 'power', 'crazy', 'exp', 'magnet', 'secret', 'expBonus'];
        // --- KẾT THÚC THAY ĐỔI ---

        items.forEach(item => {
            // THÊM ĐIỀU KIỆN: Nếu vật phẩm là một trong các loại buff, bỏ qua không hút
            if (buffTypes.includes(item.type)) return;

            if (item.active && distance(player, item) < magnetRadius) {
                // Di chuyển vật phẩm về phía người chơi
                const angle = Math.atan2(player.y - item.y, player.x - item.x);
                item.x += Math.cos(angle) * 5; // Tốc độ hút
                item.y += Math.sin(angle) * 5; // Tốc độ hút
            }
        });
    }

updateParticles();
updatePet();   // 🐰 xử lý pet mỗi frame
zombies = zombies.filter(z => z.active);
zombies.forEach(z => updateBigBossLazer(z, globalDeltaTime));
  updateUI();
  updateStatsOverlay();
  updateMusic(); // Gọi hàm kiểm tra nhạc trong mỗi khung hình
    const skillsOverlay = document.getElementById('skillsOverlay');
  if (skillsOverlay && !skillsOverlay.classList.contains('hidden')) {
    updateSkillsList();
  }
  updateEnemyBullets();
}
// Lazer boss
function updateBigBossLazer(z, deltaTime) {
    if (!z.active || !z.isBigBoss) return;

    if (z.lazerDamageCooldown === undefined) z.lazerDamageCooldown = 0;
    if (z.isChargingLazer === undefined) z.isChargingLazer = false;

    const distanceToPlayer = distance(z, player);
    const ATTACK_RANGE = 600; // Tầm bắt đầu ngắm bắn
    const CHARGE_TIME = 2; // Thời gian ngắm bắn là 2 giây
    
    // Lấy thẻ audio của âm thanh "gồng"
    const chargeSound = document.getElementById('sfx-lazer-charging');

    // Nếu người chơi ở ngoài tầm và boss không đang bắn
    if (distanceToPlayer > ATTACK_RANGE && !z.isLazerAttacking) {
        // Nếu boss ĐANG gồng thì phải tắt âm thanh đi
        if (z.isChargingLazer && chargeSound) {
            chargeSound.pause();
            chargeSound.currentTime = 0;
        }
        z.isChargingLazer = false;
        z.lazerTimer = 0;
    } 
    // Nếu người chơi ở trong tầm và boss chưa làm gì cả
    else if (distanceToPlayer < ATTACK_RANGE && !z.isLazerAttacking && !z.isChargingLazer) {
        z.isChargingLazer = true; // Bắt đầu gồng
        z.lazerTimer = 0;
        
        // Bắt đầu phát âm thanh gồng
        if (chargeSound) {
            chargeSound.volume = 0.5; // <-- THÊM DÒNG NÀY (0.5 = 50% âm lượng)
            chargeSound.play();
    }
  }
    // Nếu đang trong giai đoạn gồng laze
    if (z.isChargingLazer) {
        z.lazerTimer += deltaTime;
        // Nếu gồng đủ 2 giây thì bắn
        if (z.lazerTimer > CHARGE_TIME) {
            z.isChargingLazer = false;
            z.isLazerAttacking = true;
            
            // Dừng âm thanh gồng
            if (chargeSound) {
                chargeSound.pause();
                chargeSound.currentTime = 0;
            }
            // Phát âm thanh bắn
            playSound('sfx-bigboss-laser', 0.5);
            
            z.lazerDuration = 2;
            z.lazerTimer = 0;
            z.lazerAngle = Math.atan2(player.y - z.y, player.x - z.x);
        }
    }

    // Giai đoạn bắn tia lazer
    if (z.isLazerAttacking) {
        z.lazerDuration -= deltaTime;
        if (z.lazerDuration <= 0) {
            z.isLazerAttacking = false;
        }
        
        if (z.lazerAngle !== undefined) {
            const proj = (player.x - z.x) * Math.cos(z.lazerAngle) + (player.y - z.y) * Math.sin(z.lazerAngle);
            const perp = Math.abs((player.x - z.x) * Math.sin(z.lazerAngle) - (player.y - z.y) * Math.cos(z.lazerAngle));
            
            const lazerRange = 600;
            const lazerWidth = 18;
            const lazerCooldown = 60;

            if (proj > 0 && proj < lazerRange && perp < lazerWidth) {
                if (z.lazerDamageCooldown <= 0 && player.hearts > 0) {
                    if (player.shieldActive) {
                      const now = Date.now();
                        // Dùng chung cooldown với va chạm zombie để tránh spam âm thanh
                        if (now - lastShieldBlockSoundTime > 100) {
                            playSound('sfx-shield-block', 0.3); // 30% âm lượng
                            lastShieldBlockSoundTime = now;
                        }
                        if (frame % 3 === 0) {
                            createParticleExplosion(player.x, player.y, 2, 'smoke');
                        }
                    } else {
                        const lazerDamage = calculateZombieDamage(z);
                        if (supportAuraActive) {
                            lazerDamage *= 0.5;
                        }
                        player.hearts -= lazerDamage;
                        z.lazerDamageCooldown = lazerCooldown;
                        createDamageImpactEffect(player, lazerDamage);
                        if (player.hearts <= 0) {
                            handlePlayerDeath(); 
                        }
                    }
                }
            }
          }
        
        if (z.lazerDamageCooldown > 0) z.lazerDamageCooldown--;
    }
}
// === 🌍 MINI MAP ===
// Toàn bản đồ rộng 3000 x 2000 (có thể điều chỉnh)
const worldWidth = 3000;
const worldHeight = 2000;
const wallThickness = 10; // Độ dày tường viền bản đồ
const miniMapCanvas = document.getElementById("miniMap");
const miniCtx = miniMapCanvas.getContext("2d");
let showMiniMap = false; //false để ẩn ban đầu

// Bắt phím M để bật/tắt
document.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "m") {
    showMiniMap = !showMiniMap;
    miniMapCanvas.style.display = showMiniMap ? "block" : "none";
  }
  // ⌨️ Ẩn/hiện menu UI khi bấm phím t
  if (e.key.toLowerCase() === "t") {
    uiVisible = !uiVisible;
    const ui = document.getElementById("ui");
    ui.style.display = uiVisible ? "flex" : "none";
}
});

// Hàm vẽ mini map
function drawMiniMap() {
  if (!showMiniMap) return;

  miniCtx.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

  const scaleX = miniMapCanvas.width / worldWidth;
  const scaleY = miniMapCanvas.height / worldHeight;
 // 👇 mới thêm – dễ chỉnh kích thước sau này
  const ITEM_SIZE   = 1.2;   // chiều rộng/ cao dấu vật phẩm (px trên minimap)
  const ZOMBIE_SIZE = 2;     // zombie thường (ô vuông)
  const DOT_PLAYER  = 3;     // bán kính chấm player & boss/mini
    // --- BẮT ĐẦU PHẦN BỔ SUNG ---
  // Vẽ các hòm tiếp tế (🪂) đang rơi
  supplyDrops.forEach(drop => {
      const mapX = drop.x * scaleX;
      const mapY = drop.y * scaleY;
      
      miniCtx.fillStyle = "cyan"; // Chấm màu xanh cyan cho dễ thấy
      miniCtx.beginPath();
      miniCtx.arc(mapX, mapY, 2, 0, Math.PI * 2); // Vẽ một chấm tròn
      miniCtx.fill();
  });
  // --- KẾT THÚC PHẦN BỔ SUNG ---

// Draw items (energy, mana, hp)
for (let it of items) {
  if (!it.active) continue;
  switch (it.type) {
    case "energy": miniCtx.fillStyle = "yellow"; break; // Màu vàng cho năng lượng
    case "mana": miniCtx.fillStyle = "cyan"; break; // Màu xanh lam cho mana
    case "hp": miniCtx.fillStyle = "lime"; break; // Màu xanh lá cây cho HP
    case "box": miniCtx.fillStyle = "blue"; break; // Màu xanh dương cho hộp
    
    // Thêm các trường hợp mới cho các vật phẩm đặc biệt
    case "lucky": miniCtx.fillStyle = "#22c55e"; break; // Màu xanh lá cây cho Lucky
    case "power": miniCtx.fillStyle = "#ef4444"; break; // Màu đỏ cho Power
    case "crazy": miniCtx.fillStyle = "#f59e0b"; break; // Màu vàng cam cho Crazy
    case "exp": miniCtx.fillStyle = "#ffeb3b"; break; // Màu vàng cho Exp
    case "magnet": miniCtx.fillStyle = "#8b5cf6"; break; // Màu tím cho Magnet
    case "secret": miniCtx.fillStyle = "violet"; break; // Màu tím đậm cho Secret
    case "expBonus": miniCtx.fillStyle = "gold"; break; // Màu vàng kim cho ExpBonus
    case "potion": miniCtx.fillStyle = "red"; break; // Ví dụ: chấm màu đỏ

    default: miniCtx.fillStyle = "gray";
  }
  miniCtx.fillRect(it.x * scaleX - 0.5, it.y * scaleY - 0.5, 1, 1); // Vẽ kích thước vật phẩm trên minimap
}
// 💜 Vẽ clone trên minimap
clones.forEach(clone => {
  const mapX = (clone.x / worldWidth) * miniMapCanvas.width;
  const mapY = (clone.y / worldHeight) * miniMapCanvas.height;
  miniCtx.fillStyle = "#cc66ff";
  miniCtx.beginPath();
  miniCtx.arc(mapX, mapY, 2, 0, Math.PI * 2);
  miniCtx.fill();
});
// 🟦 Vẽ máy bay trên minimap
activePlanes.forEach(plane => {
  const mapX = (plane.x / worldWidth) * miniMapCanvas.width;
  const mapY = (plane.y / worldHeight) * miniMapCanvas.height;
  miniCtx.fillStyle = "#cc66ff";
  miniCtx.beginPath();
  miniCtx.arc(mapX, mapY, 2, 0, Math.PI * 2);
  miniCtx.fill();
});
  // Draw zombies
for (let z of zombies) {
  if (!z.active) continue;

  const mapX = (z.x / worldWidth) * miniMapCanvas.width;
  const mapY = (z.y / worldHeight) * miniMapCanvas.height;

  if (z.isBigBoss) {
    // 💚 BigBoss – to nhất, màu rõ ràng khác hẳn
    miniCtx.fillStyle = "purple";
    miniCtx.beginPath();
    miniCtx.arc(mapX, mapY, 3, 0, Math.PI * 2);
    miniCtx.fill();
  } 
  else if (z.isBoss) {
    // 🔴 Boss thường – màu đỏ hoặc cam, tuỳ bạn
    miniCtx.fillStyle = "orange";
    miniCtx.beginPath();
    miniCtx.arc(mapX, mapY, 2, 0, Math.PI * 2);
    miniCtx.fill();
  } 
  else if (z.type === "miniBoss") {
    // 🟠 MiniBoss – khác boss thường chút
    miniCtx.fillStyle = "gold";
    miniCtx.beginPath();
    miniCtx.arc(mapX, mapY, 1.5, 0, Math.PI * 2);
    miniCtx.fill();
  } 
  else {
    // 🔲 Zombie thường – vuông nhỏ
    miniCtx.fillStyle = "red";
    miniCtx.fillRect(mapX - 1, mapY - 1, 2, 2);
  }
}
  // Draw player
  miniCtx.fillStyle = "#00ccff";  // Xanh dương đồng bộ tên
  miniCtx.beginPath();
  miniCtx.arc(player.x * scaleX, player.y * scaleY, 2, 0, Math.PI * 2);
  miniCtx.fill();
  /* — chấm pet Thỏ màu hồng — */
if (petRabbit && petActive) {
  miniCtx.fillStyle = "#ff4dc4";          // hồng đậm
  miniCtx.beginPath();
  miniCtx.arc(petRabbit.x * scaleX, petRabbit.y * scaleY, 2, 0, Math.PI * 2);
  miniCtx.fill();
}
}
// 🎨 Vẽ đường chéo sọc (diagonal stripes) trên canvas
function drawDiagonalStripes(ctx, x, y, width, height, stripeColor = "#666", spacing = 10) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(x, y, width, height);
  ctx.clip();

  ctx.strokeStyle = stripeColor;
  ctx.lineWidth = 1; // Độ dày đường sọc

  const maxLength = width + height;
  for (let i = -height; i < maxLength; i += spacing) {
    ctx.beginPath();
    ctx.moveTo(x + i, y);
    ctx.lineTo(x + i - height, y + height);
    ctx.stroke();
  }

  ctx.restore();
}
function drawBloodOrb(ctx) {
    if (!bloodOrbActive) return;
    bloodOrbs.forEach(o => {
        ctx.save();
        ctx.translate(o.x, o.y);

        // Quả cầu tự xoay quanh chính nó
        ctx.rotate(frame / 100);

        // === Vẽ các gai dài ===
        ctx.shadowBlur = 6;         // Thêm blur cho các gai
        ctx.shadowColor = "red";
        for (let i = 0; i < 12; i++) {
            const angle = (Math.PI * 2 / 12) * i;
            const x = Math.cos(angle) * 24; // Gai dài hơn hẳn
            const y = Math.sin(angle) * 24;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(x, y);
            ctx.strokeStyle = "rgba(50, 0, 0, 0.7)";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // === Vẽ vòng tròn ngoài tối, viền đỏ bóng ===
        ctx.beginPath();
        ctx.arc(0, 0, 16, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(60, 0, 0, 0.9)";
        ctx.strokeStyle = "rgba(255,0,0,0.7)";
        ctx.lineWidth = 2;
        ctx.fill();
        ctx.stroke();

        // === Vẽ vòng tròn trong đỏ nhạt, trong suốt hơn ===
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255, 80, 80, 0.05)"; // 📍 Đỏ rất nhạt, trong suốt
        ctx.fill();
        ctx.restore();

        // === Icon 🩸 chính giữa ===
        ctx.font = "1rem Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "white";
        ctx.fillText("🩸", o.x, o.y);

        // === Beam nhịp tim ===
        if (!o.target) return;
        const z = o.target;
        ctx.beginPath();
        ctx.moveTo(o.x, o.y);
        const segments = 16;
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const x = o.x + (z.x - o.x) * t;
            const y = o.y + (z.y - o.y) * t + Math.sin(t * 6 * Math.PI + frame / 8) * 5;
            ctx.lineTo(x, y);
        }
        ctx.strokeStyle = "rgba(255,0,0,0.6)";
        ctx.lineWidth = 2;
        ctx.shadowBlur = 4;
        ctx.shadowColor = "red";
        ctx.stroke();
        ctx.shadowBlur = 0;
    });
}
/**
 * Tạo hiệu ứng chữ "+EXP" bay lên khi nhận được kinh nghiệm.
 * @param {object} target - Đối tượng bị tiêu diệt (thường là zombie).
 * @param {number} amount - Lượng EXP nhận được.
 */
function createExpGainEffect(target, amount) {
    // Chỉ tạo hiệu ứng nếu nhận được EXP
    if (amount <= 0) return;

    // Tạo popup số EXP nhận được
    const radius = target.radius || target.size || 15;
    healEffects.push({
        x: target.x + 36 + (Math.random() - 0.5) * 10, // Lệch sang phải
        y: target.y - radius,
        life: 120,
        maxLife: 120,
        text: `+${amount} exp`,
        delay: 0,
        color: 'gold' // Màu vàng
    });
}
/**
 * Tạo hiệu ứng khi một mục tiêu được hồi máu.
 * @param {object} target - Đối tượng được hồi máu (thường là player).
 * @param {number} amount - Lượng máu được hồi.
 */
function createHealImpactEffect(target, amount) {
    // 1. Tạo popup số máu hồi màu xanh lá
    const radius = target.radius || target.size || 15;
    healEffects.push({
        x: target.x + (Math.random() - 0.5) * 10,
        y: target.y - radius * 2,
        life: 120,
        maxLife: 120,
        text: `+${amount}💚`,
        delay: 0,
        color: 'lime'
    });

    // 2. Tạo hiệu ứng các hạt xanh lá bay ra
    for (let i = 0; i < 5; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 1.5 + 0.5;
        particles.push({
            x: target.x, y: target.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 2 + 1,
            color: 'rgba(50, 205, 50, 0.7)',
            alpha: 1,
            fastFade: true
        });
    }
}
/**
 * Tạo hiệu ứng khi một mục tiêu bị dính sát thương.
 * @param {object} target - Đối tượng bị dính sát thương (player hoặc zombie).
 * @param {number} amount - Lượng sát thương.
 */
function createDamageImpactEffect(target, amount) {
    // --- BẮT ĐẦU THÊM MỚI ---
    // Nếu đối tượng chịu sát thương là người chơi, phát âm thanh "hurt"
    if (target === player) {
        playSound('sfx-player-hurt', 0.3); // Phát ở 30% âm lượng
    }
    // --- KẾT THÚC THÊM MỚI ---

    let effectColor, particleColor;
    
    if (target === player) {
        // Nếu là người chơi, máu vẫn màu đỏ
        effectColor = '#ff4c4c';
        particleColor = 'rgba(255, 0, 0, 0.7)';
    } else {
        // ✨ THAY ĐỔI: Nếu là zombie, máu sẽ màu tím
        effectColor = 'violet';                      // Màu cho chữ -HP
        particleColor = 'rgba(190, 80, 220, 0.7)'; // Màu cho hạt "máu"
    }

    // Tạo popup số sát thương (dùng màu đã chọn)
    const radius = target.radius || target.size || 15;
    healEffects.push({
        x: target.x + (Math.random() - 0.5) * 10,
        y: target.y - radius * 2,
        life: 120,
        maxLife: 120,
        text: `-${amount}`,
        delay: 0,
        color: effectColor
    });

    // Tạo hiệu ứng vệt máu (dùng màu đã chọn)
    for (let i = 0; i < 5; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 1.5 + 0.5;
        particles.push({
            x: target.x, y: target.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 2 + 1,
            color: particleColor,
            alpha: 1,
            fastFade: 0.012
        });
    }
}
// hàm hiệu ứng chặn đạn
function createShieldImpactEffect(x, y) {
    // Tạo ra 5 tia lửa nhỏ bay ra ngẫu nhiên
    for (let i = 0; i < 5; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 1.5 + 0.5;
        particles.push({
            x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 2 + 1,
            color: `rgba(0, 255, 255, ${Math.random() * 0.5 + 0.5})`, // Màu xanh cyan
            alpha: 1,
            fastFade: true // Tan biến nhanh
        });
    }
}

function createBloodOrbParticleOnBeam(orb) {
    if (!orb.target) return;

    // Random vị trí dọc theo beam từ quả cầu tới zombie
    const t = Math.random(); // Từ 0 đến 1
    const x = orb.x + (orb.target.x - orb.x) * t;
    const y = orb.y + (orb.target.y - orb.y) * t;

    const dx = orb.x - x;
    const dy = orb.y - y;
    const speed = 0.5 + Math.random() * 0.5;

    particles.push({
        x: x,
        y: y,
        vx: dx * 0.02 * speed,
        vy: dy * 0.02 * speed,
        alpha: 1,
        size: 1 + Math.random() * 1,
        color: 'rgba(255, 0, 0, 0.6)',
        fastFade: true // Đánh dấu hạt tan nhanh
    });
}
// Vẽ Fairy và hiệu ứng hạt
function createFairyParticle(x, y) {
    particles.push({
        // Loại hạt này không cần type vì dùng logic mặc định
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        size: Math.random() * 0.5 + 0.5,
        color: 'rgba(0, 255, 255, 0.7)', // Màu xanh cyan phát sáng
        alpha: 1,
        fastFade: true // Mờ nhanh
    });
}
// Tạo 1 hạt nhỏ bay ngược vào quả cầu mỗi khi hút máu
function createBloodOrbParticle(orb) {
  createSuctionDust(orb.x, orb.y, 40, "rgba(255,0,0,0.6)", true);
}
/**
 * Sinh 1 hạt bụi bay vào (cx, cy)
 * @param {number} cx, cy   – toạ độ tâm cần hút
 * @param {number} spread   – khoảng đặt hạt (mặc định 250-300 px)
 * @param {string} color    – màu/độ mờ hạt
 * @param {boolean} fast    – tan nhanh (dùng cho tia máu)
 */
function createSuctionDust(cx, cy, spread = 250,
                           color = "rgba(200,200,200,0.5)",
                           fast = false) {
  const a      = Math.random() * Math.PI * 2;
  const r      = spread + Math.random() * 50;
  const px     = cx + Math.cos(a) * r;
  const py     = cy + Math.sin(a) * r;
  const speed  = 0.02;

  particles.push({
    x : px,          y : py,
    vx: (cx - px) * speed,
    vy: (cy - py) * speed,
    size  : 1 + Math.random() * 2,
    alpha : 1,
    color ,
    fastFade: fast // Nếu true, hạt sẽ tan biến nhanh
  });
}
// Hàm mới tạo hạt lốc xoáy cho cổng không gian
function createGateOrbitParticle(gate) {
    const angle = Math.random() * Math.PI * 2;
    // Bán kính quỹ đạo sẽ hơi lớn hơn bán kính của cổng một chút
    const orbitRadius = gate.radius * (1.1 + Math.random() * 0.2);

    particles.push({
        type: 'gate_orbit', // Loại hạt mới để xử lý riêng
        cx: gate.x,
        cy: gate.y,
        orbitRadius: orbitRadius,
        angle: angle,
        orbitSpeed: 0.01 + Math.random() * 0.015, // Tốc độ xoay ngẫu nhiên
        size: 1 + Math.random() * 1.5,
        alpha: 0.9,
        life: 60 + Math.floor(Math.random() * 30), // Tuổi thọ của hạt (frame)
        color: 'rgba(255, 220, 0, 0.8)' // Màu vàng
    });
}
// Hàm mới tạo hạt lốc xoáy cho hố đen
function createVortexParticle(cx, cy, spawnRadius) {
    const angle = Math.random() * Math.PI * 2;
    // Tạo hạt ở một khoảng ngẫu nhiên bên ngoài rìa
    const radius = spawnRadius * (0.8 + Math.random() * 0.4);

    particles.push({
        type: 'blackhole_vortex', // Đánh dấu đây là hạt lốc xoáy
        cx: cx,                   // Lưu tọa độ tâm để xoay quanh
        cy: cy,
        orbitRadius: radius,      // Khoảng cách ban đầu tới tâm
        angle: angle,             // Góc ban đầu
        pullSpeed: 0.5 + Math.random() * 0.5, // Tốc độ bị hút vào
        orbitSpeed: 0.02 + Math.random() * 0.001, // Tốc độ xoay
        size: 1.5 + Math.random() * 1.5,
        alpha: 0.8,
        color: 'rgba(10, 10, 20, 0.7)' // Màu tím đậm vũ trụ
    });
}
function triggerPlayerDyingEffect() {
  playSound('sfx-player-explode', 0.2); // Phát âm thanh nổ
    // Tạo một vụ nổ các hạt màu đỏ tại vị trí người chơi
    for (let i = 0; i < 150; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 6 + 2; // Tốc độ hạt ngẫu nhiên
        const color = `rgba(255, ${Math.random() * 100}, ${Math.random() * 50}, ${Math.random() * 0.5 + 0.5})`;

        particles.push({
            x: player.x,
            y: player.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 4 + 2,
            color: color,
            alpha: 1,
            fastFade: true 
        });
    }
}
function handlePlayerDeath() {
      // Kiểm tra xem kỹ năng Fairy có thể cứu mạng không
    if (fairyActive && fairyDeathDefyAvailable) {
        fairyDeathDefyAvailable = false; // Dùng hết 1 lần cứu mạng
        player.hearts = 10; // Hồi lại 10 HP
        player.hitTimer = 180; // Bất tử 3 giây
        showWarning("🦋 Fairy đã cứu bạn!");
        
        return; 
    }

    if (player.isDying) return; // Ngăn việc gọi lại nhiều lần

    // --- BẮT ĐẦU THÊM MỚI ---
    
    // Dừng tất cả nhạc nền đang phát
    stopAllMusic();
    
    // Phát âm thanh thua cuộc
    playSound('sfx-game-over');

    // --- KẾT THÚC THÊM MỚI ---

    player.isDying = true;
    triggerPlayerDyingEffect();

    // Sau 2 giây, hiện màn hình Game Over
    setTimeout(() => {
        gameOver = true;
        document.getElementById("gameOverPanel").classList.add("visible");
    }, 1500); // 1.5 giây để hiệu ứng kịp diễn ra
}
// Cập nhật trạng thái của tất cả các hạt hiệu ứng trong mỗi khung hình
function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];

// LOGIC CẢI TIẾN: Di chuyển và xử lý va chạm cho icon lửa/băng
        if (p.type === 'fire_spark' || p.type === 'ice_shard') {
            if (!p.target || !p.target.active) {
                particles.splice(i, 1);
                continue;
            }
            
            const angle = Math.atan2(p.target.y - p.y, p.target.x - p.x);
            p.rotation = angle;
            p.x += Math.cos(angle) * p.speed;
            p.y += Math.sin(angle) * p.speed;

            // Nếu icon đã bay tới gần mục tiêu
            if (distance(p, p.target) < p.speed) {
                // Gây sát thương và hiệu ứng TẠI ĐÂY
                if (p.target.active) {
                    dealDamageToZombie(p.target, p.damage);
                    if (p.type === 'fire_spark') {
                        p.target.burnEndTime = Date.now() + 3000;
                        // BỔ SUNG: Thêm hiệu ứng hình ảnh bốc cháy
                        p.target.onFireUntil = Date.now() + 400;
                    } else { // 'ice_shard'
                        p.target.slowEndTime = Date.now() + 3000;
                        // BỔ SUNG: Thêm hiệu ứng hình ảnh đóng băng
                        p.target.onIceUntil = Date.now() + 400;
                    }
                }
                particles.splice(i, 1); // Xóa icon sau khi đã trúng
            }
            continue;
        }
        // (Các logic xử lý hạt khác giữ nguyên)
        if (p.type === 'blackhole_vortex') {
            p.orbitRadius -= p.pullSpeed;
            p.angle += p.orbitSpeed;
            p.x = p.cx + Math.cos(p.angle) * p.orbitRadius;
            p.y = p.cy + Math.sin(p.angle) * p.orbitRadius;
            p.alpha -= 0.015;
            if (p.orbitRadius <= 1 || p.alpha <= 0) {
                particles.splice(i, 1);
                continue;
            }
        } else if (p.type === 'fairy_status_effect') {
            if (p.target && p.target.active) {
                p.angle += 0.1;
                p.x = p.target.x + Math.cos(p.angle) * p.orbitRadius;
                p.y = p.target.y + Math.sin(p.angle) * p.orbitRadius;
                p.life--;
            } else {
                p.life -= 5;
            }
            p.alpha = p.life / p.maxLife;
            if (p.life <= 0) {
                particles.splice(i, 1);
                continue;
            }
        } else if (p.type === 'gate_orbit') {
            p.angle += p.orbitSpeed;
            p.x = p.cx + Math.cos(p.angle) * p.orbitRadius;
            p.y = p.cy + Math.sin(p.angle) * p.orbitRadius;
            p.life--;
            p.alpha = p.life / 90;
            if (p.life <= 0) {
                particles.splice(i, 1);
                continue;
            }
        } else if (p.type === 'aura_particle') {
            p.x += p.vx;
            p.y += p.vy;
            p.alpha -= p.alphaDecay;
        } else {
            if (p.maxDistance !== undefined) {
                const distSq = (p.x - p.originX) ** 2 + (p.y - p.originY) ** 2;
                if (distSq > p.maxDistance ** 2) {
                    p.alpha -= 0.1;
                }
            }
            p.x += p.vx;
            p.y += p.vy;
            if (typeof p.fastFade === 'number') {
                p.alpha -= p.fastFade;
            } else if (p.fastFade === true) {
                p.alpha -= 0.006;
            } else {
                p.alpha -= 0.0006;
            }
        }
        if (p.alpha <= 0) {
            if (particles[i] === p) {
                particles.splice(i, 1);
            }
        }
    }
}
// Vẽ tất cả các hạt hiệu ứng lên canvas
function drawParticles(ctx) {
    particles.forEach(p => {
        // LOGIC VẼ MỚI: Vẽ đốm lửa và mảnh băng tùy chỉnh
        if (p.type === 'fire_spark' || p.type === 'ice_shard') {
            ctx.save();
            // Di chuyển và xoay canvas đến vị trí và hướng của viên đạn
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation || 0);

            if (p.type === 'fire_spark') {
                // Vẽ đốm lửa: Gồm một "đuôi" màu cam và một "đầu" màu vàng sáng
                // Đuôi lửa (mờ hơn)
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = '#ff8c00'; // DarkOrange
                ctx.beginPath();
                ctx.arc(-3, 0, 5, 0, Math.PI * 2); // Vòng tròn lớn hơn ở phía sau
                ctx.fill();

                // Đầu lửa (sáng rõ)
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = '#ffd700'; // Gold
                ctx.beginPath();
                ctx.arc(2, 0, 4, 0, Math.PI * 2); // Vòng tròn nhỏ hơn ở phía trước
                ctx.fill();
            } else { // 'ice_shard'
                // Vẽ mảnh băng: một hình thoi dài, sắc nhọn
                ctx.fillStyle = '#afeeee'; // PaleTurquoise
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(8, 0);   // Mũi nhọn
                ctx.lineTo(-4, -4); // Cạnh trên
                ctx.lineTo(-8, 0);  // Đuôi
                ctx.lineTo(-4, 4);  // Cạnh dưới
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            ctx.restore();
            return; // Bỏ qua, không vẽ hạt tròn mặc định
        }

        // Logic vẽ các hạt mặc định (giữ nguyên)
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.shadowColor = 'purple';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    });
    // Reset độ trong suốt về mặc định
    ctx.globalAlpha = 1;
}
// === 🌗 NGÀY ĐÊM ===
function updateDayNight() {
    const now = Date.now();
    const deltaTime = (now - lastUpdateTime) / 1000;
    lastUpdateTime = now;

    dayTime += deltaTime / dayDuration;
    if (dayTime >= 1) {
        dayTime -= 1; // Reset về 0 liên tục
        currentDay++; // Tăng số ngày khi một ngày mới bắt đầu        
    }
    // Lưu lại để chỗ khác dùng
    globalDeltaTime = deltaTime;
}

function drawBackgroundByTime(ctx) {
    const w = canvas.width;
    const h = canvas.height;

    // 🕒 Tính giờ 0 - 23
    const hour = Math.floor(dayTime * 24) % 24;
    // --- BẮT ĐẦU LOGIC MỚI ---
// Nếu là 9h sáng và sự kiện chưa được kích hoạt trong ngày hôm nay
if (hour === 9 && !morningDropTriggered) {
    triggerSupplyDrop();
    morningDropTriggered = true; // Đánh dấu đã kích hoạt 9h
}
// Nếu là 12h trưa và sự kiện chưa được kích hoạt trong ngày hôm nay
else if (hour === 12 && !morningDropTriggered12h) {
    triggerSupplyDrop();
    morningDropTriggered12h = true; // Đánh dấu đã kích hoạt 12h
}
// Nếu là 15h chiều và sự kiện chưa được kích hoạt trong ngày hôm nay
else if (hour === 15 && !morningDropTriggered15h) {
    triggerSupplyDrop();
    morningDropTriggered15h = true; // Đánh dấu đã kích hoạt 15h
}
// Reset lại các cờ khi qua ngày mới (ví dụ: lúc 0h)
else if (hour === 0) {
    morningDropTriggered = false;
    morningDropTriggered12h = false;
    morningDropTriggered15h = false;
}
    // --- KẾT THÚC LOGIC MỚI ---

    // 🌗 Xác định độ tối / sáng theo thực tế
    let darkness = 0;

    if (hour >= 0 && hour < 4) {
        darkness = 0.6;
    } else if (hour >= 4 && hour < 6) {
        darkness = (6 - hour) / 2 * 0.6; // từ 0.6 -> 0
    } else if (hour >= 6 && hour < 11) {
        darkness = 0;
    } else if (hour >= 11 && hour < 13) {
        darkness = -0.1; // sáng hơn bình thường
    } else if (hour >= 13 && hour < 17) {
        darkness = 0;
    } else if (hour >= 17 && hour < 19) {
        darkness = (hour - 17) / 2 * 0.4; // từ 0 -> 0.4
    } else if (hour >= 19 && hour <= 23) {
        darkness = 0.6;
    }

    // 🌓 Phủ tối hoặc làm sáng hơn
    if (darkness > 0) {
        ctx.fillStyle = `rgba(0, 0, 0, ${darkness})`;
        ctx.fillRect(0, 0, w, h);
    } else if (darkness < 0) {
        ctx.fillStyle = `rgba(255, 255, 255, ${-darkness})`;
        ctx.fillRect(0, 0, w, h);
    }

    // ☀️ / 🌙 Vẽ biểu tượng báo ngày / đêm
    const iconX = 28;
    const iconY = 82; // Vị trí mặt trời

    if (hour >= 6 && hour < 18) {
        ctx.beginPath();
        ctx.arc(iconX, iconY, 14, 0, Math.PI * 2);
        ctx.fillStyle = '#FFD966';
        ctx.fill();
        ctx.strokeStyle = '#CC9900';
        ctx.stroke();
    } else {
        ctx.beginPath();
        ctx.arc(iconX, iconY, 12, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(200, 200, 255, 0.8)`;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(iconX - 4, iconY - 2, 10, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(0,0,0,0.6)`;
        ctx.fill();
    }

    // 🕒 Số giờ 0-23
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(`${hour}`, iconX + 20, iconY);
}
const balloonColors = ['#f87171', '#fbbf24', '#34d399', '#60a5fa', '#c084fc'];
function randomizeBackground() {
    backgroundStars = [];
    backgroundBirds = [];
    backgroundTrees = [];
    backgroundClouds = [];
    backgroundPlanes = [];
    backgroundMushrooms = [];
    backgroundRocks = [];
    backgroundBalloons = [];
    backgroundSeeds = [];
    backgroundBigStars = [];

const bigStarCount = isNight() ? 10 : 3;
for (let i = 0; i < bigStarCount; i++) {
    backgroundBigStars.push([
        Math.random() * worldWidth,
        Math.random() * (worldHeight / 2)
    ]);
}
    // ⭐ Ngôi sao nhỏ, trải dài nửa trên map
const starCount = isNight() ? 300 : 50; // Ban đêm nhiều hơn, ban ngày ít hơn
for (let i = 0; i < starCount; i++) {
    backgroundStars.push([
        Math.random() * worldWidth,
        Math.random() * (worldHeight / 2)
    ]);
}
    // 🕊️ Chim, bay ở cao trung bình
    for (let i = 0; i < 15; i++) {
        backgroundBirds.push([
            Math.random() * worldWidth,
            50 + Math.random() * 100
        ]);
    }

    // 🌳 Cây phía xa dưới mặt đất
    for (let i = 0; i < 50; i++) {
        backgroundTrees.push([
            Math.random() * worldWidth,
            worldHeight - 150 + Math.random() * 20
        ]);
    }

    // ☁️ Mây đơn giản phía trên cây
for (let i = 0; i < 5; i++) {
    backgroundClouds.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 250 - Math.random() * 200,
        size: 0.5 + Math.random() * 1.5,
        speed: 0.05 + Math.random() * 0.1,
        isDark: Math.random() < 0.2 // 20% là mây xám
    });
}
    // ✈️ 🛩️Máy bay đơn giản phía trên mây
const planeIcons = ['✈️', '🛩️', '🚀'];
// Nhóm 1: Dọc rìa trái world map
for (let i = 0; i < 1; i++) {
    backgroundPlanes.push({
        x: -200 - Math.random() * 200,  // rìa trái ngoài map
        y: worldHeight / 2 + Math.random() * (worldHeight / 2), // giữa xuống dưới
        vx: 0.5 + Math.random() * 0.3,
        vy: -0.3 - Math.random() * 0.2,
        size: 0.8 + Math.random() * 1.5,
        opacity: 0.4 + Math.random() * 0.5,
        icon: planeIcons[Math.floor(Math.random() * planeIcons.length)]
    });
}
// Nhóm 2: Trải dài phía dưới toàn bản đồ
for (let i = 0; i < 2; i++) {
    backgroundPlanes.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 100 - Math.random() * 100,
        vx: 0.5 + Math.random() * 0.3,
        vy: -0.3 - Math.random() * 0.2,
        size: 0.8 + Math.random() * 1.5,
        opacity: 0.4 + Math.random() * 0.5,
        icon: planeIcons[Math.floor(Math.random() * planeIcons.length)]
    });
}
    // 🍄 Nấm dưới đất
    for (let i = 0; i < 30; i++) {
        backgroundMushrooms.push([
            Math.random() * worldWidth,
            worldHeight - 70 + Math.random() * 10
        ]);
    }

    // 🪨 Đá nhỏ dưới đất
    for (let i = 0; i < 30; i++) {
        backgroundRocks.push([
            Math.random() * worldWidth,
            worldHeight - 70 + Math.random() * 10
        ]);
    }

    // 🎈 Bóng bay màu ngẫu nhiên giữa map
for (let i = 0; i < 5; i++) {
    backgroundBalloons.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 300 - Math.random() * 100,
        vx: -0.05 + Math.random() * 0.1, // bay nhẹ trái/phải
        speed: 0.15 + Math.random() * 0.1, // bay lên chậm
        color: balloonColors[Math.floor(Math.random() * balloonColors.length)]
    });
}
    // 🌼 Hoa bồ công anh xuất hiện thấp, bay lên cao
for (let i = 0; i < 15; i++) {
    backgroundSeeds.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 300 - Math.random() * 100,
        vx: -0.1 + Math.random() * 0.2, // ngẫu nhiên từ -0.1 (trái) -> +0.1 (phải)
        speed: 0.02 + Math.random() * 0.05
    });
}
}
function drawCuteCloud(ctx, x, y, scale = 1, isDark = false) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    const gradient = ctx.createLinearGradient(0, -20, 0, 20);
    if (isDark) {
        gradient.addColorStop(0, 'rgba(150, 150, 150, 0.5)');
        gradient.addColorStop(1, 'rgba(100, 100, 100, 0.4)');
    } else {
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
        gradient.addColorStop(1, 'rgba(230, 230, 230, 0.7)');
    }
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(-30, 0, 20, Math.PI * 0.5, Math.PI * 1.5);
    ctx.arc(0, -20, 35, Math.PI, 0);
    ctx.arc(30, 0, 20, Math.PI * 1.5, Math.PI * 0.5);
    ctx.closePath();
    ctx.shadowColor = 'rgba(0,0,0,0.1)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetY = 4;
    ctx.fill();
    ctx.restore();
}
if (prevIsNight !== isNight()) {
    randomizeBackground();
    prevIsNight = isNight();
}

function isNight() {
    const hour = Math.floor(dayTime * 24) % 24;
    return hour >= 19 || hour < 6;
}
// Hình nền
function drawBackground() {
    // ===== BẦU TRỜI =====
    const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    skyGradient.addColorStop(0, '#0f172a');
    skyGradient.addColorStop(0.6, '#1e3a8a');
    skyGradient.addColorStop(1, '#60a5fa');
    ctx.fillStyle = skyGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

// ===== SAO NHỎ =====
backgroundStars.forEach(([x, y], index) => {
    const flicker = (Math.sin(performance.now() / 1000 + index) + 1) / 2; // 0 ~ 1 chậm, nhấp nháy nhẹ
    const alpha = isNight() ? 0.5 + flicker * 0.5 : 0.1; // Đêm sáng 0.5-1, ngày mờ nhẹ
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.fillRect(x - camera.x, y - camera.y, 1, 1);
});

// ===== SAO LỚN =====
backgroundBigStars.forEach(([x, y], index) => {
    const flicker = (Math.sin(performance.now() / 1500 + index) + 1) / 2; // chậm hơn sao nhỏ
    const alpha = isNight() ? 0.7 + flicker * 0.3 : 0.1;
    ctx.fillStyle = `rgba(255, 214, 64, ${alpha})`; // Màu vàng nhạt giống sao thật

    ctx.fillRect(x - 2 - camera.x, y - camera.y, 4, 1);
    ctx.fillRect(x - camera.x, y - 2 - camera.y, 1, 4);
});

    // ===== CHIM =====
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.beginPath();
    backgroundBirds.forEach(([x, y]) => {
        ctx.moveTo(x - camera.x, y - camera.y);
        ctx.lineTo(x + 4 - camera.x, y - 3 - camera.y);
        ctx.lineTo(x + 8 - camera.x, y - camera.y);
    });
    ctx.stroke();

    // ===== CÂY XA =====
    ctx.fillStyle = '#14532d';
    backgroundTrees.forEach(([x, y]) => {
        ctx.fillRect(x - camera.x, y - camera.y, 4, 40);
        ctx.beginPath();
        ctx.arc(x + 2 - camera.x, y - 10 - camera.y, 10, 0, Math.PI * 2);
        ctx.fill();
    });

    // ===== CÂY LỚN =====
    ctx.fillStyle = '#14532d';
    ctx.fillRect(120 - camera.x, worldHeight - 180 - camera.y, 10, 100);
    ctx.beginPath();
    ctx.arc(125 - camera.x, worldHeight - 180 - camera.y, 30, 0, Math.PI * 2);
    ctx.fill();
    for (let i = 0; i < 3; i++) {
        let x = 160 + i * 20;
        ctx.fillRect(x - camera.x, worldHeight - 130 - camera.y, 5, 50);
        ctx.beginPath();
        ctx.arc(x + 2.5 - camera.x, worldHeight - 130 - camera.y, 10, 0, Math.PI * 2);
        ctx.fill();
    }

    // ===== MÂY CUTE =====
backgroundClouds.forEach((cloud) => {
    cloud.x += cloud.speed;
    if (cloud.x - camera.x > canvas.width + 150) {
        cloud.x = camera.x - 200;
    }
    drawCuteCloud(ctx, cloud.x - camera.x, cloud.y - camera.y, cloud.size, cloud.isDark);
});
    // ===== MÁY BAY =====
backgroundPlanes.forEach(plane => {
    plane.x += plane.vx;
    plane.y += plane.vy;

    if (plane.x > worldWidth + 300 || plane.y < camera.y - 300) {
        if (Math.random() < 0.5) {
            // Reset kiểu dọc rìa trái
            plane.x = -200 - Math.random() * 200;
            plane.y = worldHeight / 2 + Math.random() * (worldHeight / 2);
        } else {
            // Reset kiểu dưới map trải ngang
            plane.x = Math.random() * worldWidth;
            plane.y = worldHeight - 100 - Math.random() * 100;
        }
        plane.vx = 0.5 + Math.random() * 0.3;
        plane.vy = -0.3 - Math.random() * 0.2;
    }

    const posX = plane.x - camera.x;
    const posY = plane.y - camera.y;

    ctx.save();
    ctx.globalAlpha = plane.opacity;
    ctx.font = `${18 * plane.size}px Arial`;
    ctx.fillText(plane.icon, posX, posY);
    ctx.restore();
});
    // ===== CỎ =====
    ctx.fillStyle = '#16a34a';
    ctx.beginPath();
    ctx.moveTo(0 - camera.x, worldHeight - 80 - camera.y);
    for (let i = 0; i <= worldWidth; i += 30) {
        ctx.lineTo(i + 15 - camera.x, worldHeight - 100 + (i % 60 ? -10 : 10) - camera.y);
    }
    ctx.lineTo(worldWidth - camera.x, worldHeight - 80 - camera.y);
    ctx.lineTo(worldWidth - camera.x, worldHeight - camera.y);
    ctx.lineTo(0 - camera.x, worldHeight - camera.y);
    ctx.closePath();
    ctx.fill();

    // ===== ĐẤT =====
    ctx.fillStyle = '#fbd38d';
    ctx.fillRect(0 - camera.x, worldHeight - 80 - camera.y, worldWidth, 40);
    ctx.fillStyle = '#d97706';
    ctx.fillRect(0 - camera.x, worldHeight - 40 - camera.y, worldWidth, 4);

    // ===== NẤM =====
    backgroundMushrooms.forEach(([x, y]) => {
        ctx.fillStyle = '#b91c1c';
        ctx.beginPath();
        ctx.arc(x - camera.x, y - camera.y, 4, 0, Math.PI);
        ctx.fill();
        ctx.fillStyle = '#92400e';
        ctx.fillRect(x - 1 - camera.x, y - camera.y, 2, 5);
    });

    // ===== ĐÁ =====
    ctx.fillStyle = '#444';
    backgroundRocks.forEach(([x, y]) => {
        ctx.beginPath();
        ctx.ellipse(x - camera.x, y - camera.y, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
    });

    // ===== BÓNG BAY =====
backgroundBalloons.forEach(balloon => {
    balloon.x += balloon.vx;
    balloon.y -= balloon.speed;

    // Khi bay quá cao so với camera thì reset về dưới thấp
    if (balloon.y < camera.y + 100) {
        balloon.x = Math.random() * worldWidth;
        balloon.y = worldHeight - 300 - Math.random() * 100;
        balloon.vx = -0.05 + Math.random() * 0.1;
        balloon.speed = 0.15 + Math.random() * 0.1;
    }

    // Vẽ dây nhỏ
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath();
    ctx.moveTo(balloon.x - camera.x, balloon.y + 20 - camera.y);
    ctx.lineTo(balloon.x - camera.x, balloon.y + 30 - camera.y);
    ctx.stroke();

    // Vẽ bóng bay
    ctx.fillStyle = balloon.color;
    ctx.beginPath();
    ctx.ellipse(balloon.x - camera.x, balloon.y - camera.y, 10, 15, 0, 0, Math.PI * 2);
    ctx.fill();

    // Hiệu ứng sáng nhẹ
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath();
    ctx.ellipse(balloon.x - 4 - camera.x, balloon.y - 6 - camera.y, 2, 4, 0, 0, Math.PI * 2);
    ctx.fill();
});
    // ===== HOA BỒ CÔNG ANH =====
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.lineWidth = 0.5;
    backgroundSeeds.forEach((seed) => {
        seed.x += seed.vx;
        seed.y -= seed.speed;

        if (seed.y < camera.y + 100) {
            seed.x = Math.random() * worldWidth;
            seed.y = worldHeight - 300 - Math.random() * 100;
            seed.vx = -0.1 + Math.random() * 0.2;
            seed.speed = 0.02 + Math.random() * 0.05;
        }

        let posX = seed.x - camera.x;
        let posY = seed.y - camera.y;

        ctx.beginPath();
        ctx.moveTo(posX, posY);
        ctx.lineTo(posX, posY + 6);
        ctx.stroke();

        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            let angle = (Math.PI * 2 / 8) * i;
            let endX = posX + Math.cos(angle) * 4;
            let endY = posY + Math.sin(angle) * 2;
            ctx.moveTo(posX, posY);
            ctx.lineTo(endX, endY);
        }
        ctx.stroke();
    });
}
/**
 * Vẽ hiệu ứng Hào quang Hỗ trợ dưới chân người chơi
 */
function drawSupportAura(ctx) {
    if (!supportAuraActive) return;

    const centerX = player.x;
    const centerY = player.y + player.size - 5;
    const rotationInner = Date.now() / 4000; // Tốc độ xoay của hoa văn bên trong
    const rotationOuter = -Date.now() / 5000; // Tốc độ xoay ngược chiều của vòng ngoài

    // --- Bắt đầu vẽ vòng tròn bên trong (GIỮ NGUYÊN) ---
    const radiusXInner = 50;
    const radiusYInner = 25;
    
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, radiusXInner, radiusYInner, 0, 0, Math.PI * 2);
    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radiusXInner);
    gradient.addColorStop(0, 'rgba(100, 80, 20, 0.5)');
    gradient.addColorStop(1, 'rgba(50, 40, 0, 0.4)');
    ctx.fillStyle = gradient;
    ctx.fill();
    ctx.clip(); 
    
    ctx.strokeStyle = `rgba(255, 215, 0, 0.7)`;
    ctx.lineWidth = 1.5;
    ctx.shadowColor = "gold";
    ctx.shadowBlur = 10;
    
    auraCrackLines.forEach(line => {
        const r_x1 = line.x1 * Math.cos(rotationInner) - line.y1 * Math.sin(rotationInner);
        const r_y1 = line.x1 * Math.sin(rotationInner) + line.y1 * Math.cos(rotationInner);
        const r_x2 = line.x2 * Math.cos(rotationInner) - line.y2 * Math.sin(rotationInner);
        const r_y2 = line.x2 * Math.sin(rotationInner) + line.y2 * Math.cos(rotationInner);
        ctx.beginPath();
        ctx.moveTo(centerX + r_x1, centerY + r_y1 * 0.5);
        ctx.lineTo(centerX + r_x2, centerY + r_y2 * 0.5);
        ctx.stroke();
    });
    ctx.restore();
    // --- Kết thúc vẽ vòng tròn bên trong ---


    // --- (MỚI) Vẽ vòng tròn bên ngoài có hoa văn và xoay ngược chiều ---
    const radiusXOuter = 52; // Bán kính vòng ngoài lớn hơn
    const radiusYOuter = 26;

    ctx.save();
    // 1. Vẽ viền phát sáng
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, radiusXOuter, radiusYOuter, 0, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255, 230, 150, 0.3)`;
    ctx.lineWidth = 2;
    ctx.shadowColor = "gold";
    ctx.shadowBlur = 10;
    ctx.stroke();

    // 2. Vẽ hoa văn là các chấm nhỏ xoay ngược chiều
    const numDots = 40;
    for (let i = 0; i < numDots; i++) {
        const angle = (Math.PI * 2 / numDots) * i + rotationOuter;
        const dotRadius = 0.5;
        const dotX = centerX + Math.cos(angle) * radiusXOuter;
        const dotY = centerY + Math.sin(angle) * radiusYOuter;

        ctx.beginPath();
        ctx.arc(dotX, dotY, dotRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 230, 150, 0.8)';
        ctx.fill();
    }
    ctx.restore();
}
function drawAuraLightBeams(ctx) {
    if (!supportAuraActive) return;

    ctx.save();
    auraLightBeams.forEach(beam => {
        const groundY = player.y + player.size - 5;
        const height = 100; // Chiều cao của cột sáng

        // Tạo gradient mờ dần về phía trên
        const gradient = ctx.createLinearGradient(beam.x, groundY, beam.x, groundY - height);
        gradient.addColorStop(0, `rgba(255, 215, 0, ${beam.alpha * 0.5})`);
        gradient.addColorStop(1, `rgba(255, 215, 0, 0)`);
        
        ctx.fillStyle = gradient;
        ctx.fillRect(beam.x - beam.width / 2, groundY - height, beam.width, height);
    });
    ctx.restore();
}
// Hàm con để vẽ 2 đóm sáng cho một hiệu ứng buff cụ thể
function drawSingleBuffEffect(effect) {
    const centerX = player.x;
    const centerY = player.y;
    const baseRadius = player.size + 15;

    // --- Tính toán vị trí và vẽ vệt sáng (Trail) ---
    const trailLength = 5;
    for (let i = 1; i <= trailLength; i++) {
        const trailAngle = effect.angle - (0.05 * i);
        const radiusX = baseRadius + Math.sin(trailAngle / 2) * 8;
        const radiusY = baseRadius * 0.6;
        const x1 = centerX + Math.cos(trailAngle) * radiusX;
        const y1 = centerY + Math.sin(trailAngle * 2) * radiusY;
        const x2 = centerX - Math.cos(trailAngle) * radiusX;
        const y2 = centerY - Math.sin(trailAngle * 2) * radiusY;

        const alpha = 1.0 - (i / trailLength);
        ctx.globalAlpha = alpha * 0.5;
        ctx.fillStyle = effect.color;

        ctx.beginPath();
        ctx.arc(x1, y1, 3 - i * 0.5, 0, Math.PI * 2); // Kích thước đóm sáng
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x2, y2, 3 - i * 0.5, 0, Math.PI * 2);
        ctx.fill();
    }

    // --- Vẽ Đóm sáng chính ---
    ctx.globalAlpha = 1.0;
    const currentRadiusX = baseRadius + Math.sin(effect.angle / 2) * 8;
    const currentRadiusY = baseRadius * 0.6;
    const currentX1 = centerX + Math.cos(effect.angle) * currentRadiusX;
    const currentY1 = centerY + Math.sin(effect.angle * 2) * currentRadiusY;
    const currentX2 = centerX - Math.cos(effect.angle) * currentRadiusX;
    const currentY2 = centerY - Math.sin(effect.angle * 2) * currentRadiusY;

    ctx.fillStyle = effect.color;
    ctx.beginPath();
    ctx.arc(currentX1, currentY1, 3, 0, Math.PI * 2); // Kích thước đóm sáng
    ctx.fill();
    ctx.beginPath();
    ctx.arc(currentX2, currentY2, 3, 0, Math.PI * 2);
    ctx.fill();
}
//🎨 9. Vẽ khung hình (draw canvas)
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBackground();
  drawBackgroundByTime(ctx);
  ctx.save();
  ctx.translate(-camera.x, -camera.y); // dịch toàn bộ hệ tọa độ theo camera

// 🧱 Vẽ tường dày có sọc chéo
ctx.fillStyle = "#123"; // nền tối
ctx.fillRect(0, 0, worldWidth, wallThickness); // Trên
ctx.fillRect(0, worldHeight - wallThickness, worldWidth, wallThickness); // Dưới
ctx.fillRect(0, 0, wallThickness, worldHeight); // Trái
ctx.fillRect(worldWidth - wallThickness, 0, wallThickness, worldHeight); // Phải

// 🎨 Vẽ sọc chéo lên từng cạnh
drawDiagonalStripes(ctx, 0, 0, worldWidth, wallThickness); // Trên
drawDiagonalStripes(ctx, 0, worldHeight - wallThickness, worldWidth, wallThickness); // Dưới
drawDiagonalStripes(ctx, 0, 0, wallThickness, worldHeight); // Trái
drawDiagonalStripes(ctx, worldWidth - wallThickness, 0, wallThickness, worldHeight); // Phải
// (MỚI) Vẽ Hào quang Hỗ trợ dưới chân
drawSupportAura(ctx);
drawAuraLightBeams(ctx);
  // 1. VẼ CÁC ĐÓM SÁNG Ở PHÍA SAU PLAYER
  for (const buff in buffEffects) {
      const effect = buffEffects[buff];
      // Kiểm tra xem đóm sáng có đang ở nửa trên quỹ đạo không
      if (effect.active && Math.sin(effect.angle * 2) < 0) {
          ctx.save();
          ctx.shadowColor = effect.color;
          ctx.shadowBlur = 15;
          drawSingleBuffEffect(effect);
          ctx.restore();
      }
  }
  // 2. VẼ PLAYER
if (!player.isDying && player.size > 0.1) {
// 🎯 Vẽ tên người chơi trên đầu
ctx.font = "1rem sans-serif";
ctx.fillStyle = "#00ccff"; // 💙 Màu xanh dương
ctx.shadowColor = "#00ccff";
ctx.shadowBlur = 8;
ctx.textAlign = "center";
ctx.textBaseline = "bottom";
ctx.fillText(player.name, player.x, player.y - player.size - 4); // Vẽ tên trên đầu player
// --- BẮT ĐẦU: Vẽ chữ hiệu ứng trên đầu player ---
    let buffTextYOffset = player.y - player.size - 20;
    ctx.font = "bold 0.8rem sans-serif";
    ctx.textAlign = "center";
    
    const now = Date.now();
    const isExpActive = now < expBuffEndTime;
    const isCrazyActive = now < crazyBuffEndTime;
    const isPowerActive = now < powerBuffEndTime;
    const isLuckyActive = now < luckyBuffEndTime;

    // Vẽ ExpUp (MỚI)
    if (isExpActive) {
        ctx.fillStyle = "#ffeb3b"; // Màu vàng
        ctx.shadowColor = "white";
        ctx.shadowBlur = 5;
        ctx.fillText("🌿 ExpUp", player.x, buffTextYOffset);
        buffTextYOffset -= 18; // Dịch chữ tiếp theo lên trên
    }
    
    // Vẽ Crazy
    if (isCrazyActive) {
        ctx.fillStyle = "#f59e0b";
        ctx.shadowColor = "white";
        ctx.shadowBlur = 5;
        ctx.fillText("🍂 CrazyUp", player.x, buffTextYOffset);
        buffTextYOffset -= 18;
    }
    
    // Vẽ Power
    if (isPowerActive) {
        ctx.fillStyle = "#ef4444";
        ctx.shadowColor = "white";
        ctx.shadowBlur = 5;
        ctx.fillText("🍁 PowerUp", player.x, buffTextYOffset);
        buffTextYOffset -= 18;
    }

    // Vẽ Lucky
    if (isLuckyActive) {
        ctx.fillStyle = "#22c55e";
        ctx.shadowColor = "white";
        ctx.shadowBlur = 5;
        ctx.fillText("🍀 LuckyUp", player.x, buffTextYOffset);
    }

    ctx.shadowBlur = 0; // Reset hiệu ứng
    // --- KẾT THÚC: Vẽ chữ hiệu ứng trên đầu player ---
ctx.shadowBlur = 0; // reset sau khi vẽ
ctx.shadowColor = "transparent";
// Vẽ hình tròn player
if (disguiseActive) {
    // --- (MỚI) LOGIC CẢNH BÁO NHẤP NHÁY ---
    const remainingTime = disguiseEndTime - Date.now();
    let shouldDraw = true;

    // Nếu thời gian còn lại dưới 2 giây
    if (remainingTime < 3000 && remainingTime > 0) {
        // Nhấp nháy mỗi 150 mili giây
        if (Math.floor(Date.now() / 150) % 2 === 0) {
            shouldDraw = false;
        }
    }
    
    // Chỉ vẽ nếu không trong giai đoạn "tắt" của hiệu ứng
    if (shouldDraw) {
        // 🐸 Vẽ ếch thay cho player (logic vẽ giữ nguyên)
        ctx.save();
        ctx.font = "2rem serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "lime";
        ctx.shadowBlur = 8;
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = "white";
        ctx.fillText("🐸", player.x, player.y);
        ctx.restore();
    }
} else {
  // 🧍 Vẽ player bình thường
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);

  if (levelUpGlowTime > 0) {
    ctx.shadowBlur = 4;
    ctx.shadowColor = "gold";
    ctx.fillStyle = "gold";
  } else {
    ctx.shadowBlur = 0;
    ctx.shadowColor = "transparent";
    ctx.fillStyle = (player.hitTimer % 10 < 5) ? "#ff4c4c" : "#00ff00";
  }
}
  ctx.fill();
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = "rgba(0, 255, 255, 0.4)";
  ctx.shadowColor = "rgba(0, 255, 255, 0.25)";
  ctx.stroke();
    // 3. VẼ CÁC ĐÓM SÁNG Ở PHÍA TRƯỚC PLAYER
  for (const buff in buffEffects) {
      const effect = buffEffects[buff];
      // Kiểm tra xem đóm sáng có đang ở nửa dưới quỹ đạo không
      if (effect.active && Math.sin(effect.angle * 2) >= 0) {
          ctx.save();
          ctx.shadowColor = effect.color;
          ctx.shadowBlur = 15;
          drawSingleBuffEffect(effect);
          ctx.restore();
      }
  }
      // ✨✨ DỜI TOÀN BỘ KHỐI VẼ MẮT VÀ MIỆNG VÀO ĐÂY ✨✨
    if (zombies.length > 0) {
        const target = zombies.reduce((a, b) => distance(a, player) < distance(b, player) ? a : b);
        const angle = Math.atan2(target.y - player.y, target.x - player.x);
        const eyeOffsetX = Math.cos(angle) * (player.size * 0.3); // Điều chỉnh theo size
        const eyeOffsetY = Math.sin(angle) * (player.size * 0.3);
        const mouthOffsetX = Math.cos(angle) * (player.size * 0.5);
        const mouthOffsetY = Math.sin(angle) * (player.size * 0.5);

        // Mắt trái
        ctx.beginPath();
        ctx.arc(player.x + eyeOffsetX - (player.size * 0.2), player.y + eyeOffsetY - (player.size * 0.2), 2, 0, Math.PI * 2);
        ctx.fillStyle = "white";
        ctx.fill();

        // Mắt phải
        ctx.beginPath();
        ctx.arc(player.x + eyeOffsetX + (player.size * 0.2), player.y + eyeOffsetY - (player.size * 0.2), 2, 0, Math.PI * 2);
        ctx.fill();

        // Miệng
        ctx.beginPath();
        ctx.arc(player.x + mouthOffsetX, player.y + mouthOffsetY + (player.size * 0.15), 2, 0, Math.PI);
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1;
        ctx.stroke();
    }
}
if (playerTeleportState.isTeleporting || playerTeleportState.alpha < 1) {
    ctx.restore();
}

// 🎭 Vẽ các ảo ảnh phân thân
clones.forEach((c,i) => {
  ctx.save();
  ctx.beginPath();
  ctx.arc(c.x, c.y, player.size * 0.75, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
  ctx.shadowBlur = 8;
  ctx.shadowColor = "#aaaaff";
  ctx.fill();
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = "rgba(0,255,255,0.6)";
  ctx.stroke();
  ctx.restore();

  // 👁️ Mắt của clone
  ctx.beginPath();
  ctx.arc(c.x - 3, c.y - 5, 1.5, 0, Math.PI * 2);
  ctx.arc(c.x + 3, c.y - 5, 1.5, 0, Math.PI * 2);
  ctx.fillStyle = "white";
  ctx.fill();
// 👄 Miệng clone
  ctx.beginPath();
  ctx.arc(c.x, c.y + 4, 5, 0, Math.PI); // nửa cung tròn hướng lên (miệng cười)
  ctx.strokeStyle = "rgba(0, 100, 200, 0.6)";
  ctx.lineWidth = 1.2;
  ctx.stroke();
   // 🏷️ Tên clone (Clone 1, 2, ...)
  ctx.font = "bold 12px Segoe UI";
  ctx.fillStyle = "#00ccff"; // Màu xanh dương
  ctx.textAlign = "center";
  ctx.fillText(`Clone ${i + 1}`, c.x, c.y - 22);
});

  bullets.forEach(b => {
  if (!b.active) return; // 🛡 bỏ qua đạn đã bị gỡ
ctx.save();
ctx.translate(b.x, b.y);
    // Nếu là đạn của Fairy, vẽ nó theo kiểu khác
    if (b.isFairyBullet) {
        ctx.fillStyle = 'rgba(100, 255, 150, 0.9)';
        ctx.shadowColor = 'lime';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(0, 0, 5, 0, Math.PI * 2);
        ctx.fill();
    }
    // 2. Nếu là đạn Cà rốt của Pet
    else if (b.isPetBullet) {
        ctx.font = "1.2rem serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(b.icon, 0, 0); // Vẽ icon cà rốt 🥕
    }
    // 3. Các loại đạn còn lại (của người chơi, clone...)
    else {
        if (b.piercing) {
            b.rotation = (b.rotation || 0) + 0.3;
            ctx.rotate(b.rotation);
            ctx.fillStyle = b.color || "cyan";
            ctx.beginPath();
            ctx.moveTo(-6, -3);
            ctx.lineTo(6, 0);
            ctx.lineTo(-6, 3);
            ctx.closePath();
            ctx.shadowBlur = 4;
            ctx.shadowColor = b.color || "cyan";
            ctx.fill();
        } else {
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI * 2);
            ctx.fillStyle = b.color || "yellow";
            ctx.fill();
        }
    }
    ctx.restore();
});
// Vẽ tia laze của người chơi
  playerLasers.forEach(laser => {
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(laser.startX, laser.startY);
    // Vẽ một đường dài theo hướng bắn
    const endX = laser.startX + Math.cos(laser.angle) * 2000;
    const endY = laser.startY + Math.sin(laser.angle) * 2000;
    ctx.lineTo(endX, endY);

    // Định dạng cho tia laze
    ctx.strokeStyle = "cyan";
    ctx.lineWidth = 4;
    ctx.shadowColor = "cyan";
    ctx.shadowBlur = 10;
    ctx.globalAlpha = laser.life / 20; // Mờ dần

    ctx.stroke();
    ctx.restore();
  });
// 🔫 Vẽ đạn từ boss & mini boss
enemyBullets.forEach(b => {
  ctx.beginPath();
  ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
  ctx.fillStyle = "red";
  ctx.fill();
});
// Vẽ bigboss
function drawBigBoss(ctx, z) {
    const { x, y, radius, hp } = z; // Lấy các thuộc tính từ 'z' để dùng bên dưới
    ctx.save();
    ctx.translate(x, y);

    // Ánh sáng nền
    ctx.beginPath();
    ctx.arc(0, 0, radius + 20, 0, Math.PI * 2);
    ctx.fillStyle = "#123";
    ctx.shadowColor = "#a445f5";
    ctx.shadowBlur = 20;
    ctx.fill();
    ctx.shadowBlur = 0;
    // Hiệu ứng vòng xoáy bên trong boss
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = "#a445f5";
    ctx.lineWidth = 1;

    const numCircles = 6;
    for (let i = 0; i < numCircles; i++) {
        ctx.beginPath();
        ctx.arc(0, 0, (radius / 6) * (i + 1), 0, Math.PI * 2);
        ctx.stroke();
    }

    ctx.globalAlpha = 1;
    ctx.restore();

    // Tay trái
    ctx.beginPath();
    ctx.moveTo(-radius * 0.55, -radius * 0.1);
    ctx.quadraticCurveTo(-radius, 0, -radius * 0.9, radius * 0.3);
    ctx.quadraticCurveTo(-radius * 0.8, radius * 0.1, -radius * 0.5, 0);
    ctx.closePath();
    ctx.fillStyle = "#4e2d6d";
    ctx.fill();

    // Tay phải
    ctx.beginPath();
    ctx.moveTo(radius * 0.55, -radius * 0.1);
    ctx.quadraticCurveTo(radius, 0, radius * 0.9, radius * 0.3);
    ctx.quadraticCurveTo(radius * 0.8, radius * 0.1, radius * 0.5, 0);
    ctx.closePath();
    ctx.fill();

    // Chân trái (dài hơn)
    ctx.beginPath();
    ctx.moveTo(-20, radius * 0.4);
    ctx.lineTo(-30, radius * 0.8);
    ctx.lineTo(-10, radius * 0.8);
    ctx.lineTo(0, radius * 0.4);
    ctx.closePath();
    ctx.fill();

    // Chân phải (dài hơn)
    ctx.beginPath();
    ctx.moveTo(20, radius * 0.4);
    ctx.lineTo(30, radius * 0.8);
    ctx.lineTo(10, radius * 0.8);
    ctx.lineTo(0, radius * 0.4);
    ctx.closePath();
    ctx.fill();

    // Cơ thể
    ctx.beginPath();
    ctx.moveTo(-radius * 0.6, -radius * 0.1);
    ctx.bezierCurveTo(-radius * 0.75, radius * 0.3, -30, radius * 0.6, 0, radius * 0.5);
    ctx.bezierCurveTo(30, radius * 0.6, radius * 0.75, radius * 0.3, radius * 0.6, -radius * 0.1);
    ctx.closePath();
    ctx.fillStyle = "#4e2d6d";
    ctx.fill();

    // Bụng rách
    ctx.beginPath();
    ctx.moveTo(-15, 20);
    ctx.lineTo(0, 30);
    ctx.lineTo(15, 20);
    ctx.lineTo(0, 40);
    ctx.closePath();
    ctx.fillStyle = "#8b1f1f";
    ctx.fill();

    // Đầu
    ctx.beginPath();
    ctx.ellipse(0, -radius * 0.35, 45, 60, 0, 0, Math.PI * 2);
    ctx.fillStyle = "#6f3c9c";
    ctx.fill();
    ctx.strokeStyle = "#26142e";
    ctx.lineWidth = 3;
    ctx.stroke();

    // Mắt đỏ glow
    function eye(x, y) {
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fillStyle = "#ff3333";
        ctx.shadowColor = "#ff0000";
        ctx.shadowBlur = 12;
        ctx.fill();
        ctx.shadowBlur = 0;
    }
    eye(-18, -radius * 0.4);
    eye(18, -radius * 0.4);

    // Lông mày
    ctx.strokeStyle = "#2e163a";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-28, -radius * 0.47);
    ctx.lineTo(-8, -radius * 0.5);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(28, -radius * 0.47);
    ctx.lineTo(8, -radius * 0.5);
    ctx.stroke();

    // Tóc
    ctx.beginPath();
    ctx.arc(0, -radius * 0.6, 30, Math.PI, 0);
    ctx.fillStyle = "#1e0f2a";
    ctx.fill();

    // Mũi
    ctx.beginPath();
    ctx.moveTo(-5, -radius * 0.2);
    ctx.lineTo(0, -radius * 0.15);
    ctx.lineTo(5, -radius * 0.2);
    ctx.fillStyle = "#3a1f4d";
    ctx.fill();

    // Miệng đen + răng nanh đen
    ctx.beginPath();
    ctx.moveTo(-18, -radius * 0.1);
    ctx.quadraticCurveTo(0, 0, 18, -radius * 0.1);
    ctx.quadraticCurveTo(0, 10, -18, -radius * 0.1);
    ctx.closePath();
    ctx.fillStyle = "#120000";
    ctx.fill();

    // Răng nanh đen nhỏ
    ctx.fillStyle = "#120000";
    function fang(x, y, h, flip = 1) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 3 * flip, y + h);
        ctx.lineTo(x - 3 * flip, y + h);
        ctx.closePath();
        ctx.fill();
    }
    fang(-8, -radius * 0.1 + 5, 6);
    fang(8, -radius * 0.1 + 5, 6);

    // Vết nứt đầu
    ctx.beginPath();
    ctx.moveTo(-10, -radius * 0.6);
    ctx.lineTo(-5, -radius * 0.5);
    ctx.lineTo(-15, -radius * 0.4);
    ctx.lineTo(-5, -radius * 0.3);
    ctx.strokeStyle = "#4b2b60";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Sẹo mặt
    ctx.beginPath();
    ctx.moveTo(22, -8);
    ctx.lineTo(18, 3);
    ctx.lineTo(28, 6);
    ctx.strokeStyle = "#8a477e";
    ctx.stroke();

    // Sẹo ngực
    ctx.beginPath();
    ctx.moveTo(-18, 28);
    ctx.lineTo(-8, 38);
    ctx.lineTo(-22, 48);
    ctx.stroke();

    // Giáp vai
    ctx.fillStyle = "#2b2b2b";
    ctx.beginPath();
    ctx.moveTo(-55, -5);
    ctx.quadraticCurveTo(-90, 10, -70, 35);
    ctx.quadraticCurveTo(-40, 20, -35, 25);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(55, -5);
    ctx.quadraticCurveTo(90, 10, 70, 35);
    ctx.quadraticCurveTo(40, 20, 35, 25);
    ctx.closePath();
    ctx.fill();

    // Sừng vỡ
    function horn(x, y, flip = 1) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.bezierCurveTo(x + 15 * flip, y - 35, x + 25 * flip, y - 55, x + 10 * flip, y);
        ctx.lineTo(x + 4 * flip, y);
        ctx.closePath();
        ctx.fillStyle = "#444";
        ctx.fill();
        ctx.strokeStyle = "#222";
        ctx.stroke();
    }
    horn(-30, -radius * 0.6, -1);
    horn(30, -radius * 0.6, 1);

    // BOSS + HP
    ctx.font = `${radius * 0.3}px sans-serif`;
    ctx.fillStyle = "violet";
    ctx.textAlign = "center";
    ctx.strokeStyle = "#bb99ff";
    ctx.lineWidth = 2;
    ctx.strokeText(`BOSS ${hp}`, 0, -radius - 30); // Thêm viền chữ
    ctx.fillText(`BOSS ${hp}`, 0, -radius - 30); // Tên boss
    // ✨ THÊM HIỆU ỨNG CẢNH BÁO KHI BOSS ĐANG NGẮM BẮN
    if (z.isChargingLazer) {
        // Vẽ một tia laser mỏng, mờ, màu đỏ từ boss đến người chơi
        const chargeProgress = z.lazerTimer / 2; // 2 là CHARGE_TIME
        const alpha = 0.3 + chargeProgress * 0.4; // Độ mờ tăng dần
        
        ctx.save();
        ctx.beginPath();
        // Điểm bắt đầu là giữa 2 mắt của boss
        ctx.moveTo(0, -z.radius * 0.4); 
        // Điểm kết thúc là vị trí của người chơi (tính tương đối)
        const relativePlayerX = player.x - z.x;
        const relativePlayerY = player.y - z.y;
        ctx.lineTo(relativePlayerX, relativePlayerY);
        
        ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
        ctx.lineWidth = 1;
        ctx.shadowColor = 'red';
        ctx.shadowBlur = 10;
        ctx.stroke();
        ctx.restore();
        }
        ctx.restore();
}
function drawBigBossLazer(ctx, z) {
    if (!z.isBigBoss || !z.isLazerAttacking || z.lazerAngle === undefined) return;

    ctx.save();
    ctx.translate(z.x, z.y);

    // Vẽ vòng tròn phát sáng ở tâm bắn
    ctx.save();
    ctx.beginPath();
    ctx.arc(0, 0, 28, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(200,100,255,0.18)";
    ctx.shadowColor = "violet";
    ctx.shadowBlur = 22;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();

    // Vẽ vòng tròn nhỏ hơn, đậm hơn ở tâm
    ctx.save();
    ctx.beginPath();
    ctx.arc(0, 0, 12, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(200,100,255,0.45)";
    ctx.shadowColor = "violet";
    ctx.shadowBlur = 12;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();

    // Vẽ tia lazer
    ctx.rotate(z.lazerAngle);
    ctx.strokeStyle = "rgba(200, 100, 255, 0.7)";
    ctx.lineWidth = 8;
    ctx.shadowColor = "violet";
    ctx.shadowBlur = 24;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    const lazerRange = 600; // Đảm bảo biến này có tồn tại
    ctx.lineTo(lazerRange, 0);
    ctx.stroke();
    ctx.restore();

    // ✨ THAY ĐỔI: Sử dụng 'z' thay vì 'bigBoss'
    const endX = z.x + Math.cos(z.lazerAngle) * lazerRange;
    const endY = z.y + Math.sin(z.lazerAngle) * lazerRange;
    const glowRadius = 30;

    const glow = ctx.createRadialGradient(endX, endY, 0, endX, endY, glowRadius);
    glow.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
    glow.addColorStop(0.4, 'rgba(128, 0, 128, 0.5)');
    glow.addColorStop(1, 'rgba(128, 0, 128, 0)');

    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(endX, endY, glowRadius, 0, Math.PI * 2);
    ctx.fill();
}

// Vẽ toàn bộ zombie hoạt động kèm icon, HP, trạng thái, biểu cảm (tối ưu fillText)
// Vòng lặp zombie
zombies.forEach(z => { 
    // ✨ BẮT ĐẦU ĐOẠN MÃ TĂNG HP MỚI ✨
    // Kiểm tra xem zombie có sống sót qua ngày mới không
    if (currentDay > z.lastDayBuffed) {
        const hpIncreaseMultiplier = 1.1; // Tăng 10% HP mỗi ngày
        // Tăng cả HP hiện tại và HP gốc để buff có hiệu lực vĩnh viễn
        z.hp = Math.round(z.hp * hpIncreaseMultiplier);
        z.baseHp = Math.round(z.baseHp * hpIncreaseMultiplier);
        z.lastDayBuffed = currentDay; // Cập nhật ngày đã được buff
        z.isBuffed = true; // Tạo hiệu ứng nhấp nháy trong 60 frame (khoảng 1 giây)
    }
    // ✨ KẾT THÚC ĐOẠN MÃ TĂNG HP MỚI ✨
  if (!z.active) return;
  // 🆕 Vẽ BigBoss giống Boss nhưng riêng block để dễ quản lý
  if (z.isBigBoss) {
    drawBigBoss(ctx, z);
    drawBigBossLazer(ctx, z);
    return;
  }
ctx.save();

// ✨ Glow cho Boss hoặc MiniBoss
if (z.isBoss || z.type === "miniBoss") {
  ctx.shadowColor = z.color || "#ffffff";
  ctx.shadowBlur = z.isBoss ? 4 : 2;
} else {
  ctx.shadowColor = "transparent";
  ctx.shadowBlur = 0;
}

// 🔵 Nếu zombie bị stun bởi lôi
if (z.stunned && Date.now() < z.stunnedUntil) {
  ctx.shadowColor = "#00e5ff";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "#b3f0ff";
}
// 🔥 Nếu zombie bị trúng lửa
else if (z.onFireUntil && Date.now() < z.onFireUntil) {
  ctx.shadowColor = "orange";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "#ffb347";
}
// ❄️ Nếu zombie bị trúng băng
else if (z.onIceUntil && Date.now() < z.onIceUntil) {
  ctx.shadowColor = "#00e5ff";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "#b3e0ff";
}
else {
  ctx.fillStyle = z.color || "#ff69b4";
}

// 🎯 Vẽ hình tròn zombie
ctx.beginPath();
ctx.arc(z.x, z.y, z.radius, 0, Math.PI * 2);
ctx.fill();
ctx.restore();

// --- BẮT ĐẦU ĐOẠN MÃ CẦN THÊM ---

// Vẽ chi tiết dựa trên style của zombie
switch (z.style) {
    case "Walker": // Zombie đi bộ thông thường
        ctx.fillStyle = "#333";
        ctx.fillRect(z.x - 5, z.y - 10, 10, 4); // Vết nứt trên đầu
        break;

    case "Brute": // Zombie to khỏe, trâu bò
        ctx.fillStyle = "#4a4a4a"; // Giáp vai
        ctx.fillRect(z.x - 15, z.y - 8, 30, 8);
        ctx.fillStyle = "darkred"; // Mắt đỏ
        ctx.beginPath();
        ctx.arc(z.x, z.y, 4, 0, Math.PI * 2);
        ctx.fill();
        break;

    case "Spitter": // Zombie phun độc
        ctx.fillStyle = "yellow"; // Túi độc
        ctx.beginPath();
        ctx.arc(z.x, z.y + 4, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "orange";
        ctx.stroke();
        break;

    case "Mutant": // Zombie đột biến
        ctx.fillStyle = "purple"; // Các khối u
        ctx.beginPath();
        ctx.arc(z.x - 8, z.y - 8, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(z.x + 10, z.y, 8, 0, Math.PI * 2);
        ctx.fill();
        break;
    case "Cyber":
      ctx.fillStyle = "#00ffff";
      ctx.fillRect(z.x - 10, z.y - 3, 20, 6);
      break;
    case "Hunter":
      ctx.fillStyle = "#654321";
      ctx.fillRect(z.x - 4, z.y - 8, 8, 16);
      ctx.fillStyle = "#432";
      ctx.fillRect(z.x - 6, z.y + 6, 12, 4);
      break;
    case "Shadow":
      ctx.fillStyle = "#333";
      ctx.fillRect(z.x - 10, z.y - 4, 20, 8);
      ctx.fillStyle = "red";
      ctx.fillRect(z.x - 5, z.y - 2, 10, 4);
      break;
    case "Arcanist":
      ctx.fillStyle = "purple";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 12, Math.PI, 2 * Math.PI);
      ctx.fill();
      ctx.fillStyle = "#ff0";
      ctx.fillRect(z.x - 3, z.y - 5, 6, 10);
      break;
    case "Soldier":
      ctx.fillStyle = "green";
      ctx.fillRect(z.x - 10, z.y - 8, 20, 5);
      ctx.fillStyle = "#444";
      ctx.fillRect(z.x - 3, z.y, 6, 12);
      break;
    case "Robot":
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 3, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#888";
      ctx.fillRect(z.x - 8, z.y + 4, 16, 4);
      break;
    case "Knight":
      ctx.fillStyle = "#999";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 4, 10, 0, Math.PI);
      ctx.fill();
      ctx.fillStyle = "#555";
      ctx.fillRect(z.x - 6, z.y, 12, 4);
      break;
    case "Rogue":
      ctx.strokeStyle = "orange";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(z.x, z.y, 6, 0, Math.PI * 2);
      ctx.stroke();
      break;
    case "Wraith":
      ctx.fillStyle = "#333";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "aqua";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 4, 2.5, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Astronaut":
      ctx.strokeStyle = "#ccc";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(z.x, z.y, 14, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = "#999";
      ctx.fillRect(z.x - 4, z.y + 2, 8, 4);
      break;
    case "Beast":
      ctx.fillStyle = "brown";
      ctx.fillRect(z.x - 5, z.y + 5, 10, 6);
      ctx.fillStyle = "#333";
      ctx.fillRect(z.x - 3, z.y - 6, 6, 3);
      break;
    case "Spectre":
      ctx.fillStyle = "lime";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#0f0";
      ctx.stroke();
      break;
    case "Ninja":
      ctx.fillStyle = "#111";
      ctx.fillRect(z.x - 8, z.y - 8, 16, 16);
      ctx.fillStyle = "red";
      ctx.fillRect(z.x - 4, z.y - 2, 8, 4);
      break;
    case "Samurai":
      ctx.fillStyle = "#444";
      ctx.fillRect(z.x - 10, z.y - 6, 20, 12);
      ctx.strokeStyle = "#c00";
      ctx.strokeRect(z.x - 10, z.y - 6, 20, 12);
      break;
    case "Alien":
      ctx.fillStyle = "lime";
      ctx.beginPath();
      ctx.ellipse(z.x, z.y, 10, 14, 0, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Skeleton":
      ctx.fillStyle = "#ddd";
      ctx.fillRect(z.x - 6, z.y - 10, 12, 20);
      ctx.strokeStyle = "#000";
      ctx.strokeRect(z.x - 6, z.y - 10, 12, 20);
      break;
    case "Mage":
      ctx.fillStyle = "violet";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 4, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "yellow";
      ctx.fillRect(z.x - 2, z.y + 2, 4, 10);
      break;
    case "Ghost":
      ctx.fillStyle = "#aaa";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 14, 0, Math.PI);
      ctx.fill();
      ctx.fillRect(z.x - 14, z.y, 28, 10);
      break;
    case "Monk":
      ctx.fillStyle = "#964B00";
      ctx.fillRect(z.x - 6, z.y - 8, 12, 16);
      ctx.fillStyle = "gold";
      ctx.fillRect(z.x - 3, z.y, 6, 10);
      break;
    case "Cyborg":
      ctx.fillStyle = "#999";
      ctx.fillRect(z.x - 10, z.y - 6, 20, 12);
      ctx.fillStyle = "red";
      ctx.fillRect(z.x + 6, z.y - 2, 4, 4);
      break;
    case "Shaman":
      ctx.fillStyle = "green";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "white";
      ctx.fillRect(z.x - 2, z.y - 8, 4, 16);
      break;
    case "Demon":
      ctx.fillStyle = "darkred";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#444";
      ctx.fillRect(z.x - 6, z.y, 12, 8);
      break;
    case "Angel":
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "gold";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 14, 4, 0, Math.PI * 2);
      ctx.stroke();
      break;
    case "Guardian":
      ctx.fillStyle = "#555";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.strokeStyle = "yellow";
      ctx.strokeRect(z.x - 10, z.y - 10, 20, 20);
      break;
    case "Pilot":
      ctx.fillStyle = "#005588";
      ctx.fillRect(z.x - 8, z.y - 8, 16, 16);
      ctx.fillStyle = "#eee";
      ctx.fillRect(z.x - 4, z.y - 4, 8, 4);
      break;
    case "Engineer":
      ctx.fillStyle = "#b8860b";
      ctx.fillRect(z.x - 10, z.y - 6, 20, 12);
      ctx.fillStyle = "#222";
      ctx.fillRect(z.x - 2, z.y - 2, 4, 4);
      break;
    case "Android":
      ctx.fillStyle = "#666";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "blue";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 5, 3, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Starfighter":
      ctx.fillStyle = "#800080";
      ctx.beginPath();
      ctx.moveTo(z.x - 10, z.y + 10);
      ctx.lineTo(z.x, z.y - 10);
      ctx.lineTo(z.x + 10, z.y + 10);
      ctx.closePath();
      ctx.fill();
      break;
    case "Commander":
      ctx.fillStyle = "#333366";
      ctx.fillRect(z.x - 12, z.y - 8, 24, 16);
      ctx.fillStyle = "gold";
      ctx.fillRect(z.x - 8, z.y - 4, 16, 8);
      break;
    case "Medic":
      ctx.fillStyle = "#fff";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "red";
      ctx.fillRect(z.x - 8, z.y - 2, 16, 4);
      ctx.fillRect(z.x - 2, z.y - 8, 4, 16);
      break;
    case "Barbarian":
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(z.x - 8, z.y - 10, 16, 20);
      ctx.fillStyle = "#555";
      ctx.fillRect(z.x - 10, z.y - 12, 20, 4);
      break;
    case "Paladin":
      ctx.fillStyle = "#ffd700";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "#4682B4";
      ctx.fillRect(z.x - 6, z.y - 6, 12, 12);
      break;
    case "Druid":
      ctx.fillStyle = "#228B22";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "brown";
      ctx.fillRect(z.x - 4, z.y - 12, 8, 4);
      break;
    case "Necromancer":
      ctx.fillStyle = "#000";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "darkgreen";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 4, 6, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Archer":
      ctx.fillStyle = "#556B2F";
      ctx.fillRect(z.x - 8, z.y - 8, 16, 16);
      ctx.strokeStyle = "brown";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(z.x + 5, z.y - 10);
      ctx.lineTo(z.x + 15, z.y);
      ctx.stroke();
      break;
    case "Sorcerer":
      ctx.fillStyle = "#8A2BE2";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#ffff00";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 5, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Bard":
      ctx.fillStyle = "#DC143C";
      ctx.fillRect(z.x - 8, z.y - 8, 16, 16);
      ctx.fillStyle = "#DAA520";
      ctx.beginPath();
      ctx.arc(z.x, z.y + 8, 6, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Cleric":
      ctx.fillStyle = "#F8F8FF";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "#B22222";
      ctx.fillRect(z.x - 2, z.y - 10, 4, 20);
      break;
    case "Vampire":
      ctx.fillStyle = "#8B0000";
      ctx.beginPath();
      ctx.ellipse(z.x, z.y, 12, 18, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.fillRect(z.x - 2, z.y + 8, 4, 4);
      break;
    case "Werewolf":
      ctx.fillStyle = "#696969";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 16, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "brown";
      ctx.beginPath();
      ctx.moveTo(z.x - 8, z.y - 10);
      ctx.lineTo(z.x - 4, z.y - 16);
      ctx.lineTo(z.x, z.y - 10);
      ctx.fill();
      break;
    case "Goblin":
      ctx.fillStyle = "#3CB371";
      ctx.beginPath();
      ctx.ellipse(z.x, z.y, 10, 15, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#8B4513";
      ctx.beginPath();
      ctx.moveTo(z.x + 6, z.y - 8);
      ctx.lineTo(z.x + 10, z.y - 12);
      ctx.lineTo(z.x + 12, z.y - 8);
      ctx.fill();
      break;
    case "Elf":
      ctx.fillStyle = "#008000";
      ctx.beginPath();
      ctx.ellipse(z.x, z.y, 10, 16, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "lightgoldenrodyellow";
      ctx.beginPath();
      ctx.moveTo(z.x + 8, z.y - 10);
      ctx.lineTo(z.x + 14, z.y - 6);
      ctx.lineTo(z.x + 8, z.y - 2);
      ctx.fill();
      break;
    case "Dwarf":
      ctx.fillStyle = "#A52A2A";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(z.x - 8, z.y + 6, 16, 8);
      break;
    case "Orc":
      ctx.fillStyle = "#4B0082";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 16, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#00FF7F";
      ctx.beginPath();
      ctx.moveTo(z.x + 5, z.y + 5);
      ctx.lineTo(z.x + 10, z.y + 10);
      ctx.lineTo(z.x + 5, z.y + 15);
      ctx.fill();
      break;
    case "Detective":
      ctx.fillStyle = "#4682B4";
      ctx.fillRect(z.x - 8, z.y - 10, 16, 20);
      ctx.fillStyle = "#333";
      ctx.fillRect(z.x - 10, z.y - 12, 20, 4);
      break;
    case "Swat":
      ctx.fillStyle = "#2F4F4F";
      ctx.fillRect(z.x - 12, z.y - 12, 24, 24);
      ctx.fillStyle = "#808080";
      ctx.fillRect(z.x - 4, z.y - 10, 8, 4);
      break;
    case "Firefighter":
      ctx.fillStyle = "#FF4500";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "#8B0000";
      ctx.fillRect(z.x - 4, z.y - 12, 8, 4);
      break;
    case "Doctor":
      ctx.fillStyle = "#ADD8E6";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "red";
      ctx.fillRect(z.x - 8, z.y - 2, 16, 4);
      ctx.fillRect(z.x - 2, z.y - 8, 4, 16);
      break;
}
// --- KẾT THÚC ĐOẠN MÃ CẦN THÊM ---

// ⚡ Hiệu ứng điện động khi bị stun bởi lôi
if (z.stunnedByThunder && Date.now() < z.stunnedThunderUntil) {
  // Hiệu ứng tia điện động
  ctx.save();
  ctx.strokeStyle = "#00ffff"; // Xanh điện sáng hơn
  ctx.lineWidth = 1;
  ctx.shadowColor = "#00ffff";
  ctx.shadowBlur = 8;
  for (let i = 0; i < 2; i++) {
    const angle = Math.random() * Math.PI * 2;
    const r1 = z.radius + 2;
    const r2 = z.radius + 4 + Math.random() * 4;
    ctx.beginPath();
    ctx.moveTo(z.x + Math.cos(angle) * r1, z.y + Math.sin(angle) * r1);
    ctx.lineTo(z.x + Math.cos(angle) * r2, z.y + Math.sin(angle) * r2);
    ctx.stroke();
  }
  ctx.restore();

  // Hiện chữ "CHOÁNG" nổi bật trên đầu
  ctx.save();
  ctx.font = "0.8rem Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillStyle = "#00ffff";
  ctx.shadowColor = "#00ffff";
  ctx.shadowBlur = 12;
  ctx.globalAlpha = 0.92;
  ctx.fillText("Choáng", z.x, z.y - z.radius - 18);
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
  ctx.restore();
}
    // Hiện chữ "Cháy" khi zombie bị đốt
    if (z.burnEndTime && Date.now() < z.burnEndTime) {
      ctx.save();
      ctx.font = "0.8rem Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.fillStyle = "orange"; // Màu cam cho hiệu ứng cháy
      ctx.shadowColor = "red";
      ctx.shadowBlur = 10;
      // Vẽ chữ "Cháy" ở cùng vị trí với chữ "Choáng"
      ctx.fillText("Cháy", z.x, z.y - z.radius - 18);
      ctx.restore();
    }

    // Hiện chữ "Chậm" khi zombie bị làm chậm
    if (z.slowEndTime && Date.now() < z.slowEndTime) {
      ctx.save();
      ctx.font = "0.8rem Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.fillStyle = "#87ceeb"; // Màu xanh da trời cho hiệu ứng chậm
      ctx.shadowColor = "blue";
      ctx.shadowBlur = 10;
      // Vẽ chữ "Chậm" ở cùng vị trí với chữ "Choáng"
      ctx.fillText("Chậm", z.x, z.y - z.radius - 18);
      ctx.restore();
    }

// 🔥 Hiệu ứng lửa động khi bị trúng lửa
if (z.onFireUntil && Date.now() < z.onFireUntil) {
  ctx.save();
  // Lớp sáng cam phủ ngoài (chỉ 1 lần shadowBlur)
  ctx.globalAlpha = 0.5;
  ctx.beginPath();
  ctx.arc(z.x, z.y, z.radius + 2, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(255,120,0,0.25)";
  ctx.shadowColor = "orange";
  ctx.shadowBlur = 12;
  ctx.fill();
  ctx.shadowBlur = 0;

  // Vẽ 2 ngọn lửa động (fill, không blur)
  for (let i = 0; i < 2; i++) {
    const angle = (Math.PI * 2 / 2) * i + frame / 15;
    const len = 10 + Math.sin(frame / 7 + i + frame / 10) * 3;
    ctx.save();
    ctx.translate(z.x + Math.cos(angle) * (z.radius - 2), z.y + Math.sin(angle) * (z.radius - 2));
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.quadraticCurveTo(2, -len / 2, 0, -len);
    ctx.quadraticCurveTo(-2, -len / 2, 0, 0);
    ctx.fillStyle = "rgba(255,140,0,0.85)";
    ctx.globalAlpha = 0.8;
    ctx.fill();
    ctx.restore();
  }
  ctx.restore();
}

// ❄️ Hiệu ứng băng động khi bị trúng băng
if (z.onIceUntil && Date.now() < z.onIceUntil) {
  ctx.save();
  // Lớp băng phủ ngoài (chỉ 1 lần shadowBlur)
  ctx.globalAlpha = 0.7;
  ctx.beginPath();
  ctx.arc(z.x, z.y, z.radius + 2, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(180,220,255,0.45)";
  ctx.shadowColor = "#b3e0ff";
  ctx.shadowBlur = 10;
  ctx.fill();
  ctx.shadowBlur = 0;

  // Vẽ 2 tinh thể băng nhỏ (fill, không blur)
  for (let i = 0; i < 2; i++) {
    const angle = (Math.PI * 2 / 2) * i + frame / 30;
    const len = 7 + Math.sin(frame / 8 + i) * 1.5;
    ctx.save();
    ctx.translate(z.x + Math.cos(angle) * (z.radius + 4), z.y + Math.sin(angle) * (z.radius + 4));
    ctx.rotate(angle + frame / 40);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(2, -len / 2);
    ctx.lineTo(0, -len);
    ctx.lineTo(-2, -len / 2);
    ctx.closePath();
    ctx.fillStyle = "#e0f7fa";
    ctx.globalAlpha = 0.7;
    ctx.fill();
    ctx.restore();
  }
  ctx.restore();
}
// ✨✨ Mã hiển thị tên được thêm vào đây ✨✨
// Chọn màu chữ: nếu là Tinh Anh thì màu đỏ, không thì màu trắng
ctx.fillStyle = z.isElite ? "#ff4c4c" : "#fff"; 
ctx.font = "12px sans-serif";
ctx.textAlign = "center";
ctx.shadowBlur = 0;
ctx.fillText(z.style || 'Normal', z.x, z.y + z.radius + 18);

// === 🆕 fillText gộp toàn bộ thông tin ===
ctx.save();

// 🧠 Font chung
ctx.fillStyle = "#fff";
ctx.textAlign = "center";
ctx.textBaseline = "middle";

// 🅰️ Vẽ cấp + HP trên đầu zombie
let levelChar = "";
if (z.isBoss) levelChar = "SS";
else if (z.type === "miniBoss") levelChar = "S";
else levelChar = String.fromCharCode(96 + (z.level || 1));

// ✨ Giảm kích thước font nếu là boss hoặc mini boss
let levelFontSize = z.radius * 0.9; // mặc định cho zombie thường
if (z.type === "miniBoss") levelFontSize = z.radius * 0.6;
if (z.isBoss) levelFontSize = z.radius * 0.5;

ctx.font = `${levelFontSize}px sans-serif`;
ctx.textAlign = "center";
ctx.textBaseline = "middle"; // Vị trí icon zombie
ctx.fillStyle = z.color || "#fff";
// 1. Tạo chuỗi HP cơ bản
let hpText = `${levelChar}-${z.hp}`;
// 2. Nếu zombie vừa được buff, thêm dấu "+" vào chuỗi
if (z.isBuffed) {
    hpText += "*";
}
// 3. Vẽ chuỗi text cuối cùng lên màn hình
ctx.fillText(hpText, z.x, z.y - z.radius - 8);

// 🧟 Vẽ icon zombie ở giữa thân
ctx.font = `${z.radius * 1.5}px sans-serif`;
const iconChar = z.isBoss ? "💀" : "";
ctx.fillText(iconChar, z.x, z.y);

// 😴 Trạng thái (chỉ zombie thường & có icon)
// 🎯 Hiển thị icon hành vi: 😡 khi chasing, 😫/💤Zzz khi wandering (30%)
let behaviorIcon = null;
// Boss sẽ không có icon trạng thái
if (!z.isBoss && z.state === "chasing" && z.showStatusIcon) {
  behaviorIcon = "😡";
} else if (!z.isBoss && z.type !== "miniBoss" && z.state === "wandering") {
  const isSleeping = z.wanderBehavior === "pause";

  // 💤 Đang lang thang & đứng im
  if (isSleeping && isNight()) {
    behaviorIcon = "💤"; // 💯 luôn hiển thị khi ban đêm
  } else if (z.showStatusIcon) {
    behaviorIcon = isSleeping ? "💤" : "😫"; // Ngày thường theo 30%
  }
}
    // Vẽ icon Suy yếu nếu có
    if (z.isWeakened && Date.now() < z.weakenEndTime) {
        ctx.font = `${z.radius}px sans-serif`;
        ctx.textAlign = "right"; // Vẽ bên phải
        ctx.textBaseline = "top";
        ctx.fillStyle = "#ff4c4c"; // Màu đỏ
        ctx.fillText("💥⬇️", z.x - z.radius * -1, z.y - z.radius * 3);
    }

if (behaviorIcon) {
  ctx.font = `${z.radius}px sans-serif`;
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillStyle = "#fff";
  ctx.fillText(behaviorIcon, z.x + z.radius * 0.6, z.y - z.radius * 1.2);
}
ctx.restore();

  // 💬 Biểu cảm (chỉ zombie thường mới có)
  if (!z.isBoss && z.iconToDraw) {
    ctx.save();
    ctx.font = `${z.radius * 1.2}px serif`;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#fff";
    ctx.shadowColor = "#000";
    ctx.shadowBlur = 4;
ctx.font = `${z.radius}px sans-serif`;
ctx.textAlign = "left";
ctx.textBaseline = "top";
ctx.fillStyle = "#fff";
ctx.fillText(z.iconToDraw, z.x + z.radius * 0.6, z.y - z.radius * 1.2);
    ctx.restore();
}
});

// Vẽ lớp khiên nếu đang hoạt động
function drawHex3D(ctx, x, y, size) {
  const gradient = ctx.createRadialGradient(x, y, size * 0.3, x, y, size);
  gradient.addColorStop(0, "rgba(0,255,255,0.25)");
  gradient.addColorStop(1, "rgba(0,200,255,0.05)");

  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const angle = Math.PI / 3 * i;
    const px = x + size * Math.cos(angle);
    const py = y + size * Math.sin(angle);
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fillStyle = gradient;
  ctx.strokeStyle = "rgba(0,255,255,0.1)";
  ctx.lineWidth = 0.8;
  ctx.fill();
  ctx.stroke();
}

if (player.shieldActive) {
// Vòng tròn ngoài cùng
  const pulse = Math.sin(Date.now() / 200) * 2;
  ctx.save();
  ctx.globalAlpha = 0.6;
  ctx.beginPath();
  ctx.arc(player.x, player.y, 48 + pulse, 0, Math.PI * 2);
  ctx.strokeStyle = "rgba(0,200,255,0.7)";
  ctx.lineWidth = 4;
  ctx.shadowColor = "#00eaff";
  ctx.shadowBlur = 10;
  ctx.stroke();
  ctx.restore();

// Vẽ mạng lưới lục giác đều trong khiên
const hexSize = 10;
const spacingX = hexSize * Math.sqrt(3);
const spacingY = hexSize * 1.5;
const radius = 45;
const angleOffset = Date.now() / 3000; // Góc xoay theo thời gian

for (let row = -5; row <= 5; row++) {
  for (let col = -5; col <= 5; col++) {
    const offsetX = (row % 2 === 0) ? 0 : spacingX / 2;
    const x0 = col * spacingX + offsetX;
    const y0 = row * spacingY;

    const dx = x0;
    const dy = y0;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < radius) {
// 👉 Xoay điểm quanh tâm player
      const angle = angleOffset;
      const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
      const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
      const px = player.x + rotatedX;
      const py = player.y + rotatedY;
      drawHex3D(ctx, px, py, hexSize);
}
}
}
}

// Vẽ vệ tinh laze 🛰️
satellites.forEach(sat => {
  ctx.save();
  ctx.translate(sat.x, sat.y);
  ctx.shadowBlur = 10;
  ctx.shadowColor = "cyan";
  ctx.fillStyle = "white";
  ctx.font = "1.2rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("🛰️", 0, 0);
  ctx.restore();
});

explosions.forEach(e => {
  ctx.beginPath();
  ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
  ctx.fillStyle = `rgba(255, 200, 0, ${e.life / 20})`;
  ctx.fill();
});
// Vẽ tia laze cho từng vệ tinh
satellites.forEach(sat => {
  if (sat.laserBeam && sat.laserBeam.life > 0) {
    const x1 = sat.x, y1 = sat.y;
    const angle = sat.laserBeam.angle;
    const x2 = x1 + Math.cos(angle) * 500;
    const y2 = y1 + Math.sin(angle) * 500;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = "rgba(0, 255, 255, 0.8)";
    ctx.lineWidth = 3;
    ctx.shadowColor = "cyan";
    ctx.shadowBlur = 12;
    ctx.stroke();
    ctx.restore();
  }
});
// Vẽ UFO
if (ufoActive) {
ufos.forEach(ufo => {
    // THÊM VÀO: Logic kiểm tra và đổi hướng bay
    if (Date.now() > ufo.nextDirectionChangeTime) {
        // Hết giờ, tạo tốc độ ngẫu nhiên mới
        ufo.speedX = (Math.random() - 0.5) * 2;
        ufo.speedY = (Math.random() - 0.5) * 0.5;

        // Đặt lại mốc thời gian cho lần đổi hướng tiếp theo
        ufo.nextDirectionChangeTime = Date.now() + ufo.directionChangeInterval;
    }

    // --- Di chuyển UFO ---
    ufo.relativeX += ufo.speedX;
    ufo.relativeY += ufo.speedY;

        // --- Giữ UFO trong khung hình (hiệu ứng "dội tường") ---
        // Dội cạnh trái/phải
        if (ufo.relativeX < 0 || ufo.relativeX > canvas.width) {
            ufo.speedX *= -1;
        }
        // Dội cạnh trên/dưới (trong một khoảng giới hạn)
        if (ufo.relativeY < 120 || ufo.relativeY > 360) {
            ufo.speedY *= -1;
        }

        // --- Logic tấn công ---
        if (Date.now() > ufo.laserCooldown) {
            // Tọa độ thực của UFO trên bản đồ
            const ufoWorldX = camera.x + ufo.relativeX;
            const ufoWorldY = camera.y + ufo.relativeY;
            
            // Tìm zombie gần nhất để bắn
            const target = zombies.find(z => z.active && distance({x: ufoWorldX, y: ufoWorldY}, z) < 400);

            if (target) {
              playSound('sfx-laser', 0.5);
                const angle = Math.atan2(target.y - ufoWorldY, target.x - ufoWorldX);
                ufo.angle = angle; // Lưu góc bắn để vẽ tia laser
                ufo.laserLife = 30; // Tia laser tồn tại trong 0.5 giây

                // Gây sát thương cho tất cả zombie trên đường bắn
                zombies.forEach(z => {
                    if (!z.active) return;
                    const dx = Math.cos(angle), dy = Math.sin(angle);
                    const proj = (z.x - ufoWorldX) * dx + (z.y - ufoWorldY) * dy;
                    const perp = Math.abs((z.x - ufoWorldX) * dy - (z.y - ufoWorldY) * dx);
                    if (proj > 0 && proj < 1200 && perp < 20) {
                        dealDamageToZombie(z, ufo.damage);
                    }
                });
            }
            // Đặt lại thời gian hồi chiêu
            ufo.laserCooldown = Date.now() + 1500; // Bắn mỗi 1.5 giây
        }
        
        if (ufo.laserLife > 0) ufo.laserLife--;
    });
}
ufos.forEach(ufo => {
    // Tính toán tọa độ vẽ thực tế dựa trên camera và vị trí tương đối
    const drawX = camera.x + ufo.relativeX;
    const drawY = camera.y + ufo.relativeY;

    // UFO icon
    ctx.save();
    ctx.translate(drawX, drawY); // <-- Dùng tọa độ mới
    ctx.shadowBlur = 10;
    ctx.shadowColor = "red";
    ctx.fillStyle = "white";
    ctx.font = "1.4rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("🛸", 0, 0);
    ctx.restore();

    // Tia laser đỏ
    if (ufo.laserLife > 0) {
        const x1 = drawX; // <-- Dùng tọa độ mới
        const y1 = drawY; // <-- Dùng tọa độ mới
        const laserLength = 1200;
        const x2 = x1 + Math.cos(ufo.angle) * laserLength;
        const y2 = y1 + Math.sin(ufo.angle) * laserLength;

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = "rgba(255, 0, 0, 0.8)";
        ctx.lineWidth = 3;
        ctx.shadowColor = "red";
        ctx.shadowBlur = 15;
        ctx.stroke();
        ctx.restore();
    }
});
// Vẽ các vòng nổ phụ của bom hạt nhân
extraShockwaves.forEach(sw => {
  ctx.save();
  ctx.beginPath();
  ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2);
  ctx.strokeStyle = sw.color;
  ctx.globalAlpha = sw.alpha;
  ctx.lineWidth = 3;
  ctx.shadowColor = sw.color;
  ctx.shadowBlur = 12;
  ctx.stroke();
  ctx.restore();
});

drawItems();
drawSupplyDrops();
drawEffects();
/**
 * Vẽ các kiện hàng tiếp tế (🪂) ra màn hình.
 */
function drawSupplyDrops() {
    ctx.font = "2rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.shadowColor = "black";
    ctx.shadowBlur = 5;

    supplyDrops.forEach(drop => {
        ctx.fillText("🪂", drop.x, drop.y);
    });

    ctx.shadowBlur = 0; // Reset
}
// 🎨 Vẽ vật phẩm hiện có trên màn hình
function drawItems() {
  items.forEach(it => {
    if (!it.active) return;
    ctx.save();

    // Cài đặt font chữ và căn chỉnh cho vật phẩm
    ctx.font = "0.9rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    let icon, color;

    // Chọn icon và màu sắc phù hợp với từng vật phẩm
    switch (it.type) {
      case 'potion':
        icon = "💊";
        color = "red";
        break;
      case 'lucky':
        icon = "🍀";
        color = "#22c55e";
        break;
      case 'power':
        icon = "🍁";
        color = "#ef4444";
        break;
      case 'crazy': 
        icon = "🍂";
        color = "#f59e0b";
        break;
      case 'exp': 
        icon = "🌿";
        color = "#ffeb3b";
        break;
      // --- BẮT ĐẦU PHẦN BỔ SUNG ---
      case 'magnet':
        icon = "🧲";
        color = "#8b5cf6"; // Màu tím
        break;
      case 'secret':
        icon = "❓";
        color = "#ffeb3b"; // Màu vàng
        break;
      case 'expBonus':
        icon = "🌟";
        color = "#ffeb3b"; // Màu vàng
        break;
      // --- KẾT THÚC PHẦN BỔ SUNG ---
      case 'coin':
        icon = "🪙";
        color = "gold";
        break;
      case 'energy':
        icon = "⚡";
        color = "gold";
        break;
      case 'mana':
        icon = "💠";
        color = "cyan";
        break;
      case 'hp':
        icon = "❤️";
        color = "red";
        break;
      case 'box':
        icon = "📦";
        color = "#fff";
        break;
    }

    // Tạo hiệu ứng nhẹ (bóng đổ và chuyển động nhẹ nhàng)
    if (icon) {
        ctx.shadowBlur = 3;
        ctx.shadowColor = color;
        ctx.fillStyle = color;
        const bob = Math.sin(frame / 10 + it.x + it.y) * 2;
        ctx.fillText(icon, it.x, it.y + bob);
    }
    ctx.restore();
  });
}
// 🌩️ Vẽ tia sét
function drawLightningBolts() {
    // ✨ THAY ĐỔI: Chỉ chạy nếu một trong hai kỹ năng (Bão sét hoặc Lôi) đang hoạt động
    if (!lightningActive && !thunderActive) return;
    
    ctx.save();
    
    // Vẽ các đám mây của Bão sét (nếu có)
    if (lightningActive) {
        lightningBolts.forEach(bolt => {
            ctx.font = "2rem serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "yellow";
            ctx.shadowColor = "gold";
            ctx.shadowBlur = 8;
            ctx.fillText("🌩️", bolt.x, bolt.y);
        });
    }

    // Vẽ các tia sét đang hoạt động (cho cả hai kỹ năng)
    activeLightningStrikes.forEach(strike => {
        if (strike.type === 'chain') {
            const path = strike.path;
            const alpha = strike.life / 30;
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineWidth = 1.5;
            ctx.shadowColor = "white";
            ctx.shadowBlur = 10;
            ctx.stroke();
        } else {
            // --- Vẽ SÉT CHÍNH (vàng, dày, từ trên trời) ---
            const path = strike.path;
            if (path.length < 2) return;
            const endPoint = path[path.length - 1];
            const alpha = strike.life / 60;

            if (strike.life > 35) { 
                ctx.beginPath();
                ctx.arc(endPoint.x, endPoint.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 200, ${alpha * 0.8})`;
                ctx.shadowColor = "yellow"; ctx.shadowBlur = 20;
                ctx.fill(); ctx.shadowBlur = 0;
            }
            
            ctx.shadowColor = "yellow"; ctx.shadowBlur = 20;
            for (let i = 1; i < path.length; i++) {
                const p = i / (path.length - 1);
                const lw = 4 * (1 - p);
                ctx.beginPath();
                ctx.moveTo(path[i-1].x, path[i-1].y);
                ctx.lineTo(path[i].x, path[i].y);
                ctx.strokeStyle = `rgba(255, 255, 0, ${alpha * 0.6})`;
                ctx.lineWidth = lw;
                ctx.stroke();
            }
            
            ctx.shadowBlur = 0;
            for (let i = 1; i < path.length; i++) {
                const p = i / (path.length - 1);
                const lw = 1.5 * (1 - p);
                ctx.beginPath();
                ctx.moveTo(path[i-1].x, path[i-1].y);
                ctx.lineTo(path[i].x, path[i].y);
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.lineWidth = lw;
                ctx.stroke();
            }
        }
    });

    ctx.restore();
}

function drawBlackHole() {
  // 📦 Lọc ra các máy bay sắp bị hút
  const blackHolePlanes = activePlanes.filter(p => p.x > worldWidth - 200);

  if (blackHolePlanes.length === 0) return; // ❌ Không có máy bay nào gần hố đen thì không vẽ

  // 📍 Xác định vị trí hố đen dựa trên máy bay gần nhất
  const blackHoleX = worldWidth - 100;

  // 🎯 Tính trung bình độ cao các máy bay đang tới gần
  const blackHoleY = blackHolePlanes.reduce((sum, p) => sum + p.y, 0) / blackHolePlanes.length;

  // 🔵 Hiệu ứng phồng nhẹ
  const pulse = Math.sin(Date.now() / 300);
  const radius = 40 + pulse * 5;

  // 🎨 Vẽ hố đen
  ctx.save();
  ctx.beginPath();
  ctx.arc(blackHoleX, blackHoleY, radius, 0, Math.PI * 2);
  ctx.fillStyle = "black";
  ctx.shadowColor = "purple";
  ctx.shadowBlur = 20;
  ctx.fill();
  ctx.restore();
}
if (petRabbit && petActive) {
  const { x, y, radius } = petRabbit;

  /* — thân — */
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fillStyle   = "#fff0fa";   // thân trắng-hồng
  ctx.fill();
  ctx.strokeStyle = "#ff7ad9";   // viền hồng nhạt
  ctx.lineWidth   = 2;
  ctx.stroke();

  /* — tai — */
  ctx.beginPath();
  ctx.ellipse(x - 6, y - 18, 3, 6, 0, 0, Math.PI * 2);
  ctx.ellipse(x + 6, y - 18, 3, 6, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  /* — mắt — */
  ctx.beginPath();
  ctx.arc(x - 4, y - 3, 1.5, 0, Math.PI * 2);
  ctx.arc(x + 4, y - 3, 1.5, 0, Math.PI * 2);
  ctx.fillStyle = "#000";
  ctx.fill();

  /* — miệng — */
  ctx.beginPath();
  ctx.arc(x, y + 4, 2, 0, Math.PI);
  ctx.strokeStyle = "#000";
  ctx.stroke();

  /* — tên “Thỏ” — */
  ctx.font         = "0.8rem sans-serif";
  ctx.fillStyle    = "#ff7ad9";   // cùng màu viền
  ctx.shadowColor  = "#ff7ad9";
  ctx.shadowBlur   = 8;
  ctx.textAlign    = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText("Thỏ", x, y - radius - 10);
  ctx.shadowBlur   = 0;
  ctx.shadowColor  = "transparent";
}

// ================== VẼ CỔNG KHÔNG GIAN ==================
if (spaceGateActive && spaceGate && spaceGate.radius > 0.1) { // Sử dụng radius > 0.1
    ctx.save();
    // Áp dụng hiệu ứng mờ dần khi cổng mới xuất hiện
    ctx.globalAlpha = spaceGate.alpha;

    const x = spaceGate.x;
    const y = spaceGate.y;
    const radius = spaceGate.radius;

    // Lớp hào quang bên ngoài
// Lớp hào quang bên ngoài
const pulse = Math.sin(frame * 0.1) * 5;
ctx.beginPath();
// ✨ SỬA LỖI: Dùng Math.max để đảm bảo bán kính không bao giờ âm
ctx.arc(x, y, Math.max(0, radius + pulse), 0, Math.PI * 2); 
ctx.fillStyle = `rgba(255, 100, 0, 0.2)`;
ctx.fill();

    // Vòng xoáy lửa trung tâm
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
    gradient.addColorStop(0, 'rgba(255, 255, 180, 0.9)');
    gradient.addColorStop(0.5, 'rgba(255, 180, 0, 0.8)');
    gradient.addColorStop(1, 'rgba(200, 50, 0, 0.5)');
    
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();

    // Viền ngoài phát sáng
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.strokeStyle = "gold";
    ctx.lineWidth = 3;
    ctx.shadowColor = "orange";
    ctx.shadowBlur = 15;
    ctx.stroke();

    // Các tia lửa xoáy bên trong
    ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
    ctx.lineWidth = 1.5;
    ctx.shadowColor = "yellow";
    ctx.shadowBlur = 15;
    for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        const startAngle = spaceGate.rotation + (i * Math.PI / 2);
        const endAngle = startAngle + Math.PI * 0.8;
        ctx.arc(x, y, radius * (0.3 + (i * 0.15)), startAngle, endAngle);
        ctx.stroke();
    }
    
    ctx.restore();
}

// Đoạn này xử lý việc làm mờ người chơi khi dịch chuyển, giữ nguyên
if (playerTeleportState.isTeleporting || playerTeleportState.alpha < 1) {
    ctx.save();
    ctx.globalAlpha = playerTeleportState.alpha;
}

drawParticles(ctx);

drawBloodOrb(ctx);
drawBlackHole();
drawLightningBolts(); // 🌩️ Vẽ tia sét
updateAndDrawHealEffects();
ctx.restore(); // kết thúc dịch chuyển camera
drawMiniMap();
// 🎨 Vẽ bản đồ thu nhỏ
}

// 🎨 Vẽ tất cả hiệu ứng kỹ năng gọn lại
function drawEffects() {
  // === THÊM VÀO: VẼ ĐÁM MÂY CỦA MƯA KIẾM ===
    swordRainClouds.forEach(cloud => {
        ctx.save();
        // Vị trí vẽ = vị trí camera + vị trí tương đối của mây
        const drawX = camera.x + cloud.relativeX;
        const drawY = camera.y + cloud.relativeY;
        
        ctx.font = "2rem serif";
        ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
        ctx.shadowColor = "rgba(0, 0, 0, 0.3)";
        ctx.shadowBlur = 2;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("☁️", drawX, drawY);
        ctx.restore();
    });
    // ✨ Thêm vòng lặp này vào để vẽ các Fairy
    fairies.forEach(fairy => {
        ctx.save();
        ctx.font = "1.2rem serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "cyan";
        ctx.shadowBlur = 15;
        ctx.fillStyle = 'white'; 
        ctx.fillText("🦋", fairy.x, fairy.y);
        ctx.restore();
    });
    
  fireballs.forEach(f => {
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.shadowBlur = 8;
    ctx.shadowColor = "orange";
    ctx.fillStyle = "orange";
    ctx.font = "1.3rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("🔥", 0, 0);
    ctx.restore();
  });

  iceballs.forEach(f => {
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.shadowBlur = 8;
    ctx.shadowColor = "#00e5ff";
    ctx.fillStyle = "#00e5ff";
    ctx.font = "1.3rem serif";
// ctx.font = (f.radius * 0.9) + " serif"; Kỹ năng to ra khi lên level
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("❄️", 0, 0);
    ctx.restore();
  });
// Vẽ quả cầu lôi
if (thunderActive) {
  thunderBalls.forEach(f => {
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.shadowBlur = 8;
    ctx.shadowColor = "#00e5ff";
    ctx.fillStyle = "#00e5ff";
    ctx.font = "1rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("🔵", 0, 0);
    // Hiệu ứng điện xung quanh
    for (let i = 0; i < 6; i++) {
      const angle = (Math.PI * 2 / 6) * i + frame / 10;
      ctx.beginPath();
      ctx.arc(Math.cos(angle) * 12, Math.sin(angle) * 12, 2, 0, Math.PI * 2);
      ctx.fillStyle = "#b3f0ff";
      ctx.fill();
    }
    ctx.restore();
  });
}

swords.forEach(s => {
    ctx.save();
    ctx.translate(s.x, s.y);
    if (s.state === 'charging') {
  ctx.shadowBlur = 8; // Hiệu ứng bóng mờ
  ctx.shadowColor = '#00ffff';
  ctx.fillStyle = '#00ffff';
} else {
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'white';
}
    ctx.font = "1.2rem serif";
//ctx.font = (s.radius * 0.9) + " serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("🔪", 0, 0);
    ctx.restore();
  });

downwardSwords.forEach(s => {
  ctx.save();
  ctx.translate(s.x, s.y);
  ctx.shadowBlur = 8;
  ctx.shadowColor = '#00ffff';
  ctx.fillStyle = 'white';
  ctx.font = "1.2rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("⚔️", 0, 0);
  ctx.restore();
});
// Vẽ tên lửa
missiles.forEach(m => {
  ctx.save();
  ctx.translate(m.x, m.y);
  ctx.shadowColor = m.state === "delay" ? "gray" : "orange";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "white";
  ctx.font = "1.3rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("🚀", 0, 0);
  ctx.restore();
});
// BÊN TRONG HÀM drawEffects()

missiles = missiles.filter(m => {
    // --- 1. Giai đoạn chờ (delay) ---
    if (m.state === "delay") {
        m.delay--;
        if (m.delay <= 0) {
            m.state = "fly";
        }
        return true;
    }

    // --- 2. Cập nhật di chuyển & dẫn hướng (giữ nguyên) ---
    if (m.target && m.target.active) {
        const desiredAngle = Math.atan2(m.target.y - m.y, m.target.x - m.x);
        const currentAngle = Math.atan2(m.dy, m.dx);
        const turnRate = 0.05;
        let delta = desiredAngle - currentAngle;
        if (delta > Math.PI) delta -= 2 * Math.PI;
        if (delta < -Math.PI) delta += 2 * Math.PI;
        const newAngle = currentAngle + Math.sign(delta) * Math.min(turnRate, Math.abs(delta));
        const speed = 2.5;
        m.dx = Math.cos(newAngle) * speed;
        m.dy = Math.sin(newAngle) * speed;
    }
    m.x += m.dx;
    m.y += m.dy;

    // --- 3. Gây sát thương xuyên trên đường bay (giữ nguyên) ---
    zombies.forEach(z => {
        if (z.active && !m.hitSet.has(z) && distance(m, z) < 20) {
            if (!z.missileHitCooldown || Date.now() > z.missileHitCooldown) {
                dealDamageToZombie(z, m.damage);
                m.hitSet.add(z);
                z.missileHitCooldown = Date.now() + 100;
            }
        }
    });

    // --- 4. Kiểm tra giới hạn khoảng cách bay và va chạm ---
    const travelDistance = distance({ x: m.startX, y: m.startY }, m);
    const hitTarget = m.target && m.target.active && distance(m, m.target) < 25;

    // --- 5. Xử lý NỔ KÉP khi hết tầm hoặc va chạm mục tiêu chính ---
    if (travelDistance > 360 || hitTarget) {
        
        // ✨ BẮT ĐẦU PHẦN CẢI TIẾN ✨
        // Vụ nổ chính (100% sát thương)
        zombies.forEach(z => {
            if (z.active && distance(m, z) < 120) { // Bán kính nổ 120px
                dealDamageToZombie(z, m.damage);
            }
        });
        createParticleExplosion(m.x, m.y, 50, 'fire'); // Hiệu ứng nổ chính

        // Vụ nổ phụ (50% sát thương) sau 0.2 giây
        setTimeout(() => {
            zombies.forEach(z => {
                if (z.active && distance(m, z) < 120) {
                    dealDamageToZombie(z, m.damage * 0.5); // Gây 50% sát thương
                }
            });
            // Tạo một vụ nổ nhỏ hơn cho hiệu ứng
            const secondaryExplosion = getExplosion(m.x, m.y);
            secondaryExplosion.life = 15; // Nổ nhỏ và tan nhanh
            explosions.push(secondaryExplosion);
        }, 200); // 200ms = 0.2 giây
        // ✨ KẾT THÚC PHẦN CẢI TIẾN ✨

        return false; // Xóa tên lửa sau khi kích hoạt nổ
    }

    return true; // Giữ tên lửa lại nếu chưa nổ
});

// 💣 B52 Bombs + 🛬 Máy bay
ctx.save();
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.font = "1.3rem serif";
ctx.shadowBlur = 8;
ctx.shadowColor = "black";

// 🛬 Vẽ máy bay đang hoạt động
activePlanes.forEach(plane => {
  ctx.fillStyle = "cyan";
ctx.save();
  ctx.shadowBlur = 4;
  ctx.shadowColor = "cyan";
ctx.translate(plane.x, plane.y);
ctx.scale(plane.scale ?? 1, plane.scale ?? 1);
ctx.globalAlpha = plane.opacity ?? 1;
ctx.fillText("🛬", 0, 0);
ctx.restore();
});

// 💣 Vẽ từng quả bom đang rơi hoặc sắp nổ
bombsB52.forEach(bomb => {
  if (bomb.exploded) return;
  ctx.fillStyle = bomb.landed ? "orange" : "white";
  ctx.fillText("💣", bomb.x, bomb.y);
});

ctx.restore();
// ☢️ Vẽ bom hạt nhân
nuclearBombs.forEach(bomb => {
// ----------- Vẽ bom hạt nhân khi chưa nổ -----------
if (!bomb.exploded) {
  let offsetX = 0, offsetY = 0;

  // 🔔 Nếu còn ≤ 3 giây và đã chạm đất → rung lắc
  if (bomb.landed && bomb.timerAfterLand <= 180) {
    offsetX = (Math.random() - 0.5) * 4;
    offsetY = (Math.random() - 0.5) * 4;
  }

  ctx.save();
  // Vẽ icon bom ☢️ to, sáng (có rung)
  ctx.font = "2.2rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.shadowBlur = 12;
  ctx.shadowColor = "orange";
  ctx.fillStyle = "white";
  ctx.fillText("☢️", bomb.x + offsetX, bomb.y + offsetY);

  // -- Nếu đã chạm đất, vẽ icon 💥 và giây countdown nằm ngang --
  if (bomb.landed) {
    const baseY = bomb.y - 35;
    const iconX = bomb.x - 1;
    const secX  = bomb.x + 1;

    // Vẽ icon 💥 nhỏ
    ctx.font = "1rem serif";
    ctx.shadowBlur = 2;
    ctx.textAlign = "right";
    ctx.fillStyle = "#ffb300";
    ctx.fillText("💥", iconX, baseY);

    // Vẽ số giây nhỏ, màu đỏ
    ctx.font = "1rem sans-serif";
    ctx.fillStyle = "#ff3333";
    ctx.textAlign = "left";
    let sec = Math.max(1, Math.ceil(bomb.timerAfterLand / 60));
    ctx.fillText(`${sec}`, secX, baseY - 2);
  }

  ctx.restore();
}

// ----------- Vẽ hiệu ứng sóng xung kích khi bom phát nổ -----------
if (bomb.exploded && bomb.shockwave) {
// Hiệu ứng vòng nổ chính – nét to, vàng đậm rõ ràng
  ctx.save();
  ctx.beginPath();
  ctx.arc(bomb.x, bomb.y, bomb.shockwaveRadius, 0, Math.PI * 2);
  ctx.strokeStyle = "rgba(255, 222, 44, 0.88)";   // Vàng tươi, gần như vàng nguyên chất
  ctx.lineWidth = 16;
  ctx.shadowBlur = 32;
  ctx.shadowColor = "#ffec70";
  ctx.globalAlpha = 0.58; // Đậm và rõ
  ctx.stroke();
  ctx.restore();

  // Viền ngoài phụ - vàng trắng, rõ hơn, tạo cảm giác “hào quang”
  ctx.save();
  ctx.beginPath();
  ctx.arc(bomb.x, bomb.y, bomb.shockwaveRadius + 8, 0, Math.PI * 2);
  ctx.strokeStyle = "rgba(255,255,180,0.73)";
  ctx.lineWidth = 7;
  ctx.shadowBlur = 28;
  ctx.shadowColor = "#fffbe2";
  ctx.globalAlpha = 0.45;
  ctx.stroke();
  ctx.restore();
}
});
blackHoles.forEach(h => {
  ctx.save();
  ctx.beginPath();
  ctx.arc(h.x, h.y, h.radius, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
  ctx.shadowColor = "purple";
  ctx.shadowBlur = 20;
  ctx.fill();
  ctx.closePath();

  // Icon giữa hố đen
  ctx.font = "2rem serif";
  ctx.fillStyle = "#fff";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("🕳️", h.x, h.y);
  ctx.restore();
});
// Vẽ lazer cho clone
activeCloneLasers.forEach(laser => {
    // Tìm clone đã bắn ra tia lazer này bằng ID
    const firingClone = clones.find(c => c.id === laser.cloneId);

    // Chỉ vẽ tia lazer nếu clone đó còn tồn tại
    if (firingClone) {
        ctx.save();
        ctx.beginPath();
        // Điểm bắt đầu của lazer là vị trí HIỆN TẠI của clone
        ctx.moveTo(firingClone.x, firingClone.y);
        ctx.lineTo(laser.endX, laser.endY);
        
        ctx.strokeStyle = `rgba(255, 100, 255, ${laser.life / 120})`;
        ctx.lineWidth = 6;
        ctx.shadowColor = "#ff00ff";
        ctx.shadowBlur = 20;
        
        ctx.stroke();
        ctx.restore();
    }

  });
}

//🔁 10. Vòng lặp chính và khởi tạo game
let fps = 0, lastFrameTime = performance.now(), frameCount = 0, lastFpsUpdate = performance.now(); // biến cập nhật FPS

function loop() {
  updateDayNight(); // <-- chỉ gọi 1 lần ở đây tránh lặp lại
  const now = performance.now();
  frameCount++;

// Cập nhật FPS mỗi 500ms
if (now - lastFpsUpdate >= 500) {
    fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
    const fpsText = `FPS: ${fps}`;
if (fpsText !== lastFpsText) {
  lastFpsText = fpsText;
  document.getElementById("fpsCounter").innerText = fpsText;
}
    frameCount = 0;
    lastFpsUpdate = now;
}

  update();
  draw();
  frame++;
  
if (frame % 60 === 0 && gameStarted) {
// Giới hạn zombie tối đa là 200 - Số lượng zombie hiện tại
if (zombies.length < 200) {
    const spawnCount = Math.min(1, 200 - zombies.length);
    for (let i = 0; i < spawnCount; i++) {
    spawnZombie();
}
}
}
requestAnimationFrame(loop);
}

// ▶️ Khởi chạy ban đầu
spawnZombie();
loop();

//🧼 11. Các đoạn khởi tạo UI sau canvas
// Hàm bắt đầu game
function startGame() {
  playSound('sfx-game-start', 0.3); // Phát âm thanh bắt đầu game
//  spawnBigBoss(); // chỉ để test

  randomizeBackground();
  // Hiển thị tổng điểm
  document.getElementById("highScoreDisplay").innerText = `🏆 Kỷ lục: ${localStorage.getItem('highScore') || 0}`;
  const nameInput = document.getElementById("playerNameInput");
  player.name = nameInput.value.trim() || "Player";
  document.getElementById("startMenu").style.display = "none";
  gameStarted = true;
  waveTimer = waveTime;
  // THÊM DÒNG NÀY ĐỂ BẬT NHẠC NỀN
  playRandomNormalMusic(); // Bắt đầu phát nhạc ngẫu nhiên
  showUpgradePopup();        // 🎁 Gọi nâng cấp trước
  pendingWave = wave;        // 🌊 Wave sẽ hiển thị sau khi nâng cấp xong
}
// Hàm bật/tắt Shop
function toggleShop() {
    const shop = document.getElementById('shopOverlay');
    if (!shop) return;
    const isHidden = shop.classList.toggle('hidden');
    isPaused = !isHidden;

    if (!isHidden) {
        populateShop(); // Khi mở shop, hiển thị các vật phẩm
    }
}

// Hàm hiển thị các vật phẩm trong Shop
function populateShop() {
    const container = document.getElementById('shopItemsContainer');
    container.innerHTML = ''; // Xóa các vật phẩm cũ

    document.getElementById('shopCoinBalance').innerText = player.coins;

    shopItems.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'shop-item';

        // THAY ĐỔI: Bỏ thẻ div.cost và hiển thị giá tiền ngay trên nút Mua
        itemDiv.innerHTML = `
            <div class="icon">${item.icon}</div>
            <div class="name">${item.name}</div>
            <button onclick="purchaseShopItem('${item.id}')">${item.cost} 🪙</button>
        `;
        container.appendChild(itemDiv);
    });
}

// Hàm xử lý khi mua một vật phẩm
function purchaseShopItem(itemId) {
    const item = shopItems.find(i => i.id === itemId);
    if (!item) return;

    if (player.coins >= item.cost) {
        player.coins -= item.cost;
        playSound('sfx-powerup', 0.8); // Âm thanh mua thành công
        showWarning(`Đã mua: ${item.name}!`);
        // Áp dụng hiệu ứng vật phẩm
        switch (item.id) {
            case 'buy_10_mana':
                player.mana += item.value;
                break;
            case 'buy_10_energy':
                player.energy += item.value;
                break;
            case 'buy_5_hp':
                player.hearts += item.value;
                break;
            case 'buy_12_hp':
                player.hearts += item.value;
                break;
            case 'buy_damage':
                playerUpgrades.damageBoost += item.value;
                break;
        }

        // Cập nhật lại giao diện shop và UI chính
        populateShop();
        updateUI();
        updateStatsOverlay();
    } else {
        showWarning("Không đủ xu!"); // Thông báo không đủ tiền
    }
}
// 🌊 Hiện popup "Wave X bắt đầu"
function showWavePopup() {
  const popup = document.getElementById("wavePopup");
  popup.innerText = `Wave ${wave} bắt đầu!`;
  popup.style.animation = "none";
  void popup.offsetWidth; // force reflow để reset animation
  popup.style.display = "block";
  popup.style.animation = "waveFade 1s ease-out forwards";
  setTimeout(() => {
    popup.style.display = "none";
  }, 2000); // ẩn sau 2 giây
}

// 🎯 Giá trị theo cấp độ kỹ năng (mỗi cấp tăng dần)
const UPGRADE_TIERS = {
  fireRate: [1, 2, 3],
  damageBoost: [0.5, 1, 1.5],
  hpBoost: [5, 10, 15],            
  bulletSpeed: [0.25, 0.5, 1]
};

// 🌟 Hiển thị popup chọn nâng cấp kỹ năng
function showUpgradePopup() {
  playSound('sfx-wave-up', 0.3); // Phát âm thanh nâng cấp
  const popup = document.getElementById("upgradePopup");
  const container = document.getElementById("upgradeChoices");
  container.innerHTML = "";

  // 📌 Bảng giá trị tương ứng với từng bậc nâng cấp
  const UPGRADE_VALUES = {
    Bạc: { fireRate: 1, damageBoost: 0.5, hpBoost: 5, bulletSpeed: 0.25 },
    Vàng: { fireRate: 2, damageBoost: 1, hpBoost: 10, bulletSpeed: 0.5 },
    Kim: { fireRate: 3, damageBoost: 1.5, hpBoost: 15, bulletSpeed: 1 },
    Rare: { moveSpeed: 0.2 } // 👟 tốc độ chạy – bậc hiếm
  };
  // 🎖 Màu viền tương ứng từng bậc
  const TIER_COLORS = {
    Bạc: "#aaa",
    Vàng: "gold",
    Kim: "#c770ff",
    Rare: "#3399ff" // 💚 màu xanh bậc hiếm
  };
  // Giới hạn nâng cấp kỹ năng
  const MAX_FIRE_RATE = 21; // 🔫 hướng bắn
  const MAX_LINE_BULLETS = 10; // 🔫 số lượng đạn
  const MAX_MOVE_SPEED = 3; // 👟 tốc độ di chuyển tối đa
  const MAX_BULLET_SPEED = 10; // 🚀 tốc độ đạn tối đa

  const allUpgrades = [];

  // 🔪 Đao – tăng số lượng (tối đa 20), sau đó tăng sát thương
  // THÊM ĐIỀU KIỆN: Chỉ hiển thị nâng cấp khi người chơi đạt level 1
  if (player.level >= 1) {
    if (skillUpgrades.bladeCount < 20) {
      const tier = randomTier();
      const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];
      allUpgrades.push({
        name: `🔪 +${value} đao xoay`,
        tier,
        effect: () => {
          skillUpgrades.bladeCount = Math.min(skillUpgrades.bladeCount + value, 20);
          showWarning(`🔪 +${value} đao`);
          updateStatsOverlay();
        }
      });
    } else {
      const tier = randomTier();
      const value = { Bạc: 0.5, Vàng: 1, Kim: 1.5 }[tier];
      allUpgrades.push({
        name: `🔪 +${value} sát thương đao`,
        tier,
        effect: () => {
          skillUpgrades.bladeDamage += value;
          showWarning(`🔪 +${value} dmg`);
          updateStatsOverlay();
        }
      });
    }
  }

  // ⚔️ Kiếm – tăng cấp (tối đa 10), sau đó tăng sát thương
  // THÊM ĐIỀU KIỆN: Chỉ hiển thị nâng cấp khi người chơi đạt level 2
  if (player.level >= 2) {
    if (skillUpgrades.swordLevel < 10) {
      const tier = randomTier();
      const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];
      allUpgrades.push({
        name: `⚔️ +${value} cấp mưa kiếm`,
        tier,
        effect: () => {
          skillUpgrades.swordLevel = Math.min(skillUpgrades.swordLevel + value, 10);
          showWarning(`⚔️ +${value} cấp kiếm`);
          updateStatsOverlay();
        }
      });
    } else {
      const tier = randomTier();
      const value = { Bạc: 0.5, Vàng: 1, Kim: 1.5 }[tier];
      allUpgrades.push({
        name: `⚔️ +${value} sát thương kiếm`,
        tier,
        effect: () => {
          skillUpgrades.swordDamage += value;
          showWarning(`⚔️ +${value} dmg`);
          updateStatsOverlay();
        }
      });
    }
  }

  // 🔥 Lửa – tăng số lượng (tối đa 10), sau đó tăng sát thương
  // THÊM ĐIỀU KIỆN: Chỉ hiển thị nâng cấp khi người chơi đạt level 3
  if (player.level >= 3) {
    if (skillUpgrades.fireCount < 10) {
      const tier = randomTier();
      const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];
      allUpgrades.push({
        name: `🔥 +${value} cầu lửa`,
        tier,
        effect: () => {
          skillUpgrades.fireCount = Math.min(skillUpgrades.fireCount + value, 10);
          showWarning(`🔥 +${value} lửa`);
          updateStatsOverlay();
        }
      });
    } else {
      const tier = randomTier();
      const value = { Bạc: 0.5, Vàng: 1, Kim: 1.5 }[tier];
      allUpgrades.push({
        name: `🔥 +${value} sát thương lửa`,
        tier,
        effect: () => {
          skillUpgrades.fireDamage += value;
          showWarning(`🔥 +${value} dmg`);
          updateStatsOverlay();
        }
      });
    }
  }

  // ❄️ Băng – tăng số lượng (tối đa 10), sau đó tăng sát thương
  // THÊM ĐIỀU KIỆN: Chỉ hiển thị nâng cấp khi người chơi đạt level 3
  if (player.level >= 3) {
    if (skillUpgrades.iceCount < 10) {
      const tier = randomTier();
      const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];
      allUpgrades.push({
        name: `❄️ +${value} cầu băng`,
        tier,
        effect: () => {
          skillUpgrades.iceCount = Math.min(skillUpgrades.iceCount + value, 10);
          showWarning(`❄️ +${value} băng`);
          updateStatsOverlay();
        }
      });
    } else {
      const tier = randomTier();
      const value = { Bạc: 0.5, Vàng: 1, Kim: 1.5 }[tier];
      allUpgrades.push({
        name: `❄️ +${value} sát thương băng`,
        tier,
        effect: () => {
          skillUpgrades.iceDamage += value;
          showWarning(`❄️ +${value} dmg`);
          updateStatsOverlay();
        }
      });
    }
  }
  
  // 🔵 Lôi – tăng số lượng (tối đa 6), sau đó tăng sát thương
  // THÊM ĐIỀU KIỆN: Chỉ hiển thị nâng cấp khi người chơi đạt level 5
  if (player.level >= 5) {
    if (skillUpgrades.thunderCount < 6) {
      const tier = randomTier();
      const value = 1;
      allUpgrades.push({
        name: `🔵 +${value} cầu lôi`,
        tier,
        effect: () => {
          skillUpgrades.thunderCount = Math.min(skillUpgrades.thunderCount + value, 6);
          showWarning(`🔵 +${value} cầu lôi`);
          updateStatsOverlay();
        }
      });
    } else {
      const tier = randomTier();
      const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];
      allUpgrades.push({
        name: `🔵 +${value} sát thương lôi`,
        tier,
        effect: () => {
          skillUpgrades.thunderDamage += value;
          showWarning(`🔵 +${value} dmg lôi`);
          updateStatsOverlay();
        }
      });
    }
  }

  // 🔫 Hướng bắn – nếu chưa max
  if (playerUpgrades.fireRate < MAX_FIRE_RATE) {
    const tier = randomTier();
    const value = UPGRADE_VALUES[tier].fireRate;
    allUpgrades.push({
      name: "🔫 Hướng bắn",
      key: "fireRate",
      tier,
      value,
      effect: () => {
        const added = Math.min(playerUpgrades.fireRate + value, MAX_FIRE_RATE) - playerUpgrades.fireRate;
        playerUpgrades.fireRate += added;
        showWarning(`🔫 +${added} hướng bắn`);
        updateStatsOverlay();
      }
    });
  }

  // 💥 Sát thương – luôn có thể nâng
  {
    const tier = randomTier();
    const value = UPGRADE_VALUES[tier].damageBoost;
    allUpgrades.push({
      name: "💥 Sát thương",
      key: "damageBoost",
      tier,
      value,
      effect: () => {
        playerUpgrades.damageBoost += value;
        showWarning(`💥 +${value} sát thương`);
        updateStatsOverlay();
      }
    });
  }

  // ❤️ Máu – luôn có thể nâng
  {
    const tier = randomTier();
    const value = UPGRADE_VALUES[tier].hpBoost;
    allUpgrades.push({
      name: "❤️ Tăng máu",
      key: "hpBoost",
      tier,
      value,
      effect: () => {
        player.hearts += value;
        playerUpgrades.hpBoost += 1;
        showWarning(`❤️ +${value}`);
        updateUI();
        updateStatsOverlay();
      }
    });
  }

  // 💨 Tốc độ đạn tối đa 10
  if (playerUpgrades.bulletSpeed < MAX_BULLET_SPEED) {
    const tier = randomTier();
    const value = UPGRADE_VALUES[tier].bulletSpeed;
    allUpgrades.push({
      name: "💨 Tốc độ đạn",
      key: "bulletSpeed",
      tier,
      value,
      effect: () => {
        const added = Math.min(playerUpgrades.bulletSpeed + value, MAX_BULLET_SPEED) - playerUpgrades.bulletSpeed;
        playerUpgrades.bulletSpeed += added;
        showWarning(`💨 +${added.toFixed(1)} tốc độ đạn`);
        updateStatsOverlay();
      }
    });
  }

  // 🧨 Số lượng đạn – nếu chưa max
  if (playerUpgrades.lineBulletCount < MAX_LINE_BULLETS) {
    const tier = randomTier();
    const value = 1;
    allUpgrades.push({
      name: "🧨 số lượng đạn",
      key: "lineBulletCount",
      tier,
      value,
      effect: () => {
        playerUpgrades.lineBulletCount += value;
        showWarning(`🧨 +${value} viên mỗi hàng`);
        updateStatsOverlay();
      }
    });
  }

  // 👟 Tốc độ chạy – hiếm và chỉ 1 cấp (nếu chưa max)
  if (player.speed < MAX_MOVE_SPEED) {
    const value = UPGRADE_VALUES.Rare.moveSpeed;
    allUpgrades.push({
      name: "👟 Tốc độ chạy",
      key: "moveSpeed",
      tier: "Rare",
      value,
      effect: () => {
        player.speed = Math.min(player.speed + value, MAX_MOVE_SPEED);
        showWarning(`👟 +${value.toFixed(1)} tốc độ`);
        updateStatsOverlay();
      }
    });
  }
  
  // --- Nâng cấp kỹ năng Fairy ---
  // THÊM ĐIỀU KIỆN: Chỉ hiển thị nâng cấp khi người chơi đạt level 7
  if (player.level >= 7) {
    if (skillUpgrades.fairyCount < 3) {
      allUpgrades.push({
        name: `🦋 +1 Fairy (Tối đa 3)`,
        tier: "Kim",
        effect: () => {
          skillUpgrades.fairyCount++;
          showWarning(`🦋 Số lượng Fairy: ${skillUpgrades.fairyCount}`);
        }
      });
    } else {
      // Khi đã đủ 3 Fairy, bắt đầu nâng cấp chỉ số
      // Nâng cấp hồi máu
      const healTier = randomTier();
      const healValue = { Bạc: 1, Vàng: 2, Kim: 3 }[healTier];
      allUpgrades.push({
        name: `🦋 +${healValue} Hồi máu/giây`,
        tier: healTier,
        effect: () => {
          skillUpgrades.fairyHealLevel += healValue;
          showWarning(`🦋 Nâng cấp hồi máu!`);
        }
      });

      // Nâng cấp sát thương
      const dmgTier = randomTier();
      const dmgValue = { Bạc: 1, Vàng: 2, Kim: 3 }[dmgTier];
      allUpgrades.push({
        name: `🦋 +${dmgValue} Sát thương`,
        tier: dmgTier,
        effect: () => {
          skillUpgrades.fairyDamageLevel += dmgValue;
          showWarning(`🦋 Nâng cấp sát thương!`);
        }
      });
    }
  }
  
  // --- Nâng cấp Hồi máu cho Hào quang ---
  // THÊM ĐIỀU KIỆN: Chỉ hiển thị nâng cấp khi người chơi đạt level 6
  if (player.level >= 6) {
    const currentAuraHeal = 1 + skillUpgrades.auraHealLevel;
    if (currentAuraHeal < 5) { // Chỉ hiển thị nếu chưa đạt tối đa
      const tier = randomTier();
      const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];

      allUpgrades.push({
        name: `✨ +${value} Hồi máu`,
        tier: tier,
        effect: () => {
          skillUpgrades.auraHealLevel += value;
          const finalHeal = Math.min(1 + skillUpgrades.auraHealLevel, 5);
          showWarning(`✨ Hồi máu: ${finalHeal} HP/3s`);
          updateStatsOverlay(); // Cập nhật bảng thống kê nếu có
        }
      });
    }
  }

  // 🎲 Xáo trộn và chọn ngẫu nhiên 3 nâng cấp
  const choices = allUpgrades.sort(() => Math.random() - 0.5).slice(0, 3);
  // 🖱️ Tạo nút cho từng nâng cấp
  choices.forEach(up => {
    const btn = document.createElement("button");
    btn.innerText = up.name;
    btn.style.borderColor = TIER_COLORS[up.tier];
    btn.onclick = () => {
      playSound('sfx-upgrade-select'); // <-- THÊM ÂM THANH KHI CLICK
      up.effect();
      popup.classList.remove('visible'); // <-- Dùng class để ẩn popup
      isPaused = false;
      lastWaveTime = Date.now();

      if (pendingWave !== null) {
        setTimeout(() => {
          showWavePopup();
          pendingWave = null;
        }, 500);
      }
    };
    container.appendChild(btn);
  });

  popup.classList.add('visible'); // <-- Dùng class để hiện popup
  isPaused = true;
}
// 🛠️ Hiển thị thông báo khi nâng cấp thành công
// 🎲 Chọn bậc nâng cấp ngẫu nhiên theo tỷ lệ
function randomTier() {
  const tiers = ["Bạc", "Vàng", "Kim"];
  const weights = [0.7, 0.25, 0.05]; // tỷ lệ gặp: 60% Bạc, 30% Vàng, 10% Kim
  const r = Math.random();
  let sum = 0;
  for (let i = 0; i < tiers.length; i++) {
    sum += weights[i];
    if (r < sum) return tiers[i];
  }
  return "Bạc"; // fallback nếu có lỗi
}

// 🌟 Hiển thị popup chọn kỹ năng khi tăng level
/* ========= CẤU HÌNH ========= */
const MAX_LV = {                         // giới hạn số-lượng
  ufo        : 3,                        // UFO tấn công
  missile    : 5,                        // tên lửa F18
  lightning  : 5,                        // tia sét diện rộng
  satellite  : 2,                        // vệ tinh laze
  blackhole  : 2,                        // Hố đen
  bloodorb   : 2
};

/* tên ngắn → regex nhận diện chuỗi nâng cấp */
const UP_RX = {
  ufo       : /\+1 UFO/i,
  missile   : /\+1 tên lửa/i,
  lightning : /\+1 tia sét/i,
  satellite : /\+1 vệ tinh/i,
  blackhole : /\+1 hố đen/i,
  bloodorb  : /\+1 quả cầu/i
};

/* ========= TRỢ GIÚP ========= */
const rand    = arr => arr[Math.random() * arr.length | 0];          // pickRandom
const shuffle = a => a.sort(() => Math.random() - .5);               // Fisher–Yates 1-liner

/* kiểm tra 1 nâng cấp có “hết đát” chưa */
function isOverLimit(upgrade){
  const key = Object.keys(UP_RX).find(k => UP_RX[k].test(upgrade.name));
  if (!key) return false;                                            // gói sát thương, v.v.
  const active = activeSkills.find(s => s.name === upgrade.skillName);
  return active && (active.level || 0) >= MAX_LV[key];
}

/* ========= POPUP ========= */
function showSkillLevelUpPopup() {
  isPaused = true; // ⏸️
  const popup = document.getElementById('skillPopup');
  
  // Sửa lỗi: Lấy đúng container của popup kỹ năng thay vì popup nâng cấp wave
  const container = document.getElementById('skillChoices'); 
  container.innerHTML = '';

  /* 1️⃣ Lọc kỹ năng chưa học & nâng cấp hợp lệ */
  // THAY ĐỔI CỐT LÕI NẰM Ở ĐÂY
  // Lọc các kỹ năng chưa học VÀ người chơi đã đủ cấp độ yêu cầu
  const unlearned = skillsData.filter((skill, index) => {
    const requiredLevel = index + 1; // Skill ở vị trí 0 -> yêu cầu lv 1, vị trí 1 -> yêu cầu lv 2, ...
    return player.level >= requiredLevel && !activeSkills.includes(skill);
  });
  
  const upgrades = activeSkills
    .flatMap(sk => (sk.upgrades || []).map(up => ({ ...up, skillName: sk.name })))
    .filter(up => !isOverLimit(up)); // bỏ gói max

  /* 2️⃣ Ghép pool & chọn 3 lựa chọn */
  let choices;
  if (unlearned.length) { // Luôn ưu tiên có ≥1 skill mới nếu có thể
    const pickNew = rand(unlearned);
    const pool = [...unlearned.filter(s => s !== pickNew), ...upgrades];
    choices = [pickNew, ...shuffle(pool).slice(0, 2)];
  } else { // Đã học hết các kỹ năng có thể học ở level hiện tại
    const unique = {}; // mỗi skill 1 upgrade ngẫu nhiên
    upgrades.forEach(up => (unique[up.skillName] ||= []).push(up));
    choices = shuffle(Object.values(unique).map(rand)).slice(0, 3);
  }

  /* 3️⃣ Render nút bấm */
  choices.forEach(ch => {
    const btn = document.createElement('button');
    if (ch.icon){
      btn.textContent = `${ch.icon} ${ch.name}`;
      btn.onclick = () => {
        playSound('sfx-upgrade-select'); // <-- THÊM ÂM THANH
        learnSkill(skillsData.indexOf(ch));
        popup.style.display = 'none';
        isPaused = false;
      };
    } else {
      btn.textContent = ch.name;
      btn.style.borderColor = {Bạc:'#aaa',Vàng:'gold',Kim:'#c770ff',Đỏ:'red'}[ch.tier] || '#ccc';
      btn.onclick = () => {
        playSound('sfx-upgrade-select'); // <-- THÊM ÂM THANH
        ch.effect?.();
        showWarning(` ${ch.name}`);
        popup.style.display = 'none';
        isPaused = false;
      };
    }
    container.appendChild(btn);
  });

  popup.style.display = 'block';
}

// 🧾 Cập nhật thông tin thống kê trong overlay
function updateStatsOverlay() {
  /* 👇 1. Tính lại tổng mỗi lần vẽ */
  const alive  = zombies.length;      // đang còn trên bản đồ
  const killed = zombieKillCount;     // đã tiêu diệt
  const total  = alive + killed;      // tổng thực
document.getElementById("stat-damage").innerText =
  `💥 Sát thương: ${(playerUpgrades.damageBoost || 1).toFixed(1)}`;
  document.getElementById("stat-spawned").innerText = `🧟 Tổng số zombie: ${total}`;
  document.getElementById("stat-alive").innerText   = `🧟 Đang còn sống: ${alive}`;
  document.getElementById("stat-total").innerText   = `🧟 Đã tiêu diệt: ${killed}`;
  document.getElementById("stat-speed").innerText = `💨 Tốc độ: ${playerUpgrades.bulletSpeed.toFixed(1)}`;
  document.getElementById("stat-fireRate").innerText = `🔫 Hướng bắn: ${playerUpgrades.fireRate}`;
  document.getElementById("stat-lineCount").innerText = `🧨 Số lượng đạn: ${playerUpgrades.lineBulletCount}`;
  document.getElementById("stat-moveSpeed").innerText = `👟 Tốc độ chạy: ${player.speed.toFixed(1)}`;
  // 🔪 Thống kê kỹ năng mặc định
document.getElementById("stat-blade").innerText = `🔪 Đao: ${skillUpgrades.bladeCount} đao, ${skillUpgrades.bladeDamage.toFixed(1)} dmg`;
document.getElementById("stat-sword").innerText = `⚔️ Kiếm: Lv${skillUpgrades.swordLevel}, ${skillUpgrades.swordDamage.toFixed(1)} dmg`;
document.getElementById("stat-fire").innerText = `🔥 Lửa: ${skillUpgrades.fireCount} lửa, ${skillUpgrades.fireDamage.toFixed(1)} dmg`;
document.getElementById("stat-ice").innerText = `❄️ Băng: ${skillUpgrades.iceCount} băng, ${skillUpgrades.iceDamage.toFixed(1)} dmg`;
document.getElementById("stat-thunder").innerText = `🔵 Lôi: ${skillUpgrades.thunderCount} cầu, ${skillUpgrades.thunderDamage.toFixed(1)} dmg`;
// Kỹ năng khác
const skillText = Object.entries(skillStats)
    .map(([key, value]) => `${key}: ${value}`)
    .join("<br>");
    document.getElementById("stat-skills").innerHTML = skillText;

// 🧟 Zombie theo cấp: chỉ hiển thị từ Cấp 1 → 10
  let breakdown = "";
  for (let i = 1; i <= 10; i++) {
    breakdown += `<div>🧟 Cấp ${i}: ${zombieByLevel[i] || 0}</div>`;
  }

// 💀 Thống kê Mini Boss & Boss ở cuối
  const miniBossLine = `<div>💀 Mini Boss: ${zombieByLevel.miniBoss || 0}</div>`;
  const bossLine = `<div>💀 Boss: ${zombieByLevel.boss || 0}</div>`;
  const bigBossLine = `<div>💀 BigBoss: ${zombieByLevel.bigBoss || 0}</div>`;
  document.getElementById("stat-breakdown").innerHTML =
  breakdown + miniBossLine + bossLine + bigBossLine;
}
const activeSkills = [];

// Kỹ năng mẫu
const skillsData = [
  {
    name: "Khiên bảo vệ",
    icon: "🛡️",
    manaCost: 10,
    duration: 60000,
    description: "Tạo một vòng bảo vệ xung quanh người chơi chắn mọi sát thương."
  },
  {
    name: "Vệ tinh laze",
    icon: "🛰️",
    manaCost: 20,
    duration: 30000,
    baseDamage: 3,
    description: "Triệu hồi vệ tinh xoay quanh người chơi và bắn laze xuyên zombie."
  },
{
  name: "Tên lửa F18",
  icon: "🚀",
  manaCost: 25,
  duration: 30000,
  baseDamage: 6,
  description: "Gọi 1~5 tên lửa bay vòng tròn quanh người chơi và xuyên phá zombie.",
  upgrades: []
},
{
  name: "UFO tấn công",
  icon: "🛸",
  manaCost: 30,
  duration: 30000,
  baseDamage: 5,
  description: "Gọi UFO bay ngang màn hình, bắn laze đỏ xuống zombie mỗi giây.",
  upgrades: []
},
{
  name: "bão sét",
  icon: "🌩️",
  manaCost: 35,
  duration: 33000,
  baseDamage: 8,
  description: "Gọi sét ngẫu nhiên đánh quanh bản đồ.",
  upgrades: []
},
{
  name: "Bom B52",
  icon: "💣",
  manaCost: 52,
  duration: 52000,
  baseDamage: 10,
  description: "Máy bay mang theo Bom B52 thả hàng loạt tiêu diệt zombie."
},
  {
    name: "Ảo ảnh phân thân",
    icon: "🎭",
    manaCost: 20,
    duration: 45000,
    baseDamage: 5,
    description: "Triệu hồi 2 bản sao hỗ trợ bắn."
  },
  {
    name: "Hố đen",
    icon: "🕳️",
    manaCost: 60,
    duration: 30000,
    baseDamage: 7,
    description: "Tạo một hố đen hút zombie xung quanh."
  },
  {
    name: "Biến hình",
    icon: "🐸",
    manaCost: 5,
    duration: 10000,
    description: "Giả dạng thành ếch đồng  thời tăng tốc chạy, zombie sẽ bỏ đi không tấn công trong 5s."
  },
  {
    name: "Boom hạt nhân",
    icon: "☢️",
    manaCost: 100,
    duration: 20000,
    baseDamage: 100,
    description: "Bom hạt nhân phát nổ toàn bản đồ, sát thương cực lớn."
  },
{
    name: "Quả cầu hấp huyết",
    icon: "🩸",
    manaCost: 25,
    duration: 25000,
    baseDamage: 2,
    description: "Triệu hồi quả cầu đỏ bay quanh người chơi.\nMỗi giây hút máu zombie gần nhất, gây sát thương và hồi 1 HP.",
    upgrades: []
},
{
    name: "Cổng Không Gian",
    icon: "🌀",
    manaCost: 50,
    duration: 30000,
    baseDamage: 10,
    description: "Mở một cổng dịch chuyển trong 30 giây. Bước vào cổng sẽ đưa bạn đến một vị trí ngẫu nhiên an toàn trên bản đồ."
  },
];
/* đặt sau khai báo skillsData */
const skillTooltipMap = Object.fromEntries(
  skillsData.map(sk => [
    sk.name,
    `${sk.icon} ${sk.name}\n─ Mana ${sk.manaCost}💠, ${sk.duration/1000}s\n${sk.description}`
  ])
);

// 🧪 Thêm nâng cấp cho từng kỹ năng có baseDamage
skillsData.forEach(skill => {
  if (skill.baseDamage !== undefined) {
      skill.upgrades = [
{
        name: `${skill.icon} +1 sát thương`,
        tier: "Bạc",
        effect: () => { skill.baseDamage += 1; 
        updateSkillsList(); 
}
},
{
      name: `${skill.icon} +2 sát thương`,
      tier: "Vàng",
      effect: () => { skill.baseDamage += 2;
      updateSkillsList();
}
},
{
        name: `${skill.icon} +3 sát thương`,
        tier: "Kim",
        effect: () => { skill.baseDamage += 3;
        updateSkillsList();
}
}
];

    if (skill.name === "bão sét") {
    skill.upgrades.push({
    name: "🌩️ +1 tia sét (tối đa 5)",
    tier: "Đỏ",
    effect: () => {
  const skill = activeSkills.find(s => s.name === "bão sét");
  if (skill) {
    skill.level = (skill.level || 0) + 1;
    showWarning("🌩️ +1 tia sét!");
    updateSkillsList();
}
}
});
}
if (skill.name === "Hố đen") {
  skill.upgrades.push({
    name: "🕳️ +1 hố đen (tối đa 2)",
    tier: "Đỏ",
    effect: () => {
      const skill = activeSkills.find(s => s.name === "Hố đen");
      if (skill) {
        skill.level = Math.min((skill.level || 0) + 1, 2); // +1 tới tối đa 2 hố đen
        showWarning("🕳️ +1 hố đen!");
        updateSkillsList();
      }
    }
  });
}

if (skill.name === "Vệ tinh laze") {
  skill.upgrades.push({
    name: "🛰️ +1 vệ tinh (tối đa 2)",
    tier: "Đỏ",
    effect: () => {
      const skill = activeSkills.find(s => s.name === "Vệ tinh laze");
      if (skill) {
        skill.level = Math.min((skill.level || 0) + 1, 2); // +1 tới tối đa 2 vệ tinh
        showWarning("🛰️ +1 vệ tinh!");
        updateSkillsList();
}
}
});
}

if (skill.name === "UFO tấn công") {
  skill.upgrades.push({
    name: "🛸 +1 UFO (tối đa 3)",
    tier: "Đỏ",
effect: () => {
  const skill = activeSkills.find(s => s.name === "UFO tấn công");
  if (skill) {
    skill.level = (skill.level || 0) + 1;
    showWarning("🛸 +1 UFO!");
    updateSkillsList();
}
}
});
}

// 🎯 Nếu là kỹ năng Tên lửa thì thêm nâng cấp số lượng
    if (skill.name === "Tên lửa F18") {
      skill.upgrades.push({
        name: `${skill.icon} +1 tên lửa (tối đa 5)`,
        tier: "Đỏ",
effect: () => {
  const skill = activeSkills.find(s => s.name === "Tên lửa F18");
  if (skill) {
    skill.level = (skill.level || 0) + 1;
    showWarning("🚀 +1 tên lửa!");
    updateSkillsList();
}
}
});
}
if (skill.name === "Quả cầu hấp huyết") {
    skill.upgrades.push({
        name: "🩸 +1 quả cầu (tối đa 2)",
        tier: "Đỏ",
        effect: () => {
            const skill = activeSkills.find(s => s.name === "Quả cầu hấp huyết");
            if (skill) {
                skill.level = Math.min((skill.level || 0) + 1, 2);
                showWarning("🩸 +1 Quả cầu!");
                updateSkillsList();
            }
        }
    });
}
}
});
// 🔍 Ghép mô tả chi tiết cho mỗi skill
function buildSkillTooltip(skill) {
  const secs = (skill.duration ?? 0) / 1000;
  const rows = [
    `${skill.icon} ${skill.name}`,
    `Mana: ${skill.manaCost}💠  •  Thời gian: ${secs ? secs + " s" : "tức thì"}`,
  ];

  // --- Sát thương hiện tại (nếu có) ---
  if (skill.baseDamage !== undefined)
    rows.push(`Sát thương: ${skill.baseDamage}`);

  // --- Level hiện tại của các nâng cấp đỏ ---
  if (skill.level !== undefined)
    rows.push(`Cấp hiện tại: ${skill.level}`);

  // --- Danh sách nâng cấp khả dụng ---
  /*if (skill.upgrades?.length) {
    rows.push("Nâng cấp:");
    skill.upgrades.forEach(u => rows.push(`• ${u.name}  [${u.tier}]`));
  }*/

  // --- Mô tả gốc --- "", chèn trước mô tả nếu có
  if (skill.description) rows.push(`Mô tả: ${skill.description}`);

  return rows.join("\n");
}
// 🧪 Hàm học kỹ năng mới
function updateSkillsList() {
    const list = document.getElementById('skills-list');
    list.innerHTML = ''; // Xóa các item cũ
    
    // Tạo lại các item trong danh sách kỹ năng
    activeSkills.forEach(skill => {
        const div = document.createElement('div');
        div.className = 'skill-item';
        div.dataset.tooltip = buildSkillTooltip(skill);

        const now = Date.now();
        
        // Xử lý khi kỹ năng đang trong thời gian hồi chiêu
        if (skill.endTime && now < skill.endTime) {
            const remain = Math.ceil((skill.endTime - now) / 1000);
            div.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${remain}s`;
            div.classList.add('active');
            div.style.pointerEvents = 'none'; // Vô hiệu hóa click khi đang hồi chiêu
        } else {
            // Xử lý khi kỹ năng đã sẵn sàng
            if (skill.endTime) {
                skill.endTime = null;
            }
            const canUse = player.mana >= skill.manaCost;
            div.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${skill.manaCost}💠`;
            
            if (canUse) {
                // Nếu đủ mana, gán sự kiện click (sử dụng onmousedown để tránh lỗi)
                div.onmousedown = () => activateSkill(skill);
            } else {
                // Nếu không đủ mana, chỉ làm mờ đi để vẫn xem được tooltip
                div.style.opacity = 0.5;
            }
        }
        list.appendChild(div);
    });

    // Gán lại sự kiện cho tooltip (giữ nguyên logic gốc của bạn)
    document.querySelectorAll('#skills-list .skill-item[data-tooltip]').forEach(it => {
        it.addEventListener('mouseenter', () => {
            const ln = (it.dataset.tooltip.match(/\n/g)?.length || 0) + 1;
            const hTip = ln * 18 + 12;
            const r = it.getBoundingClientRect();
            const gap = 8;
            const overTop = Math.max(gap - r.top, 0);
            const overBottom = Math.max((r.top + hTip) - (innerHeight - gap), 0);
            const shiftValue = overTop - overBottom;
            it.style.setProperty('--tip-shift', `${shiftValue}px`);
        });

        it.addEventListener('mouseleave', () => {
            it.style.removeProperty('--tip-shift');
        });
    });
}
// 🧪 Test: Thêm kỹ năng bất kỳ bằng phím số 1–9, 0
document.addEventListener("keydown", (e) => {
    // THÊM DÒNG KIỂM TRA:
    // Nếu người dùng đang gõ trong một ô INPUT, hãy thoát ra ngay và không làm gì cả.
    if (e.target.tagName === 'INPUT') {
        return;
    }

    const keys = "1234567890-=";
    const index = keys.indexOf(e.key);

    // Nếu phím được nhấn nằm trong danh sách phím test
    if (index >= 0 && skillsData[index]) {
        // Gọi trực tiếp hàm learnSkill để đảm bảo logic đồng nhất
        learnSkill(index);
    }
});

function activateSkill(skill) {
  // Kiểm tra nếu không đủ mana hoặc kỹ năng đang hồi chiêu
  if (!skill || player.mana < skill.manaCost || (skill.endTime && Date.now() < skill.endTime)) {
    return;
  }
  playSound('sfx-ui-click', 0.2); // Phát âm thanh khi kích hoạt kỹ năng
  player.mana -= skill.manaCost;
  // Gán thời gian kết thúc hồi chiêu vào chính đối tượng skill
  skill.endTime = Date.now() + skill.duration;

  // Logic kích hoạt hiệu ứng của kỹ năng (giữ nguyên)
  switch (skill.name) {
    case "Khiên bảo vệ": activateShield(skill); break;
    case "Vệ tinh laze":
      // --- BẮT ĐẦU ĐOẠN MÃ MỚI ---
      satelliteActive = true;
      satelliteEndTime = Date.now() + skill.duration;
      
      const satCount = Math.min(skill.level || 1, 2);
      const orbitRadius = 60; // Bạn có thể chỉnh bán kính quay ở đây
      const orbitSpeed = 0.002; // Bạn có thể chỉnh tốc độ quay ở đây

      satellites = []; // Xóa các vệ tinh cũ
      for (let i = 0; i < satCount; i++) {
          satellites.push({
              // Gán cho mỗi vệ tinh một góc ban đầu để chúng cách đều nhau
              angle: (2 * Math.PI / satCount) * i, 
              orbitRadius: orbitRadius,
              orbitSpeed: orbitSpeed
          });
      }
      showWarning(`${skill.icon} ${skill.name}!`); // Giữ lại thông báo
      // --- KẾT THÚC ĐOẠN MÃ MỚI ---
      break;
    case "Tên lửa F18": activateTwinMissiles(skill); break;
    case "UFO tấn công": activateUFO(skill); break;
    case "bão sét": activateLightning(skill); break;
    case "Bom B52": activateBombs(skill); break;
    case "Ảo ảnh phân thân": activateClones(skill); break;
    case "Hố đen": activateBlackHole(skill); break;
    case "Biến hình": activateDisguise(skill); break;
    case "Boom hạt nhân": activateNuclearBomb(skill); break;
    case "Quả cầu hấp huyết": activateBloodOrb(skill); break;
    case "Cổng Không Gian": activateSpaceGate(skill); break;
  }

// Làm sáng nút kỹ năng tương ứng và đếm ngược
const list = document.getElementById('skills-list').children;
for (let i = 0; i < list.length; i++) {
  const item = list[i];
  if (item.textContent.includes(skill.name)) {
    item.classList.add("active");
    const endTime = Date.now() + skill.duration;
    const interval = setInterval(() => {
      const remain = Math.ceil((endTime - Date.now()) / 1000);
      if (remain > 0) {
        item.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${remain}s`;
} else {
        item.classList.remove("active");
        item.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${skill.manaCost}💠`;
        clearInterval(interval);
}
}, 1000);
break;
}
}
// Hiển thị thông báo kỹ năng đã kích hoạt
  showWarning(`${skill.icon} ${skill.name}!`);
}
// 🧟‍♂️ Kỹ năng: Tạo các kỹ năng đặc biệt cho người chơi
// 🛡️ Khiên bảo vệ: Tạo lớp chắn chặn sát thương và hiển thị hiệu ứng
function activateShield(skill) {
  player.shieldActive = true;
  player.shieldEndTime = Date.now() + skill.duration;

  setTimeout(() => {
    player.shieldActive = false;
}, skill.duration);
}

// 🚀 Tên lửa F18: 2 tên lửa bay quanh người chơi, xuyên và gây sát thương zombie
function activateTwinMissiles(skill) {
const createMissilePair = () => {
    // 1. Lọc ra những zombie còn sống và trong phạm vi 360px quanh người chơi
    const potentialTargets = zombies.filter(z => z.active && distance(player, z) <= 360);

    // 2. Nếu không có mục tiêu nào trong tầm, không làm gì cả
    if (potentialTargets.length === 0) return;

    // 3. Sắp xếp các mục tiêu để tìm ra con xa nhất
potentialTargets.sort((a, b) => distance(player, b) - distance(player, a));
// Bây giờ potentialTargets là một danh sách đã được sắp xếp từ xa đến gần

// Lấy số lượng tên lửa từ cấp kỹ năng
const missileCount = Math.min(skill.level || 1, 5);
for (let i = 0; i < missileCount; i++) {
    // Nếu không còn đủ mục tiêu trong danh sách, dừng tạo tên lửa
    if (i >= potentialTargets.length) break;

    // THAY ĐỔI: Gán mỗi tên lửa cho một mục tiêu khác nhau theo thứ tự từ xa đến gần
    const target = potentialTargets[i]; 
    
    const angleOffset = Math.random() * Math.PI * 2;
    const radius = 40;
    const x = player.x + Math.cos(angleOffset) * radius;
    const y = player.y + Math.sin(angleOffset) * radius;

    missiles.push({
        x, y,
        dx: 0,
        dy: 0,
        target, // <-- Mỗi tên lửa giờ đã có mục tiêu riêng
        damage: skill.baseDamage,
        delay: 120,
        state: "delay",
        startX: x,
        startY: y,
        hitSet: new Set()
    });
}
};

// 🟢 Tạo NGAY lập tức
  createMissilePair();

// ⏱ Sau đó tiếp tục tạo mỗi 2s
  const interval = setInterval(createMissilePair, 2000);
  setTimeout(() => clearInterval(interval), skill.duration);
}

// UFO tấn công
function activateUFO(skill) {
  ufoActive = true;
  ufoEndTime = Date.now() + skill.duration;
  
  // Xác định số lượng UFO dựa trên cấp kỹ năng
  const ufoCount = Math.min(skill.level || 3, 3); // Tối đa 3 UFO
  const damage = skill.baseDamage;

ufos = Array.from({ length: ufoCount }, (_, i) => {
    // Thời gian ngẫu nhiên từ 1-3 giây cho mỗi lần đổi hướng
    const interval = 1000 + Math.random() * 2000; 

    return {
        relativeX: 80 + Math.random() * 120,
        relativeY: 120 + Math.random() * 120,
        speedX: (Math.random() - 0.5) * 2,
        speedY: (Math.random() - 0.5) * 1.5,
        
        // THÊM VÀO:
        directionChangeInterval: interval, // Khoảng thời gian giữa 2 lần đổi hướng
        nextDirectionChangeTime: Date.now() + interval, // Mốc thời gian để đổi hướng tiếp theo

    damage,
    laserCooldown: Date.now() + Math.random() * 1000, // Thời gian bắn ngẫu nhiên lúc đầu
    laserLife: 0,
    angle: 0
};
});
  // Xóa UFO sau khi hết thời gian kỹ năng
  setTimeout(() => {
    ufoActive = false;
    ufos = [];
  }, skill.duration);
}

// === Helper: vẽ đường sét ngoằn ngoèo =========================
function getZigZag(start, target, segments = 8, jitter = 20) {
  const pts = [start];                         // điểm đầu là đám mây
  for (let i = 1; i < segments; i++) {
    const t = i / segments;                    // nội suy tuyến tính
    pts.push({
      x: start.x + (target.x - start.x) * t + (Math.random() - 0.5) * jitter,
      y: start.y + (target.y - start.y) * t + (Math.random() - 0.5) * jitter
    });
  }
    pts.push({
      x: target.x + (Math.random() - 0.5) * jitter,
      y: target.y + (Math.random() - 0.5) * jitter
});
  return pts;                                  // mảng [{x,y}, …]
}

// 🌩️ bão sét: Gọi sét ngẫu nhiên gây sát thương diện rộng
function activateLightning(skill) {
    lightningActive = true;
    lightningStartTime = Date.now(); // Sử dụng biến này làm mốc thời gian bắt đầu
    lightningEndTime = lightningStartTime + skill.duration;

    const boltCount = Math.min(skill.level || 5, MAX_LV.lightning);
    lightningBolts = []; // Reset lại các đám mây
    for (let i = 0; i < boltCount; i++) {
    lightningBolts.push({
        // Đã xóa offsetX
        damage: skill.baseDamage,
        nextZapTime: Date.now() + Math.random() * 1000 // Thời gian cho lần phóng sét tiếp theo
        });
    }
    
    // Hẹn giờ để tắt kỹ năng
    setTimeout(() => {
        lightningActive = false;
        lightningBolts = [];
    }, skill.duration);
}

// Kích hoạt kỹ năng Bom B52 - tái sử dụng hàm activateBombs
function spawnPlanes(skill, amount = 3) {
  const planeYBase = player.y - 180; // Vị trí máy bay bắt đầu

  for (let i = 0; i < amount; i++) {
    const plane = {
      x: -100,
      y: planeYBase - i * 20,
      targetY: planeYBase - i * 20,
      vx: 1.5 + i * 0.5,
      lastDropTime: Date.now(),
      nextDropDelay: 5000 + i * 500 + Math.random() * 300,

      // 👇 Hiệu ứng biến mất
      scale: 1,
      opacity: 1,
      disappearing: false
    };

    activePlanes.push(plane);

    // ✅ Cập nhật tốc độ ngang mỗi 1–5 giây
    function schedulePlaneSpeedAdjust() {
      const delay = Math.random() * (5000 - 1000) + 1000;
      plane._speedTimeout = setTimeout(() => {
        plane.vx = Math.random() * (5 - 0.5) + 0.5;
        schedulePlaneSpeedAdjust(); // Gọi lại để lặp
      }, delay);
    }

    // ✅ Cập nhật độ cao dao động mỗi 1–5 giây
    function schedulePlaneHeightAdjust() {
      const delay = Math.random() * (5000 - 1000) + 1000;
      plane._heightTimeout = setTimeout(() => {
        plane.targetY += (Math.random() - 0.5) * 40; // dao động ±20
        schedulePlaneHeightAdjust(); // Lặp tiếp
      }, delay);
    }

    // 🔄 Kích hoạt 2 chu kỳ điều chỉnh
    schedulePlaneSpeedAdjust();
    schedulePlaneHeightAdjust();

    // 🎮 Cập nhật chuyển động và thả bom định kỳ
    const planeInterval = setInterval(() => {
      const now = Date.now();

      // ➡ Di chuyển theo tốc độ hiện tại
      plane.x += plane.vx;

      // 📈 Bay mượt đến targetY
      plane.y += (plane.targetY - plane.y) * 0.05;

      // 💣 Thả bom nếu đến thời điểm
      if (now - plane.lastDropTime > plane.nextDropDelay) {
        plane.lastDropTime = now;
        plane.nextDropDelay = 1000 + Math.random() * 2000; // từ 1–3s

        const targetY = plane.y + 100 + Math.random() * (canvas.height * 0.9); // 90%
        bombsB52.push({
          x: plane.x,
          y: plane.y,
          vy: 3,
          exploded: false,
          landed: false,
          finalY: targetY,
          timerAfterLand: 180,
          radius: 15,
          damage: skill.baseDamage
        });
      }

      // 🌀 Khi gần rìa map thì bắt đầu biến mất
      if (!plane.disappearing && plane.x > worldWidth - 180) {
        plane.disappearing = true;
      }

      // 🧼 Hiệu ứng thu nhỏ và xoá máy bay
      if (plane.disappearing) {
        plane.scale *= 0.95;
        plane.opacity -= 0.05;

        if (plane.scale < 0.1 || plane.opacity <= 0) {
          clearInterval(planeInterval);
          clearTimeout(plane._speedTimeout);
          clearTimeout(plane._heightTimeout);
          activePlanes.splice(activePlanes.indexOf(plane), 1);
        }
      }
    }, 50);
  }
}
const planeWaves = [
  { delay: 0, amount: 1 },      // tạo 3 máy bay ngay lập tức
  { delay: 3000, amount: 1 },  // tạo 5 máy bay sau 30s
  { delay: 6000, amount: 1 },
  { delay: 9000, amount: 1 },  // tạo 2 máy bay sau 60s
];
// 💣 Bom B52: rơi xuống, nổ khi trúng zombie, nếu không trúng thì nổ sau 5s khi chạm đất
function activateBombs(skill) {
  const skillEndTime = Date.now() + skill.duration;

  planeWaves.forEach(wave => {
    setTimeout(() => {
      spawnPlanes(skill, wave.amount);
    }, wave.delay);
  });
  // 💣 Update bom rơi như cũ
  const updateInterval = setInterval(() => {
    for (let i = bombsB52.length - 1; i >= 0; i--) {
      const bomb = bombsB52[i];
      if (bomb.exploded) continue;

      if (!bomb.landed) {
        bomb.y += bomb.vy;
        for (let z of zombies) {
          if (z.active && distance(bomb, z) < bomb.radius + z.radius) {
            explodeB52Bomb(bomb);
            bombsB52.splice(i, 1);
            break;
          }
        }
        if (bomb.y >= bomb.finalY) {
          bomb.y = bomb.finalY;
          bomb.landed = true;
        }
      } else {
        bomb.timerAfterLand--;
        if (bomb.timerAfterLand <= 0) {
          explodeB52Bomb(bomb);
          bombsB52.splice(i, 1);
        }
      }
    }

    if (Date.now() > skillEndTime && bombsB52.length === 0) {
      clearInterval(updateInterval);
    }
  }, 1000 / 60);

function explodeB52Bomb(bomb) {
    bomb.exploded = true;

    // ✨ BẮT ĐẦU PHẦN CẢI TIẾN ✨
    // 1. Vụ nổ chính (100% sát thương)
    zombies.forEach(z => {
        if (z.active && distance(bomb, z) < 200) { // Bán kính nổ 200px
            dealDamageToZombie(z, bomb.damage);
        }
    });
    createParticleExplosion(bomb.x, bomb.y, 50, 'fire'); // Hiệu ứng nổ chính

    // 2. Vụ nổ phụ (50% sát thương) sau 0.2 giây
    setTimeout(() => {
        zombies.forEach(z => {
            if (z.active && distance(bomb, z) < 200) {
                // Gây thêm 50% sát thương
                dealDamageToZombie(z, bomb.damage * 0.5); 
            }
        });
        // Tạo một vụ nổ nhỏ hơn để báo hiệu
        const secondaryExplosion = getExplosion(bomb.x, bomb.y);
        secondaryExplosion.life = 15;
        explosions.push(secondaryExplosion);
    }, 200); // 200ms = 0.2 giây
    // ✨ KẾT THÚC PHẦN CẢI TIẾN ✨
}
}
// 🎭 Ảo ảnh phân thân: Tạo 2 bản sao bắn đạn hỗ trợ
function activateClones(skill) {
  clonesActive = true;
  clonesEndTime = Date.now() + skill.duration;
  clones = [];

  const moveAngle = Math.random() * Math.PI * 2; // hướng di chuyển chung

  for (let i = 0; i < 2; i++) {
    const offset = (i === 0 ? -40 : 40); // clone trái và phải cách nhau 80px
    clones.push({
      x: player.x + Math.cos(moveAngle + Math.PI / 2) * offset,
      y: player.y + Math.sin(moveAngle + Math.PI / 2) * offset,
      moveAngle: moveAngle,
      moveSpeed: 1.2,                     // Tốc độ di chuyển clone
      baseDamage: skill.baseDamage || 5, // Sát thương riêng
      lastShot: 0,
      id: Date.now() + i, // Tạo 1 ID tia lazer
      shotCount: 0
    });
  }
}
// 🕳️ Hố đen: Hút zombie vào tâm và gây sát thương liên tục
function activateBlackHole(skill) {
  const holeCount = Math.min(skill.level || 2, 2);
  
  // ✨ THAY ĐỔI: Tách biệt kích thước và phạm vi hút
  const VISUAL_RADIUS = 150;  // Kích thước hố đen sẽ được vẽ trên màn hình
  const PULL_RADIUS = 200; // Phạm vi hút zombie xung quanh

  const firstAngle = Math.random() * Math.PI * 2;

  for (let i = 0; i < holeCount; i++) {
    const angle = firstAngle + (i * Math.PI);
    const distance = 80 + Math.random() * 80;

    const x = player.x + Math.cos(angle) * distance;
    const y = player.y + Math.sin(angle) * distance;

    blackHoles.push({
      x: x,
      y: y,
      radius: VISUAL_RADIUS,     // Gán kích thước VẼ
      pullRadius: PULL_RADIUS,   // ✨ THÊM MỚI: Gán phạm vi HÚT
      damage: skill.baseDamage,
      pullSpeed: 3.5,
      tick: 0,
      endTime: Date.now() + skill.duration,
      dx: (Math.random() - 0.5) * 0.1,
      dy: (Math.random() - 0.5) * 0.1
    });
  }
}

// 🐸 Biến hình: Zombie tạm thời không phát hiện người chơi (ẩn thân)
function activateDisguise(skill) {
  disguiseActive = true;
  disguiseEndTime = Date.now() + skill.duration;

  // (MỚI) Buff tạm thời khi kích hoạt
  player.hearts += 20;
  showWarning("🐸 Biến hình! +20 HP & Tăng tốc!");

  zombies.forEach(z => {
    if (!z.isBoss) {
      z.state = "wandering";
      z.wanderTime = Date.now() + 6000 + Math.random() * 4000;// Thời gian đi lang thang ngẫu nhiên từ 6s đến 10s
      z.wanderAngle = Math.random() * Math.PI * 2;

      // 💬 Biểu cảm ngẫu nhiên nếu không phải boss
      if (Math.random() < 0.6) {
        const expressions = ["😕", "🤢", "😴", "😳", "🤮"];
        z.iconToDraw = expressions[Math.floor(Math.random() * expressions.length)];
        setTimeout(() => { z.iconToDraw = null; }, 5000); // Biểu cảm biến mất sau 5s
      }
    }
  });
// Khi hết thời gian
setTimeout(() => {
    disguiseActive = false;
    player.hearts = Math.max(1, player.hearts - 20);
    showWarning("🐸 Hết biến hình!");

    // --- LOGIC BOM KHÓI ---
    // 1. Tạo hiệu ứng khói hình ảnh
    createParticleExplosion(player.x, player.y, 70, 'smoke');

    // 2. Đẩy lùi và làm choáng zombie ở gần
    const pushRadius = 300;
    const pushForce = 30;

    zombies.forEach(z => {
        if (z.active && distance(player, z) < pushRadius) {
            const angle = Math.atan2(z.y - player.y, z.x - player.x);
            z.x += Math.cos(angle) * pushForce;
            z.y += Math.sin(angle) * pushForce;
            z.state = "wandering"; // Buộc zombie đi lang thang
        }
    });

}, skill.duration);

}
// Màu cho bom hạt nhân khi phát nổ
const colors = [
    "rgba(255,255,255,0.7)", // trắng
    "rgba(255,0,0,0.7)",     // đỏ
    "rgba(0,255,0,0.7)",     // xanh lá
    "rgba(0,200,255,0.7)",   // cyan
    "rgba(255,200,0,0.7)",   // vàng
    "rgba(255,0,255,0.7)"    // tím
];
// ☢️ Bom Hạt Nhân: Rơi xuống giữa màn hình, đếm ngược 5s rồi tạo vòng nổ lan rộng
function activateNuclearBomb(skill) {
    if (nuclearBombs.length >= 1) return;
    document.getElementById('sfx-nuke-fall').play(); // Phát âm thanh bom rơi
    nuclearBombs.push({
        x: player.x,
        y: 100,
        vy: 3.5,
        exploded: false,
        landed: false,
        timerAfterLand: 5 * 60,
        damage: skill.baseDamage * 10,
        radius: 22,
        finalY: player.y,
        shockwave: false,
        shockwaveRadius: 0,
        shockwaveSpeed: 2
    });
    const updateInterval = setInterval(() => {
        if (nuclearBombs.length === 0) {
            clearInterval(updateInterval);
            return;
        }

        const bomb = nuclearBombs[0];
        if (bomb.exploded && !bomb.shockwave) return;
        // 💨 Khi bom chạm đất – tạo hạt bụi bay vào tâm bom
        if (bomb.landed && !bomb.exploded) {
        for (let i = 0; i < 2; i++) {
        createSuctionDust(bomb.x, bomb.y, 0.6); // Tốc độ tan nhanh chậm
        }
        }
        // Bom rơi xuống
        if (!bomb.landed) {
            bomb.y += bomb.vy;
            if (bomb.y >= bomb.finalY) {
                bomb.landed = true;
                bomb.y = bomb.finalY;
                playSound('sfx-nuke-time', 0.8); // Phát âm thanh đếm giờ
            }
        }
        // Đếm ngược nổ
        else if (!bomb.exploded) {
            bomb.timerAfterLand--;
            if (bomb.timerAfterLand <= 0) {
                explodeNuclearBomb(bomb);
            }
        }

        // Sóng xung kích sau khi nổ
        if (bomb.exploded && bomb.shockwave) {
            bomb.shockwaveRadius += bomb.shockwaveSpeed;
            zombies.forEach(z => {
                if (z.active && distance(bomb, z) < bomb.shockwaveRadius) {
                    // Chỉ gây sát thương nếu zombie không có cooldown
                    if (!z.nukeCooldown || Date.now() > z.nukeCooldown) {
                        dealDamageToZombie(z, bomb.damage);
                        
                        // Đặt lại cooldown 1 giây cho con zombie này
                        z.nukeCooldown = Date.now() + 1000; // 1s mới nhận lại sát thương
                    }
                }
            });
            enemyBullets.forEach(b => {
                if (!b.active) return;
                if (distance(bomb, b) < bomb.shockwaveRadius) {
                    releaseEnemyBullet(b);
                    explosions.push(getExplosion(b.x, b.y));
                }
            });
            if (bomb.shockwaveRadius > Math.max(canvas.width, canvas.height) * 1.4) {
                nuclearBombs.shift();
                bomb.shockwave = false;
            }
        }
    }, 1000 / 60);
    // Hàm phát nổ
    function explodeNuclearBomb(bomb) {
        // Dừng âm thanh còi hú/rơi
        const fallSound = document.getElementById('sfx-nuke-fall');
        if (fallSound) {
            fallSound.pause();
            fallSound.currentTime = 0; // Reset để lần sau có thể phát lại từ đầu
        }
        // Phát âm thanh nổ
        playSound('sfx-nuke-explode', 1.0); // Phát ở 100% âm lượng

        bomb.exploded = true;
        bomb.shockwave = true;
        bomb.shockwaveRadius = 0;
        explosions.push(getExplosion(bomb.x, bomb.y)); // 💥 hiệu ứng nổ nhỏ trung tâm
        // 🌊 Thêm 2 vòng nổ phụ mỗi 2 giây
        setTimeout(() => {
            extraShockwaves.push({
                x: bomb.x,
                y: bomb.y,
                radius: 0,
                maxRadius: 300,
                color: "red",
                alpha: 1
            });
        }, 2000);
        setTimeout(() => {
            extraShockwaves.push({
                x: bomb.x,
                y: bomb.y,
                radius: 0,
                maxRadius: 400,
                color: "cyan",
                alpha: 1
            });
        }, 4000);
        // 💨 Hạt bụi bay ra khi bom phát nổ
        for (let i = 0; i < 60; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 1 + 0.5;
    const color = colors[Math.floor(Math.random() * colors.length)]; // màu ngẫu nhiên
    particles.push({
        x: bomb.x,
        y: bomb.y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: Math.random() * 3 + 1,
        color: color,
        alpha: 1
    });
}
}
}
// 🩸 Quả cầu hấp huyết
function activateBloodOrb(skill) {
    bloodOrbActive = true;
    bloodOrbEndTime = Date.now() + skill.duration;

    // Xác định số lượng quả cầu theo level (tối đa 2)
    const maxCount = Math.min(skill.level || 2, 2); // Tối đa 2 quả cầu hấp huyết
    bloodOrbCount = maxCount;

    bloodOrbs = Array.from({ length: maxCount }, (_, i) => ({
        angle: (2 * Math.PI / maxCount) * i,
        radius: 60,
        x: player.x,
        y: player.y
    }));
}
// ================== CỔNG KHÔNG GIAN ==================

// Hàm tìm một vị trí an toàn để dịch chuyển đến
function findSafeTeleportLocation() {
    let bestLocation = null;
    let lowestZombieCount = Infinity;
    const MAX_ATTEMPTS = 20; // Thử tìm 20 lần và chọn điểm tốt nhất

    const bosses = zombies.filter(z => z.isBoss || z.isBigBoss);

    for (let i = 0; i < MAX_ATTEMPTS; i++) {
        // Tạo vị trí ngẫu nhiên trong bản đồ, trừ đi vùng rìa
        const padding = 100;
        const x = Math.random() * (worldWidth - padding * 2) + padding;
        const y = Math.random() * (worldHeight - padding * 2) + padding;
        
        let isValid = true;

        // 1. Kiểm tra khoảng cách với Boss
        for (const boss of bosses) {
            if (distance({x, y}, boss) < 500) {
                isValid = false;
                break;
            }
        }
        if (!isValid) continue; // Bỏ qua vị trí này nếu quá gần boss

        // 2. Đếm số lượng zombie xung quanh
        let nearbyZombies = 0;
        for (const z of zombies) {
            if (distance({x, y}, z) < 300) {
                nearbyZombies++;
            }
        }

        // 3. Chọn vị trí có ít zombie nhất
        if (nearbyZombies < lowestZombieCount) {
            lowestZombieCount = nearbyZombies;
            bestLocation = { x, y };
        }
    }

    // Nếu không tìm được vị trí nào, trả về một vị trí ngẫu nhiên xa người chơi
    if (!bestLocation) {
        return {
            x: Math.random() * worldWidth,
            y: Math.random() * worldHeight
        };
    }
    
    return bestLocation;
}

// Hàm tạo một cổng mới
function createNewGate(x, y) {
    const safeX = Math.max(wallThickness + 60, Math.min(worldWidth - wallThickness - 60, x));
    const safeY = Math.max(wallThickness + 60, Math.min(worldHeight - wallThickness - 60, y));
    const initialRadius = 40; // Bán kính ban đầu
    spaceGate = {
        x: safeX,
        y: safeY,
        radius: initialRadius,
        originalRadius: initialRadius, // ✨ THÊM DÒNG NÀY: Lưu lại bán kính gốc
        damage: 2,
        rotation: 0,
        alpha: 0 // Vẫn giữ alpha để cổng mới hiện ra mượt mà
    };
}

// Hàm kích hoạt chính
function activateSpaceGate(skill) {
  // Nếu đã có cổng rồi thì không tạo nữa
  if (spaceGateActive) return;

  spaceGateActive = true;
  spaceGateEndTime = Date.now() + skill.duration;

  // Tạo cổng ngay trước mặt người chơi một khoảng
  // Xác định hướng dựa trên phím đang nhấn, hoặc ngẫu nhiên nếu đứng yên
  const angle = (keys.a || keys.d || keys.w || keys.s) 
                ? Math.atan2((keys.s ? 1 : 0) - (keys.w ? 1 : 0), (keys.d ? 1 : 0) - (keys.a ? 1 : 0))
                : (zombies.length > 0 ? Math.atan2(zombies[0].y - player.y, zombies[0].x - player.x) : 0);
  const distance = 150;

  createNewGate(player.x + Math.cos(angle) * distance, player.y + Math.sin(angle) * distance, skill.baseDamage);
}

// Hàm tạo cổng mới (thay thế hàm cũ)
function createNewGate(x, y, damage) {
    // Giới hạn vị trí cổng không bị tạo ra ngoài bản đồ
    const safeX = Math.max(wallThickness + 60, Math.min(worldWidth - wallThickness - 60, x));
    const safeY = Math.max(wallThickness + 60, Math.min(worldHeight - wallThickness - 60, y));

    spaceGate = {
        x: safeX,
        y: safeY,
        radius: 50,       // Bán kính hiệu ứng của cổng
        damage: damage,   // Sát thương cơ bản
        rotation: 0,
        alpha: 0,         // Độ mờ ban đầu (để làm hiệu ứng hiện ra)
        particles: []     // Mảng chứa các hạt lửa trang trí
    };
}
// 📌 Bật/tắt bảng kỹ năng bằng phím X
document.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'x') {
    document.getElementById('skillsOverlay').classList.toggle('hidden');
    updateSkillsList();
  }
});

// Thêm kỹ năng mới (gọi hàm này khi lên cấp)
function learnSkill(index) {
  const skill = skillsData[index];
if (!activeSkills.includes(skill)) {
  activeSkills.push(skill);
  /* SỬA khối gán level */
  skill.level = 1;              // ← luôn bắt đầu ở cấp 1
if (skill.baseDamage !== undefined && skill.level === undefined) {
  skill.level = 0;
}
  updateSkillsList();
  showWarning(`🎉 Học kỹ năng: ${skill.icon} ${skill.name}`);
}
}

// 🎯 Phím Z để bật/tắt bảng thống kê
document.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "z") {
    const panel = document.getElementById("statsOverlay");
    panel.classList.toggle("hidden");
}
});

// 🎯 Gán phím ` để bật/tắt FPS
document.addEventListener("keydown", (e) => {
  if (e.key === "`") {
    const fpsDiv = document.getElementById("fpsCounter");
    fpsDiv.style.display = fpsDiv.style.display === "none" ? "block" : "none";
}
});
function showGuide() {
  playSound('sfx-ui-click', 0.2);
  document.getElementById("guideOverlay").style.display = "block";
}
function hideGuide() {
  playSound('sfx-ui-click', 0.2);
  document.getElementById("guideOverlay").style.display = "none";
}
function showInfo() {
  playSound('sfx-ui-click', 0.2);
  document.getElementById("infoOverlay").style.display = "block";
}
function hideInfo() {
  playSound('sfx-ui-click', 0.2);
  document.getElementById("infoOverlay").style.display = "none";
}

// --- LOGIC CHO DEBUG MENU (Phiên bản thanh kéo) ---

// Hàm mở/đóng menu
function toggleDebugMenu() {
    const debugMenu = document.getElementById('debugMenu');
    if (!debugMenu) return;

    const isHidden = debugMenu.classList.toggle('hidden');
    isPaused = !isHidden;

    if (!isHidden) {
        populateDebugMenu();
    }
}

// HÀM CẬP NHẬT: Điền giá trị vào menu
function populateDebugMenu() {
    const setSliderValue = (id, value) => {
        const slider = document.getElementById(id);
        if (slider) {
            slider.value = value;
            const valueSpan = slider.nextElementSibling;
            if (valueSpan) {
                if (slider.step.includes('.')) {
                    valueSpan.textContent = parseFloat(value).toFixed(1);
                } else {
                    valueSpan.textContent = value;
                }
            }
        }
    };

    // Chỉ số cơ bản & game
    document.getElementById('debug-exp').value = player.exp;
    setSliderValue('debug-wave', wave);
    setSliderValue('debug-dayTime', (dayTime * 24).toFixed(1));
    setSliderValue('debug-level', player.level);
    setSliderValue('debug-hp', player.hearts);
    setSliderValue('debug-mana', player.mana);
    setSliderValue('debug-energy', player.energy);
    setSliderValue('debug-moveSpeed', player.speed);
    setSliderValue('debug-damage', playerUpgrades.damageBoost);
    setSliderValue('debug-fireRate', playerUpgrades.fireRate);
    setSliderValue('debug-bulletSpeed', playerUpgrades.bulletSpeed);
    setSliderValue('debug-lineCount', playerUpgrades.lineBulletCount);
    setSliderValue('debug-coin', player.coins);
    
    // Chỉ số kỹ năng passive
    setSliderValue('debug-bladeCount', skillUpgrades.bladeCount);
    setSliderValue('debug-bladeDamage', skillUpgrades.bladeDamage);
    setSliderValue('debug-swordLevel', skillUpgrades.swordLevel);
    setSliderValue('debug-swordDamage', skillUpgrades.swordDamage);
    setSliderValue('debug-fireCount', skillUpgrades.fireCount);
    setSliderValue('debug-fireDamage', skillUpgrades.fireDamage);
    setSliderValue('debug-iceCount', skillUpgrades.iceCount);
    setSliderValue('debug-iceDamage', skillUpgrades.iceDamage);
    setSliderValue('debug-thunderCount', skillUpgrades.thunderCount);
    setSliderValue('debug-thunderDamage', skillUpgrades.thunderDamage);
    setSliderValue('debug-auraHealLevel', skillUpgrades.auraHealLevel);
    setSliderValue('debug-fairyCount', skillUpgrades.fairyCount);
    setSliderValue('debug-fairyHealLevel', skillUpgrades.fairyHealLevel);
    setSliderValue('debug-fairyDamageLevel', skillUpgrades.fairyDamageLevel);

    // Cập nhật giá trị cho các thanh trượt kỹ năng active
    skillsData.forEach(skill => {
        const learnedSkill = activeSkills.find(s => s.name === skill.name);
        const currentData = learnedSkill || skill;
        const safeIdName = skill.name.replace(/\s/g, '-');

        if (document.getElementById(`debug-level-${safeIdName}`)) {
            setSliderValue(`debug-level-${safeIdName}`, currentData.level || 1);
        }
        if (document.getElementById(`debug-damage-${safeIdName}`)) {
            setSliderValue(`debug-damage-${safeIdName}`, currentData.baseDamage);
        }
    });
}

// HÀM CẬP NHẬT: Áp dụng các thay đổi
function applyDebugChanges() {
    // Chỉ số cơ bản & game (giữ nguyên)
    player.exp = parseInt(document.getElementById('debug-exp').value);
    player.currentLevelExp = player.exp;
    wave = parseInt(document.getElementById('debug-wave').value);
    dayTime = parseFloat(document.getElementById('debug-dayTime').value) / 24;
    updateWaveUI();
    player.level = parseInt(document.getElementById('debug-level').value);
    player.hearts = parseInt(document.getElementById('debug-hp').value);
    player.mana = parseInt(document.getElementById('debug-mana').value);
    player.energy = parseInt(document.getElementById('debug-energy').value);
    player.speed = parseFloat(document.getElementById('debug-moveSpeed').value);
    playerUpgrades.damageBoost = parseFloat(document.getElementById('debug-damage').value);
    playerUpgrades.fireRate = parseInt(document.getElementById('debug-fireRate').value);
    playerUpgrades.bulletSpeed = parseFloat(document.getElementById('debug-bulletSpeed').value);
    playerUpgrades.lineBulletCount = parseInt(document.getElementById('debug-lineCount').value);
    player.coins = parseInt(document.getElementById('debug-coin').value);

    // Chỉ số kỹ năng passive (giữ nguyên)
    skillUpgrades.bladeCount = parseInt(document.getElementById('debug-bladeCount').value);
    skillUpgrades.bladeDamage = parseFloat(document.getElementById('debug-bladeDamage').value);
    skillUpgrades.swordLevel = parseInt(document.getElementById('debug-swordLevel').value);
    skillUpgrades.swordDamage = parseFloat(document.getElementById('debug-swordDamage').value);
    skillUpgrades.fireCount = parseInt(document.getElementById('debug-fireCount').value);
    skillUpgrades.fireDamage = parseFloat(document.getElementById('debug-fireDamage').value);
    skillUpgrades.iceCount = parseInt(document.getElementById('debug-iceCount').value);
    skillUpgrades.iceDamage = parseFloat(document.getElementById('debug-iceDamage').value);
    skillUpgrades.thunderCount = parseInt(document.getElementById('debug-thunderCount').value);
    skillUpgrades.thunderDamage = parseFloat(document.getElementById('debug-thunderDamage').value);
    skillUpgrades.auraHealLevel = parseInt(document.getElementById('debug-auraHealLevel').value);
    skillUpgrades.fairyCount = parseInt(document.getElementById('debug-fairyCount').value);
    skillUpgrades.fairyHealLevel = parseInt(document.getElementById('debug-fairyHealLevel').value);
    skillUpgrades.fairyDamageLevel = parseInt(document.getElementById('debug-fairyDamageLevel').value);
    
    // --- BẮT ĐẦU SỬA LỖI LOGIC KỸ NĂNG ACTIVE ---
    skillsData.forEach(skill => {
        const safeIdName = skill.name.replace(/\s/g, '-');
        const levelSlider = document.getElementById(`debug-level-${safeIdName}`);
        const damageSlider = document.getElementById(`debug-damage-${safeIdName}`);
        let hasChanges = false;

        const learnedSkill = activeSkills.find(s => s.name === skill.name);
        const currentData = learnedSkill || skill;

        if (levelSlider) {
            const newLevel = parseInt(levelSlider.value);
            if (newLevel !== (currentData.level || 1)) {
                skill.level = newLevel;
                hasChanges = true;
            }
        }
        
        if (damageSlider) {
            const newDamage = parseFloat(damageSlider.value);
            if (newDamage !== currentData.baseDamage) {
                skill.baseDamage = newDamage;
                hasChanges = true;
            }
        }
        
        // Nếu có thay đổi và kỹ năng chưa được học -> tự động học
        if (hasChanges && !activeSkills.includes(skill)) {
            // Đảm bảo gán level 1 khi học lần đầu, giống như hàm learnSkill()
            if (skill.level === undefined) {
                skill.level = 1;
            }
            activeSkills.push(skill);
        }
    });
    // --- KẾT THÚC SỬA LỖI ---

    updateUI();
    updateStatsOverlay();
    // QUAN TRỌNG: Gọi updateSkillsList() ở cuối để làm mới giao diện kỹ năng và tooltip
    updateSkillsList(); 
    showWarning('🔧 Các chỉ số đã được cập nhật!');
}

// Đợi cho đến khi toàn bộ tài liệu HTML được tải xong rồi mới chạy mã bên trong
document.addEventListener('DOMContentLoaded', function () {

    // --- BẮT ĐẦU: NỘI DUNG TỪ KHỐI DOMContentLoaded THỨ NHẤT ---

    // Gán sự kiện nhấn phím '/' và 'o'
    document.addEventListener('keydown', (e) => {
        switch (e.key) {
            case '/':
                e.preventDefault();
                if (debugKeyTimer === null) {
                    debugKeyTimer = setTimeout(() => {
                        toggleDebugMenu();
                        debugKeyTimer = null;
                    }, 500); // Đợi 0.5 giây trước khi mở menu
                }
                break;

            case 'o':
                if (gameStarted && !gameOver) {
                    toggleShop();
                }
                break;
        }
    });

    // Bắt sự kiện khi người dùng THẢ phím `/` RA
    document.addEventListener('keyup', (e) => {
        if (e.key === '/') {
            if (debugKeyTimer) {
                clearTimeout(debugKeyTimer);
                debugKeyTimer = null;
            }
        }
    });

    // Gán sự kiện cho các nút bấm "Áp dụng" và "Đóng"
    const applyBtn = document.getElementById('applyDebugChanges');
    if (applyBtn) {
        applyBtn.onclick = applyDebugChanges;
    }

    const closeBtn = document.getElementById('closeDebugMenu');
    if (closeBtn) {
        closeBtn.onclick = toggleDebugMenu;
    }

    // Gán sự kiện 'input' cho tất cả thanh kéo để cập nhật số hiển thị khi người dùng kéo
    const sliders = document.querySelectorAll('#debugMenu input[type="range"]');
    sliders.forEach(slider => {
        const valueSpan = slider.nextElementSibling;
        if (valueSpan) {
            slider.addEventListener('input', () => {
                if (slider.step.includes('.')) {
                    valueSpan.textContent = parseFloat(slider.value).toFixed(1);
                } else {
                    valueSpan.textContent = slider.value;
                }
            });
        }
    });

    // Tự động phát bài hát ngẫu nhiên khác khi một bài hát bình thường kết thúc
    normalMusicTracks.forEach(id => {
        const track = document.getElementById(id);
        if (track) {
            track.addEventListener('ended', function () {
                if (currentMusicState === 'normal') {
                    playRandomNormalMusic();
                }
            });
        }
    });

    // Gán sự kiện nút đóng Shop
    const closeShopBtn = document.getElementById('closeShopBtn');
    if (closeShopBtn) {
        closeShopBtn.onclick = toggleShop;
    }

    // --- KẾT THÚC: NỘI DUNG TỪ KHỐI DOMContentLoaded THỨ NHẤT ---

    // --- BẮT ĐẦU: NỘI DUNG TỪ KHỐI DOMContentLoaded THỨ HAI ---

    // Bắt sự kiện phím ESC
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (gameStarted && !gameOver) {
                togglePauseMenu();
            }
        }
    });

    // Gán sự kiện cho các nút trong Pause Menu
    document.getElementById('resumeBtn').onclick = togglePauseMenu;
    document.getElementById('restartBtnPause').onclick = () => location.reload();
    document.getElementById('guideBtnPause').onclick = showGuide;
    document.getElementById('infoBtnPause').onclick = showInfo;
    document.getElementById('exitBtn').onclick = () => location.reload();

    // Gán sự kiện cho các thanh trượt âm lượng
    const masterSlider = document.getElementById('volume-master');
    const musicSlider = document.getElementById('volume-music');
    const sfxSlider = document.getElementById('volume-sfx');

    if (masterSlider) {
        masterSlider.addEventListener('input', () => {
            masterVolume = parseFloat(masterSlider.value);
            masterSlider.nextElementSibling.textContent = `${Math.round(masterVolume*100)}%`;
            updateAllMusicVolume();
        });
    }
    if (musicSlider) {
        musicSlider.addEventListener('input', () => {
            musicVolume = parseFloat(musicSlider.value);
            musicSlider.nextElementSibling.textContent = `${Math.round(musicVolume*100)}%`;
            updateAllMusicVolume();
        });
    }
    if (sfxSlider) {
        sfxSlider.addEventListener('input', () => {
            sfxVolume = parseFloat(sfxSlider.value);
            sfxSlider.nextElementSibling.textContent = `${Math.round(sfxVolume*100)}%`;
        });
    }

    // --- KẾT THÚC: NỘI DUNG TỪ KHỐI DOMContentLoaded THỨ HAI ---
    
}); // <-- Kết thúc khối DOMContentLoaded duy nhất
// --- LOGIC CHO PAUSE MENU ---

function togglePauseMenu() {
    const menu = document.getElementById('pauseMenu');
    if (!menu) return; // Thêm kiểm tra để tránh lỗi

    const isHidden = menu.classList.toggle('hidden');
    isPaused = !isHidden;
    
    // Khi mở menu, cập nhật giá trị các thanh trượt về giá trị hiện tại
    if (!isHidden) {
        document.getElementById('volume-master').value = masterVolume;
        document.getElementById('volume-music').value = musicVolume;
        document.getElementById('volume-sfx').value = sfxVolume;
        // Cập nhật text hiển thị %
        document.querySelector('#volume-master + .range-value').textContent = `${Math.round(masterVolume*100)}%`;
        document.querySelector('#volume-music + .range-value').textContent = `${Math.round(musicVolume*100)}%`;
        document.querySelector('#volume-sfx + .range-value').textContent = `${Math.round(sfxVolume*100)}%`;
    }
}

</script>
<!-- 🌟 Popup khi lên cấp -->
<div id="levelUpPopup">Level Up!</div>
<!-- 🌟 Popup chọn nâng cấp -->
<div id="upgradePopup">
  <h3 class="upgradeTitle">⏫ Chọn nâng cấp</h3>
  <div id="upgradeChoices" class="upgradeChoices"></div>
</div>

<!-- 📊 Overlay hiển thị thống số kỹ năng -->
<div id="statsOverlay" class="hidden">
  <h3>📊 Thống kê</h3>
  <div id="highScoreDisplay" style="text-align: center; font-weight: 300; margin: 2px 0; position: relative; top: -6px;">
  🏆 Kỷ lục: 0
  </div>
  <div id="stat-moveSpeed">👟 Tốc độ chạy: - </div>
  <div id="stat-damage">💥 Sát thương: - </div>
  <div id="stat-fireRate">🔫 Hướng bắn: - </div>
  <div id="stat-speed">💨 Tốc độ: - </div>
  <div id="stat-lineCount">🧨 Số lượng đạn: - </div>
  <div id="stat-blade">🔪 Đao: -</div>
  <div id="stat-sword">⚔️ Kiếm: -</div>
  <div id="stat-fire">🔥 Lửa: -</div>
  <div id="stat-ice">❄️ Băng: -</div>
  <div id="stat-thunder">🔵 Lôi: -</div>
  <div id="stat-skills"></div> <!-- kỹ năng khác -->
  <div id="stat-spawned">🧟 Tổng số zombie: 0</div>
  <div id="stat-alive">🧟 Đang còn sống: 0</div>
  <div id="stat-total">🧟 Đã tiêu diệt: 0</div>
  <div id="stat-breakdown">
    <!-- sẽ được cập nhật bằng JS -->
  </div>
</div>
<!-- 📚 Bảng Kỹ Năng Active mở bằng phím X -->
<div id="skillsOverlay" class="hidden">
<h3>📚 Kỹ năng Active</h3>
<div id="ui-mana" style="text-align: center; font-weight: 300; margin: 2px 0; position: relative; top: -2px;">💠 Mana: 0</div>
<div id="skills-list"></div>
</div>

<!-- 🎯 Hiển thị FPS realtime -->
<div id="fpsCounter" style="
  display: none;
  position: fixed;
  top: 0.2rem;
  left: 0.3rem;
  color: lime;
  background: rgba(0, 0, 0, 0);
  padding: 0.4rem 0.8rem;
  border-radius: 0.5rem;
  font-family: monospace;
  font-size: 0.9rem;
  z-index: 9999;
  pointer-events: none;
">
FPS: --
</div>
<!-- 🎓 Popup kỹ năng khi lên cấp -->
<div id="skillPopup">
  <h3>🎓 Chọn kỹ năng hoặc nâng cấp</h3>
  <div class="upgradeChoices" id="skillChoices"></div>
</div>
<div id="notificationContainer" aria-live="polite"></div>

<!-- Bảng menu gỡ lỗi (Debug Menu) -->
<div id="debugMenu" class="infoOverlay hidden">
  <h3>🔧 Debug Menu </h3>
  <div class="debug-grid">
    
    <label for="debug-level">🧑‍🦰 Level:</label>
    <div class="range-container">
      <input type="range" id="debug-level" min="1" max="100" step="1">
      <span class="range-value">1</span>
    </div>
    <label for="debug-hp">❤️ HP:</label>
    <div class="range-container">
      <input type="range" id="debug-hp" min="1" max="1000" step="1">
      <span class="range-value">10</span>
    </div>
    <label for="debug-mana">💠 Mana:</label>
    <div class="range-container">
      <input type="range" id="debug-mana" min="0" max="1000" step="1">
      <span class="range-value">10</span>
    </div>
    <label for="debug-energy">⚡ Energy:</label>
    <div class="range-container">
      <input type="range" id="debug-energy" min="0" max="1000" step="1">
      <span class="range-value">10</span>
    </div>
    <label for="debug-coin">🪙 Coin:</label>
    <div class="range-container">
      <input type="range" id="debug-coin" min="0" max="1000" step="1">
      <span class="range-value">10</span>
    </div>
    <label for="debug-moveSpeed">👟 Tốc độ chạy:</label>
    <div class="range-container">
      <input type="range" id="debug-moveSpeed" min="0.5" max="5" step="0.1">
      <span class="range-value">1.0</span>
    </div>
    <label for="debug-damage">💥 Sát thương:</label>
    <div class="range-container">
      <input type="range" id="debug-damage" min="1" max="100" step="0.5">
      <span class="range-value">1.0</span>
    </div>
    <label for="debug-fireRate">🔫 Hướng bắn:</label>
    <div class="range-container">
      <input type="range" id="debug-fireRate" min="1" max="21" step="1">
      <span class="range-value">1</span>
    </div>
    <label for="debug-bulletSpeed">💨 Tốc độ đạn:</label>
    <div class="range-container">
      <input type="range" id="debug-bulletSpeed" min="0.5" max="10" step="0.1">
      <span class="range-value">1.0</span>
    </div>
    <label for="debug-lineCount">🧨 Số lượng đạn:</label>
    <div class="range-container">
      <input type="range" id="debug-lineCount" min="1" max="10" step="1">
      <span class="range-value">1</span>
    </div>
    <h4 class="debug-subtitle" colspan="2">Trạng thái Game</h4>

    <label for="debug-exp">Exp:</label>
    <input type="number" id="debug-exp" class="custom-input" min="0" max="999999">

    <label for="debug-wave">Wave:</label>
    <div class="range-container">
      <input type="range" id="debug-wave" min="1" max="100" step="1">
      <span class="range-value">1</span>
    </div>

    <label for="debug-dayTime">Giờ trong ngày:</label>
    <div class="range-container">
      <input type="range" id="debug-dayTime" min="0" max="23.5" step="0.5">
      <span class="range-value">6.0</span>
    </div>

    <h4 class="debug-subtitle" colspan="2">Kỹ năng Active</h4>
    <div id="debug-active-skills-container" class="debug-skill-grid">
        
        <div class="debug-skill-wrapper">
            <h5>🛰️ Vệ tinh laze</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-Vệ-tinh-laze">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-Vệ-tinh-laze" min="1" max="2" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-Vệ-tinh-laze">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Vệ-tinh-laze" min="0" max="100" step="1" value="3"><span class="range-value">3</span></div>
            </div>
        </div>

        <div class="debug-skill-wrapper">
            <h5>🚀 Tên lửa F18</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-Tên-lửa-F18">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-Tên-lửa-F18" min="1" max="5" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-Tên-lửa-F18">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Tên-lửa-F18" min="0" max="100" step="1" value="6"><span class="range-value">6</span></div>
            </div>
        </div>

        <div class="debug-skill-wrapper">
            <h5>🛸 UFO tấn công</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-UFO-tấn-công">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-UFO-tấn-công" min="1" max="3" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-UFO-tấn-công">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-UFO-tấn-công" min="0" max="100" step="1" value="5"><span class="range-value">5</span></div>
            </div>
        </div>
        
        <div class="debug-skill-wrapper">
            <h5>🌩️ bão sét</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-bão-sét">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-bão-sét" min="1" max="5" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-bão-sét">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-bão-sét" min="0" max="100" step="1" value="8"><span class="range-value">8</span></div>
            </div>
        </div>
        
        <div class="debug-skill-wrapper">
            <h5>💣 Bom B52</h5>
            <div class="debug-skill-controls">
                <label for="debug-damage-Bom-B52">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Bom-B52" min="0" max="100" step="1" value="10"><span class="range-value">10</span></div>
            </div>
        </div>

        <div class="debug-skill-wrapper">
            <h5>🎭 Ảo ảnh phân thân</h5>
            <div class="debug-skill-controls">
                <label for="debug-damage-Ảo-ảnh-phân-thân">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Ảo-ảnh-phân-thân" min="0" max="100" step="1" value="5"><span class="range-value">5</span></div>
            </div>
        </div>

        <div class="debug-skill-wrapper">
            <h5>🕳️ Hố đen</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-Hố-đen">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-Hố-đen" min="1" max="2" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-Hố-đen">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Hố-đen" min="0" max="100" step="1" value="7"><span class="range-value">7</span></div>
            </div>
        </div>

        <div class="debug-skill-wrapper">
            <h5>☢️ Boom hạt nhân</h5>
            <div class="debug-skill-controls">
                <label for="debug-damage-Boom-hạt-nhân">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Boom-hạt-nhân" min="0" max="200" step="5" value="100"><span class="range-value">100</span></div>
            </div>
        </div>
        
        <div class="debug-skill-wrapper">
            <h5>🩸 Quả cầu hấp huyết</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-Quả-cầu-hấp-huyết">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-Quả-cầu-hấp-huyết" min="1" max="2" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-Quả-cầu-hấp-huyết">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Quả-cầu-hấp-huyết" min="0" max="100" step="1" value="2"><span class="range-value">2</span></div>
            </div>
        </div>
        
        <div class="debug-skill-wrapper">
            <h5>🌀 Cổng Không Gian</h5>
            <div class="debug-skill-controls">
                <label for="debug-damage-Cổng-Không-Gian">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Cổng-Không-Gian" min="0" max="100" step="1" value="99"><span class="range-value">99</span></div>
            </div>
        </div>
    </div>

    <h4 class="debug-subtitle" colspan="2">Nâng cấp Kỹ năng</h4>

    <label for="debug-bladeCount">🔪 Số lượng đao:</label>
    <div class="range-container">
        <input type="range" id="debug-bladeCount" min="2" max="20" step="1">
        <span class="range-value">2</span>
    </div>
    <label for="debug-bladeDamage">🔪 Sát thương đao:</label>
    <div class="range-container">
        <input type="range" id="debug-bladeDamage" min="1" max="50" step="0.5">
        <span class="range-value">1.0</span>
    </div>
    <label for="debug-swordLevel">⚔️ Cấp mưa kiếm:</label>
    <div class="range-container">
        <input type="range" id="debug-swordLevel" min="1" max="10" step="1">
        <span class="range-value">1</span>
    </div>
    <label for="debug-swordDamage">⚔️ Sát thương kiếm:</label>
    <div class="range-container">
        <input type="range" id="debug-swordDamage" min="1" max="50" step="0.5">
        <span class="range-value">1.0</span>
    </div>
    <label for="debug-fireCount">🔥 Số lượng lửa:</label>
    <div class="range-container">
        <input type="range" id="debug-fireCount" min="2" max="10" step="1">
        <span class="range-value">2</span>
    </div>
    <label for="debug-fireDamage">🔥 Sát thương lửa:</label>
    <div class="range-container">
        <input type="range" id="debug-fireDamage" min="1" max="50" step="0.5">
        <span class="range-value">1.0</span>
    </div>
    <label for="debug-iceCount">❄️ Số lượng băng:</label>
    <div class="range-container">
        <input type="range" id="debug-iceCount" min="2" max="10" step="1">
        <span class="range-value">2</span>
    </div>
    <label for="debug-iceDamage">❄️ Sát thương băng:</label>
    <div class="range-container">
        <input type="range" id="debug-iceDamage" min="1" max="50" step="0.5">
        <span class="range-value">1.0</span>
    </div>
    <label for="debug-thunderCount">🔵 Số lượng lôi:</label>
    <div class="range-container">
        <input type="range" id="debug-thunderCount" min="2" max="6" step="1">
        <span class="range-value">2</span>
    </div>
    <label for="debug-thunderDamage">🔵 Sát thương lôi:</label>
    <div class="range-container">
        <input type="range" id="debug-thunderDamage" min="1" max="50" step="0.5">
        <span class="range-value">1.0</span>
    </div>
<label for="debug-auraHealLevel">✨ Cấp hồi máu Aura:</label>
    <div class="range-container">
        <input type="range" id="debug-auraHealLevel" min="0" max="5" step="1">
        <span class="range-value">0</span>
    </div>

    <label for="debug-fairyCount">🦋 Số lượng Fairy:</label>
    <div class="range-container">
        <input type="range" id="debug-fairyCount" min="1" max="3" step="1">
        <span class="range-value">1</span>
    </div>

    <label for="debug-fairyHealLevel">🦋 Cấp hồi máu Fairy:</label>
    <div class="range-container">
        <input type="range" id="debug-fairyHealLevel" min="0" max="10" step="1">
        <span class="range-value">0</span>
    </div>
    
    <label for="debug-fairyDamageLevel">🦋 Cấp sát thương Fairy:</label>
    <div class="range-container">
        <input type="range" id="debug-fairyDamageLevel" min="0" max="10" step="1">
        <span class="range-value">0</span>
    </div>

  </div>
  <div class="debug-buttons">
    <button id="applyDebugChanges">Áp dụng</button>
    <button id="closeDebugMenu">Đóng</button>
  </div>
</div>

<!--Menu game ESC-->
<div id="pauseMenu" class="infoOverlay hidden">
  <h2>Tạm dừng</h2>
  
  <div class="settings-section">
    <h3>Âm thanh</h3>
    <div class="debug-grid">
      <label for="volume-master">Âm lượng Tổng:</label>
      <div class="range-container">
        <input type="range" id="volume-master" min="0" max="1" step="0.05" value="1">
        <span class="range-value">100%</span>
      </div>
      
      <label for="volume-music">Nhạc nền:</label>
      <div class="range-container">
        <input type="range" id="volume-music" min="0" max="1" step="0.05" value="0.5">
        <span class="range-value">50%</span>
      </div>

      <label for="volume-sfx">Hiệu ứng (SFX):</label>
      <div class="range-container">
        <input type="range" id="volume-sfx" min="0" max="1" step="0.05" value="0.8">
        <span class="range-value">80%</span>
      </div>
    </div>
  </div>

  <div class="pause-menu-buttons">
    <button id="resumeBtn">Tiếp tục</button>
    <button id="restartBtnPause">Chơi lại</button>
    <button id="guideBtnPause">Hướng dẫn</button>
    <button id="infoBtnPause">Thông tin</button>
    <button id="exitBtn">Về Menu chính</button>
  </div>
</div>
<!-- ℹ️ Overlay Shop -->
<div id="shopOverlay" class="infoOverlay hidden">
  <h2><i class="fas fa-store"></i> Cửa hàng Zombie Survivor </h2>
  <div class="shop-balance">Xu: <span id="shopCoinBalance">0</span> 🪙</div>
  
  <div id="shopItemsContainer" class="shop-grid">
    </div>

  <div class="shop-buttons">
    <button id="closeShopBtn">Đóng</button>
  </div>
</div>

<!-- 🎵 Âm thanh nền và hiệu ứng âm thanh -->
<audio id="music-background" src="sounds/background-music.mp3"></audio>
<audio id="music-background-2" src="sounds/background-music-2.mp3"></audio>
<audio id="music-background-3" src="sounds/background-music-3.mp3"></audio>
<audio id="music-boss" src="sounds/boss-music.mp3" loop></audio>

<audio id="sfx-shoot" src="sounds/shoot.mp3"></audio>
<audio id="sfx-zombie-die" src="sounds/zombie-die.mp3"></audio>
<audio id="sfx-pickup" src="sounds/pickup.mp3"></audio>
<audio id="sfx-pickup-coin" src="sounds/pickup-coin.mp3"></audio>
<audio id="sfx-level-up" src="sounds/level-up.mp3"></audio>
<audio id="sfx-laser" src="sounds/laser.mp3"></audio>
<audio id="sfx-bigboss-laser" src="sounds/bigboss-laser.mp3" loop></audio>
<audio id="sfx-nuke-fall" src="sounds/nuke-fall.mp3"></audio>
<audio id="sfx-nuke-explode" src="sounds/nuke-explode.mp3"></audio>
<audio id="sfx-lazer-charging" src="sounds/lazer-charging.mp3" loop></audio>
<audio id="sfx-shield-block" src="sounds/shield-block.mp3"></audio>
<audio id="sfx-game-over" src="sounds/game-over.mp3"></audio>
<audio id="sfx-player-hurt" src="sounds/player-hurt.mp3"></audio>
<audio id="sfx-player-explode" src="sounds/player-explode.mp3"></audio>
<audio id="sfx-powerup" src="sounds/powerup.mp3"></audio>
<audio id="sfx-game-start" src="sounds/game-start.mp3"></audio>
<audio id="sfx-ui-click" src="sounds/ui-click.mp3"></audio>
<audio id="sfx-lucky-loop" src="sounds/lucky-active-loop.mp3" loop></audio>
<audio id="sfx-power-loop" src="sounds/power-active-loop.mp3" loop></audio>
<audio id="sfx-upgrade-select" src="sounds/upgrade-select.mp3"></audio>
<audio id="sfx-wave-up" src="sounds/wave-up.mp3"></audio>
<audio id="sfx-nuke-time" src="sounds/nuke-time.mp3"></audio>
<audio id="sfx-crazy-loop" src="sounds/crazy-active-loop.mp3" loop></audio>
<audio id="sfx-exp-loop" src="sounds/exp-active-loop.mp3" loop></audio>
<audio id="sfx-supply-drop-item" src="sounds/supply-drop-item.mp3"></audio>

</body>
</html>
